{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GNU Toolchain for ARC User Manual","text":""},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#linker-fails-with-error-undefined-reference-to-_exit","title":"Linker fails with error: <code>undefined reference to _exit</code>","text":"<p>Among other possible functions are also <code>_sbrk</code>, <code>_write</code>, <code>_close</code>, <code>_lseek</code>, <code>_read</code>, <code>_fstat</code>, <code>_isatty</code>.</p> <p>Function <code>_exit</code> is not provided by the <code>libc</code> itself, but must be provided by the <code>libgloss</code>, which is basically a BSP (board support package). Currently several <code>libgloss</code> implementations are provided for ARC:</p> <ul> <li><code>libnosys</code> - a generic implementation with stubs.</li> <li><code>libnsim</code> - implements nSIM and QEMU IO hostlink (GNU version).</li> <li><code>libqemu</code> - implements a simplified IO hostlink for QEMU.</li> <li><code>libhl</code> - implements nSIM IO hostlink (MetaWare version).</li> <li><code>libiotdk_uart</code>, <code>libhsdk_uart</code>, <code>libemsk_uart</code> - implementations for development boards.</li> </ul> <p>In general <code>libnosys</code> is more suitable for hardware targets that does not have hostlink support, however other implementations have a distinct advantage that on exit from an application and in case of many errors it halts the core, while <code>libnosys</code> causes it to infinite loop on one place.</p>"},{"location":"faq/#ive-opened-hs38tcf-and-gcc-options-include-mcpuhs34-why-hs34-instead-of-hs38","title":"I\u2019ve opened <code>hs38.tcf</code> and GCC options include <code>-mcpu=hs34</code>. Why <code>hs34</code> instead of <code>hs38</code>?","text":"<p>Possible values of <code>-mcpu=</code> options are orthogonal to names of IPlib templates and respective TCF. GCC option <code>-mcpu=</code> supports both <code>hs34</code> and <code>hs38</code> values, but they are different - <code>hs38</code> enables more features, like <code>-mll64</code> which are not present in <code>hs34</code>. ARC HS IPlib template <code>hs38</code> doesn\u2019t contain double-word load/store, therefore -mcpu=hs38 is not compatible with this template. <code>-mcpu=hs34</code>, however, is compatible and that is why TCF generator uses this value. Refer Target Specific Options page for a full list of possible <code>-mcpu</code> values and what IPlibrary templates they correspond to.</p>"},{"location":"faq/#there-are-cant-resolve-symbol-error-messages-when-using-gdbserver-on-linux-for-arc-targets","title":"There are <code>can\u2019t resolve symbol</code> error messages when using <code>gdbserver</code> on Linux for ARC targets","text":"<p>This error message might appear when <code>gdbserver</code> is a statically linked application. Even though it is linked statically, <code>gdbserver</code> still opens <code>libthread_db.so</code> library using <code>dlopen()</code> function. There is a circular dependency here, as <code>libthread_db.so</code> expects several dynamic symbols to be already defined in the loading application (<code>gdbserver</code> in this case). However statically linked <code>gdbserver</code> does not export those dynamic symbols, therefore <code>dlopen()</code> invocation causes those error messages. In practice there have not been noticed any downside of this, even when debugging applications with threads, however that was tried only with simple test cases. To fix this issue, either rebuild gdbserver as a dynamically linked application, or pass option <code>--with-libthread-db=-lthread_db</code> to configure script of script. In this case gdbserver will link with <code>libthread_db</code> statically, instead of opening it with <code>dlopen()</code> and dependency on symbols will be resolved at link time.</p>"},{"location":"faq/#gdb-prints-an-error-message-that-xml-support-has-been-disabled-at-compile-time","title":"GDB prints an error message that <code>XML support has been disabled at compile time</code>","text":"<p>GDB uses Expat library to parse XML files. Support of XML files is optional for GDB, therefore it can be built without Expat available, however for ARC it usually required to have support of XML to read target description files. Mentioned error message might happen if GDB has been built without available development files for the Expat. On Linux systems those should be available as package in package manager.</p>"},{"location":"faq/#how-to-reset-arc-sdp-board-programmatically-without-pressing-reset-button","title":"How to reset ARC SDP board programmatically (without pressing <code>Reset</code> button)?","text":"<p>It is possible to reset ARC SDP board without touching the physical button on the board. This can be done using the special OpenOCD script:</p> <pre><code>$ openocd -f test/arc/reset_sdp.tcl\n</code></pre> <p>Note that OpenOCD will crash with a segmentation fault after executing this script - this is expected and happens only after board has been reset, but that means that other OpenOCD scripts cannot be used in chain with <code>reset_sdp.tcl</code>, first OpenOCD should be invoked to reset the board, second it should be invoked to run as an actual debugger.</p>"},{"location":"faq/#can-i-program-fpgas-in-arc-em-starter-kit-or-in-arc-sdp","title":"Can I program FPGA's in ARC EM Starter Kit or in ARC SDP?","text":"<p>OpenOCD has some support for programming of FPGA\u2019s over JTAG, however it is not officially supported for ARC development systems.</p>"},{"location":"faq/#when-debugging-arc-em-core-in-axs101-with-ashling-opella-xd-and-gdbserver-i-get-an-error-messages-and-gdb-shows-that-all-memory-and-registers-are-zeroes","title":"When debugging ARC EM core in AXS101 with Ashling Opella-XD and GDBserver I get an error messages and GDB shows that all memory and registers are zeroes","text":"<p>Decrease a JTAG frequency to no more than 5MHz using an Ashling GDBserver option <code>--jtag-frequency</code>. This particular problem can be noted if GDBserver prints:</p> <pre><code>Error: Core is running (unexpected), attempting to halt...\nError: Core is running (unexpected), attempting to halt...\nError: Unable to halt core\n</code></pre> <p>While GDB shows that whole memory is just zeroes and all register values are also zeroes.</p>"},{"location":"advanced/64-bit-operations/","title":"Impact of 64-bit Integral Operation on GCC Toolchain","text":""},{"location":"advanced/64-bit-operations/#preface","title":"Preface","text":"<p>Some of the new 64 bit integral operations made available for ARCv2HS can be used to map the C-type long long. These are:</p> Operations Hardware option Possible usage <code>LDD</code>/<code>STD</code> <code>LL64_OPTION</code> Load/store 64 bit data type Chained <code>MPYM</code>/<code>MPYMU</code> <code>MPY_OPTION_{5,6}</code> Implementation of 32x32-&gt;64 bit operations <code>MAC</code>/<code>MACU</code> <code>MPY_OPTION_7</code> Multiply and accumulate operations <code>MACD</code>/<code>MACDU</code> <code>MPY_OPTION_8+</code> Multiply and accumulate operations <code>MPYD</code>/<code>MPYDU</code> <code>MPY_OPTION_8+</code> Implementation of 32x32-&gt;64 bit operations <code>VADD2</code> <code>MPY_OPTION_9</code> Register to register move of a 64 bit data type"},{"location":"advanced/64-bit-operations/#64-bit-move-operations","title":"64-bit Move Operations","text":"<p>First step in efficiently supporting the long long data type is implementing an efficient way to move the 64 bit data type in and out register file as well as within register file. The <code>LL64_OPTION</code> provides us with the means for fast transfer of 64 bit data into a processor register pair. The <code>LDD</code>/<code>STD</code> can be used as well to implement a fast way to save/restore the registers in prologue/epilogue of a function.</p> <p>The <code>MPY_OPTION_9</code> also gives us means to move a register to another register or a 32-bit immediate into a 64 bit register. The 32-bit immediate is signed extended to match the 64 bit container. Hence, for a register to register move, we can use the following instruction:</p> <pre><code>VADD2        r0r1,r2r3,0\n</code></pre> <p>The above instruction takes 32 bits in the program memory as it uses the <code>VADD2 A,B,u6</code> encoding. Although <code>VADD2</code> supports predication, we cannot use it for register to register move due to ISA limitations (e.g., the source of the operands needs to be the input argument <code>vadd2 .cc b,b,u6</code>) If we want to move and sign extend a 32-bit immediate into a 64-bit register pair, we can use the following instruction:</p> <pre><code>VADD2        r0r1, 0xAFEF, 0\n</code></pre> <p>The above instruction takes 64 bits in the program memory as we use <code>VADD2 A,limm,u6</code> encoding.</p>"},{"location":"advanced/64-bit-operations/#multiplication-instructions","title":"Multiplication Instructions","text":"<p>The implementation of multiplication instructions depends on the multiplier option used. A special care should be taken for chained operation when <code>MPY_OPTION</code> is either 5 or 6. In these configurations, the multiplier is blocking sequential, hence, the chained option improves the multiplication result. This, however, may be relevant for EM series as the HS will employ a fully pipelined multiplier.</p> <p>In general, for 32x32bit -&gt; 64 bit type of multiplier, we use the <code>MPY-MPYM</code> instructions pair. However, when using <code>MPY_OPTION</code> larger than 7, we can make use of the <code>MPYD</code>/<code>MPYDU</code> instructions. These instructions are faster and are having a smaller impact on memory size than previous used solution. Please remark that the <code>MPYD</code>/<code>MPYDU</code> clobbers also the 64-bit accumulator register <code>(ACCH,ACCL)</code>.</p>"},{"location":"advanced/64-bit-operations/#multiply-and-accumulate-instructions","title":"Multiply and Accumulate Instructions","text":"<p>The ISAv2, provides a number of MAC operations. These are <code>MAC</code>/<code>MACU</code> for <code>MPY_OPTION</code> equals to 7, and additionally <code>MACD</code>/<code>MACDU</code> when using <code>MPY_OPTION</code> eight or more. The latter ones are interesting as they place the 64 bit result in a register pair. All the MAC operations are using the 64-bit accumulator register <code>(ACCH, ACCL)</code> to accumulate with, as well to place the result mac into.</p> <p>Using a MAC operation needs to set up the accumulator register, as well as collecting the result from the accumulator and place it into a general purpose register. Hence,</p> Used instructions Single MAC (instructions) Multiple MACs, unroll case Throughput <code>MAC</code>/<code>MACU</code> 4 (2 loads into <code>(ACCH, ACCL)</code>; 1 <code>MAC</code>; 1 move from <code>ACCH</code> to register) 4 + 1 for each unrolled <code>MAC</code> (2 to initialize <code>(ACCH, ACCL)</code>; 2 to move the accumulator) 3+ (output/anti-dependency on <code>ACC</code>), 1 (otherwise) <code>MACD</code>/<code>MACDU</code> 3 (2 loads to <code>(ACCH, ACCL)</code>; 1 <code>MAC</code>) 2 + 1 for each unrolled <code>MAC</code> 3+ (output/anti-dependency on <code>ACC</code>), 1 (otherwise) <code>ADD</code>/<code>MPYD</code> 3 (2 additions; 1 <code>MPYD</code>) 3 ops for each <code>MAC</code> 3 <code>ADD</code>/<code>MPY</code> 4 (2 additions; 2 multiplications) 4 ops for each <code>MAC</code> 4"},{"location":"advanced/64-bit-operations/#caveats","title":"Caveats","text":"<p>Having the implicit 64-bit accumulator as destination for <code>MPYD</code>/<code>MPYDU</code> operations complicate the generated code when we have an anti-dependency with a <code>MAC</code> operation on the accumulator register.</p> <p>The accumulator register is used as input as well as output for the <code>MAC</code> operation, hence, using them in a pipelined fashion may be difficult (if, for example, between mac operations exist an output/anti-dependency). In this case, it is faster to use an implementation with <code>ADD</code>/<code>MPYD</code> operations.</p>"},{"location":"advanced/64-bit-operations/#case-study","title":"Case Study","text":"<p>Consider the following C-program:</p> <pre><code>long long foo (long long a, int b, int c)\n{\na += (long long) c * (long long) b;\nreturn a;\n}\n</code></pre>  Implementation  Assembler (estimated)  <code>ADD</code>/<code>MPY</code> <pre><code>mpym   r5,r3,r2\nmpy    r4,r3,r2\nadd.f  r0,r0,r4\nadc    r1,r1,r5\n</code></pre> <code>ADD</code>/<code>MPYD</code> <pre><code>mpyd   r2,r3,r2\nadd.f  r0,r2,r0\nadc    r1,r3,r1\n</code></pre> <code>MAC</code> <pre><code>mov    ACCL,r0\nmov    ACCH,r1\nmac    r0,r2,r3\nmov    r1,ACCH\n</code></pre> <code>MACD</code> (option 8) <pre><code>mov    ACCL,r0\nmov    ACCH,r1\nmacd   r0,r2,r3\n</code></pre> <code>MACD</code> (option 9) <pre><code>vadd2  ACC,r0,0\nmacd   r0,r2,r3\n</code></pre>"},{"location":"advanced/64-bit-operations/#implementation-matrix-used-by-gcc","title":"Implementation Matrix Used by GCC","text":"<p>Due to the accumulator caveats, consider the following implementation matrix for <code>MAC</code> operations:</p> <code>MPY_OPTION</code> 2 3 4 5 6 7 8 9 <code>ADD</code>/<code>MPY</code> Y Y Y Y Y Y N N <code>ADD</code>/<code>MPYD</code> N N N N N N Y N <code>MAC</code> N N N N N N N N <code>MACD</code> N N N N N N N Y <p>Refer Target Specific Options for details.</p>"},{"location":"advanced/apex-header/","title":"Migrating APEX Header","text":""},{"location":"advanced/apex-header/#preface","title":"Preface","text":"<p>ARChitect2 tool generates a special header file when APEX instructions are specified/selected in ARChitect. Here is an example:</p> <pre><code>/* **** DO NOT EDIT - this file is generated by ARChitect2 ****\n *\n * Description: Header file declaring the compiler extensions for apex components\n */\n#ifndef _apexextensions_H_\n#define _apexextensions_H_\n#define APEX_EXT_CORE_REGS_EXT_CORE_REGS_PRESENT        1\n// User extension aux register auxreg0\n#define AR_AUXREG0 0xfffff800\n#pragma Aux_register(0xfffff800, name=&gt;\"auxreg0\")\n// User extension aux register auxreg1\n#define AR_AUXREG1 0xfffff801\n#pragma Aux_register(0xfffff801, name=&gt;\"auxreg1\")\n// User extension core register r32\n#define CR_R32 32\n#pragma Core_register(32, name=&gt;\"r32\")\n// User extension core register r33\n#define CR_R33 33\n#pragma Core_register(33, name=&gt;\"r33\")\n// User extension core register r34\n#define CR_R34 34\n#pragma Core_register(34, name=&gt;\"r34\")\n// User extension core register r35\n#define CR_R35 35\n#pragma Core_register(35, name=&gt;\"r35\")\n// User extension instruction insn1\nextern long insn1(long,long);\n#pragma intrinsic(insn1,opcode=&gt;7,sub_opcode=&gt;5, effects=&gt;\"reg=32:is_read:is_written; reg=33:is_read:is_written; reg=34:is_read:is_written; reg=35:is_read:is_written; auxreg=0xfffff800:is_read:is_written; auxreg=0xfffff801:is_read:is_written\")\n// User extension instruction insn2\nextern long insn2(long);\n#pragma intrinsic(insn2,opcode=&gt;7,sub_opcode=&gt;1, effects=&gt;\"reg=32:is_read:is_written; reg=33:is_read:is_written; reg=34:is_read:is_written; reg=35:is_read:is_written; auxreg=0xfffff800:is_read:is_written; auxreg=0xfffff801:is_read:is_written\")\n#endif\n</code></pre>"},{"location":"advanced/apex-header/#auxiliary-registers","title":"Auxiliary Registers","text":"<pre><code>// User extension aux register auxreg0\n#define AR_AUXREG0 0xfffff800\n#pragma Aux_register(0xfffff800, name=&gt;\"auxreg0\")\n</code></pre> <p>MetaWare compiler accepts the definition of various extension features via pragmas. However, this is not the case for GNU. In this case, we need to use inline assembly to make the toolchain aware of the added functionality. Thus, to handle auxiliary register definition at C-level, we may need to define this:</p> <pre><code>#define Aux_register(ADDR, NAME)                \\\n    asm (\".extAuxRegister \" NAME \", \" #ADDR \", r|w\")\n</code></pre> <p>Instantiate the register:</p> <pre><code>Aux_register (0xfffff800, \"auxreg0\");\n</code></pre>"},{"location":"advanced/apex-header/#extension-core-registers","title":"Extension Core Registers","text":"<pre><code>// User extension core register r32\n#define CR_R32 32\n#pragma Core_register(32, name=&gt;\"r32\")\n</code></pre> <p>Usually, GNU recognizes all the extension core registers as <code>r32-r57</code>. Thus, it is not necessary to define a core register which has the same name as in GNU.</p>"},{"location":"advanced/apex-header/#extension-instructions","title":"Extension Instructions","text":"<pre><code>// User extension instruction insn1\nextern long insn1(long,long);\n#pragma intrinsic(insn1,opcode=&gt;7,sub_opcode=&gt;5, effects=&gt;\"reg=32:is_read:is_written; reg=33:is_read:is_written; reg=34:is_read:is_written; reg=35:is_read:is_written; auxreg=0xfffff800:is_read:is_written; auxreg=0xfffff801:is_read:is_written\")\n</code></pre> <p>MetaWare format uses the function <code>insn1</code> declaration to select the instruction syntax, while <code>pragma</code> defines MOP, SOP and sides effects of the instruction. Thus, for our example, <code>insn1</code> must use <code>SYNTAX_3OP</code>:</p> <pre><code>#define intrinsic_3OP(NAME, MOP, SOP)           \\\n    asm (\".extInstruction \" NAME \",\" #MOP \",\"   \\\n    #SOP \",SUFFIX_NONE, SYNTAX_3OP\\n\\t\")\nintrinsic_3OP (\"insn1\", 7, 5);\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\ninsn1 (int32_t __a, int32_t __b)\n{\nint32_t __dst;\n__asm__ (\"insn1 %0, %1, %2\\n\\t\"\n: \"=r\" (__dst)\n: \"r\" (__a), \"rCal\" (__b)\n: \"r32\", \"r33\", \"r34\", \"r35\");\nreturn __dst;\n}\n</code></pre> <p>A list of clobber registers may be ignored as the compiler does not handle <code>r32-r56</code> registers. However, to be safe, it is good to mention them. As for auxiliary register, one can ignore or just add <code>memory</code> to the clobber list as AUX registers is memory.</p>"},{"location":"advanced/apex-header/#final-header-file","title":"Final Header File","text":"<pre><code>#ifndef _apexextensions_H_\n#define _apexextensions_H_\n#include &lt;stdint.h&gt;\n#define Aux_register(ADDR, NAME)                \\\n  asm (\".extAuxRegister \" NAME \", \" #ADDR \", r|w\")\n#define intrinsic_3OP(NAME, MOP, SOP)           \\\n  asm (\".extInstruction \" NAME \",\" #MOP \",\"             \\\n  #SOP \",SUFFIX_NONE, SYNTAX_3OP\\n\\t\")\n#define intrinsic_2OP(NAME, MOP, SOP)           \\\n  asm (\".extInstruction \" NAME \",\" #MOP \",\"             \\\n  #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\")\nAux_register (0xfffff800, \"auxreg0\");\nAux_register (0xfffff801, \"auxreg1\");\nintrinsic_3OP (\"insn1\", 7, 5);\nintrinsic_2OP (\"insn2\", 7, 1);\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\ninsn1 (int32_t __a, int32_t __b)\n{\nint32_t __dst;\n__asm__ (\"insn1 %0, %1, %2\\n\\t\"\n: \"=r\" (__dst)\n: \"r\" (__a), \"rCal\" (__b)\n: \"r32\", \"r33\", \"r34\", \"r35\", \"memory\");\nreturn __dst;\n}\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\ninsn2 (int32_t __a)\n{\nint32_t __dst;\n__asm__ (\"insn2 %0, %1\\n\\t\"\n: \"=r\" (__dst)\n: \"rCal\" (__a)\n: \"r32\", \"r33\", \"r34\", \"r35\", \"memory\");\nreturn __dst;\n}\n#endif\n</code></pre>"},{"location":"advanced/bit-file-fpga/","title":"Writing Bit-file into FPGA with Digilent HS Cable","text":"<p>Below is an example given of how to program a Xilinx ML509 FPGA developers board. NOTE: make sure the Digilent HS cable is connected to the right JTAG connector on the board (programming the FPGA and not the memory). So, it should be connected to PC4 JTAG and not to J51 BDM. Further more, Device 4: XC5VLX110T is the FPGA to program, device 4 in the JTAG scan chain.</p> <pre><code>&gt; djtgcfg enum\nFound 1 device(s)\n\nDevice: JtagHs2\n    Product Name:   Digilent JTAG-HS2\n    User Name:      JtagHs2\n    Serial Number:  210249810909\n\n&gt; djtgcfg -d JtagHs2 init\nInitializing scan chain...\nFound Device ID: a2ad6093\nFound Device ID: 0a001093\nFound Device ID: 59608093\nFound Device ID: f5059093\nFound Device ID: f5059093\n\nFound 5 device(s):\n    Device 0: XCF32P\n    Device 1: XCF32P\n    Device 2: XC95144XL\n    Device 3: XCCACE\n    Device 4: XC5VLX110T\n\n&gt; djtgcfg -d JtagHs2 prog -i 4 -f &lt;fpga bit file to progam&gt;.bit\nProgramming device. Do not touch your board. This may take a few minutes...\nProgramming succeeded.\n</code></pre>"},{"location":"advanced/custom-instructions/","title":"Custom instructions","text":""},{"location":"advanced/custom-instructions/#extension-instructions-encoding","title":"Extension Instructions Encoding","text":"<p>ARC architecture allows users to specify extension instructions. These extension instructions are not macros. The assembler creates encodings for using these instructions according to the specification by the user. Here is a list of supported instructions:</p> Number of operands Major opcode Sub-opcode 1 Sub-opcode 2 Sub-opcode 3 3 <code>0x07</code> <code>0x00-0x2E</code>, <code>0x30-0x3f</code> \u2014 \u2014 2 <code>0x07</code> <code>0x2F</code> <code>0x00-0x3E</code> \u2014 1 <code>0x07</code> <code>0x2F</code> <code>0x3F</code> <code>0x00-0x3F</code> 0 <code>0x07</code> <code>0x2F</code> <code>0x3F</code> <code>0x00-0x3F</code>"},{"location":"advanced/custom-instructions/#three-operand-instructions","title":"Three-operand Instructions","text":"<p>Three-operand instructions have <code>op&lt;.cc&gt;&lt;.f&gt; a,b,c</code> syntax format, and it is the most general form of an ARC instruction:</p> <pre><code>op&lt;.f&gt; a,b,c\nop&lt;.f&gt; a,b,u6\nop&lt;.f&gt; b,b,s12\nop&lt;.cc&gt;&lt;.f&gt; b,b,c\nop&lt;.cc&gt;&lt;.f&gt; b,b,u6\nop&lt;.f&gt; a,limm,c\nop&lt;.f&gt; a,limm,u6\nop&lt;.f&gt; 0,limm,s12\nop&lt;.cc&gt;&lt;.f&gt; 0,limm,c\nop&lt;.cc&gt;&lt;.f&gt; 0,limm,u6\nop&lt;.f&gt; a,b,limm\nop&lt;.cc&gt;&lt;.f&gt; b,b,limm\nop&lt;.f&gt; a,limm,limm\nop&lt;.cc&gt;&lt;.f&gt; 0,limm,limm\nop&lt;.f&gt; 0,b,c\nop&lt;.f&gt; 0,b,u6\nop&lt;.f&gt; 0,limm,c\nop&lt;.f&gt; 0,limm,u6\nop&lt;.f&gt; 0,b,limm\nop&lt;.f&gt; 0,limm,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#two-operand-instructions","title":"Two-operand Instructions","text":"<p>Two-operand instructions have the following syntax format:</p> <pre><code>op&lt;.f&gt; b,c\nop&lt;.f&gt; b,u6\nop&lt;.f&gt; b,limm\nop&lt;.f&gt; 0,c\nop&lt;.f&gt; 0,u6\nop&lt;.f&gt; 0,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#one-operand-and-zero-operand-instructions","title":"One-operand and Zero-operand Instructions","text":"<p>One-operand instructions are having the following syntax format:</p> <pre><code>op&lt;.f&gt; c\nop&lt;.f&gt; u6\nop&lt;.f&gt; limm\n</code></pre> <p>Zero-operand instructions are actually has <code>op&lt;.f&gt; u6</code> one-operand instruction syntax, with <code>u6</code> set to zero.</p> <p>To create a custom instruction, ones need to make use of the <code>.extInstruction</code> pseudo-op, which also allows the user to choose for a particular instruction syntax:</p>"},{"location":"advanced/custom-instructions/#defining-custom-instructions","title":"Defining Custom Instructions","text":"<p><code>.extInstruction</code> pseudo-op is used to create a custom instruction. On top of the formal syntax choices, we have also syntax class modifiers:</p> <ul> <li><code>OP1_MUST_BE_IMM</code> which applies for <code>SYNTAX_3OP</code> type of extension instructions, specifying that the first   operand of a three-operand instruction must be an immediate (i.e., the result is discarded). This is   usually used to set the flags using specific instructions and not retain results.</li> <li><code>OP1_IMM_IMPLIED</code> modifies syntax class <code>SYNTAX_2OP</code>, specifying that there is an implied   immediate destination operand which does not appear in the syntax. In fact this is actually   an 3-operand encoded instruction!</li> </ul>"},{"location":"advanced/custom-instructions/#example-no1-three-operand-instruction","title":"Example \u21161. Three-operand instruction","text":"<p>Definitions of the instruction:</p> <pre><code>.extInstruction insn1, 0x07, 0x2d, SUFFIX_NONE, SYNTAX_3OP|OP1_MUST_BE_IMM\n</code></pre> <p>Using the instruction:</p> <pre><code>insn1  0,b,c\ninsn1  0,b,u6\ninsn1  0,limm,c\ninsn1  0,b,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#example-no2-two-operand-instruction","title":"Example \u21162. Two-operand instruction","text":"<p>Note</p> <p>The encoding of <code>insn2</code> uses the <code>SYNTAX_3OP</code> format (i.e., Major <code>0x07</code> and SubOpcode1: <code>0x00-0x2E</code>, <code>0x30-0x3F</code>)</p> <p>Definitions of the instruction:</p> <pre><code>.extInstruction insn2, 0x07, 0x2d, SUFFIX_NONE, SYNTAX_2OP|OP1_IMM_IMPLIED\n</code></pre> <p>Using the instruction:</p> <pre><code>insn2  b,c\ninsn2  b,u6\ninsn2  limm,c\ninsn2  b,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#example-no3-all-variants","title":"Example \u21163. All Variants","text":"<p>Definitions of the instructions:</p> <pre><code>.extInstruction insn1, 7, 0x21, SUFFIX_NONE, SYNTAX_3OP\n.extInstruction insn2, 7, 0x21, SUFFIX_NONE, SYNTAX_2OP\n.extInstruction insn3, 7, 0x21, SUFFIX_NONE, SYNTAX_1OP\n.extInstruction insn4, 7, 0x21, SUFFIX_NONE, SYNTAX_NOP\n</code></pre> <p>Using the instruction:</p> <pre><code>start:\ninsn1   r0,r1,r2\ninsn2   r0,r1\ninsn3   r1\ninsn4\n</code></pre> <p>Disassembly of section <code>.text</code>:</p> <pre><code>0x0000 &lt;start&gt;:\n   0:   3921 0080               insn1   r0,r1,r2\n   4:   382f 0061               insn2   r0,r1\n   8:   392f 407f               insn3   r1\n   c:   396f 403f               insn4\n</code></pre>"},{"location":"advanced/custom-instructions/#support-in-gcc","title":"Support in GCC","text":""},{"location":"advanced/custom-instructions/#using-inline-functions","title":"Using Inline Functions","text":"<p>Define a macro for a two-operand custom instruction:</p> <pre><code>#define intrinsic_2OP(NAME, MOP, SOP)       \\\n    \".extInstruction \" NAME \",\" #MOP \",\"    \\\n    #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n</code></pre> <p>Instantiate the custom instruction:</p> <pre><code>__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n</code></pre> <p>Create an inline function:</p> <pre><code>__extension__ static __inline int32_t __attribute__ ((__always_inline__))\n__chk_pkt (int32_t __a)\n{\nint32_t __dst;\n__asm__ (\"chk_pkt %0, %1\\n\\t\"\n: \"=r\" (__dst)\n: \"rCal\" (__a));\nreturn __dst;\n}\n</code></pre> <p>Here is a full example:</p> <pre><code>#include &lt;stdint.h&gt;\n#define intrinsic_2OP(NAME, MOP, SOP)       \\\n    \".extInstruction \" NAME \",\" #MOP \",\"    \\\n    #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\n__chk_pkt (int32_t __a)\n{\nint32_t __dst;\n__asm__ (\"chk_pkt %0, %1\\n\\t\"\n: \"=r\" (__dst)\n: \"rCal\" (__a));\nreturn __dst;\n}\nint foo (void)\n{\nreturn __chk_pkt (10);\n}\n</code></pre> <p>Here is an assembler translation:</p> <pre><code>     .file   \"t03.c\"\n.cpu HS\n.extInstruction chk_pkt,0x07,0x01,SUFFIX_NONE, SYNTAX_2OP\n.section        .text\n.align 4\n.global foo\n.type   foo, @function\nfoo:\n# 13 \"t03.c\" 1\nchk_pkt r0, 10\n# 0 \"\" 2\nj_s [blink]\n.size   foo, .-foo\n.ident  \"GCC: (ARCompact/ARCv2 ISA elf32 toolchain arc-2016.09-rc1-2-gb04a7b5) 6.2.1 20160824\"\n</code></pre>"},{"location":"advanced/custom-instructions/#using-defines-only","title":"Using Defines Only","text":"<p>Define a macro for a two-operand custom instruction in a header file:</p> <pre><code>#define intrinsic_2OP(NAME, MOP, SOP)       \\\n    \".extInstruction \" NAME \",\" #MOP \",\"    \\\n    #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n</code></pre> <p>Create an inline function:</p> <pre><code>__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n</code></pre> <p>Define a macro for the custom instruction to be used in C sources:</p> <pre><code>#define chk_pkt(src) ({long __dst;                        \\\n__asm__ (\"chk_pkt %0, %1\\n\\t\"                      \\\n: \"=r\" (__dst)                              \\\n: \"rCal\" (src));                            \\\n__dst;})\n</code></pre> <p>Use the custom instruction in C-sources:</p> <pre><code>result = chk_pkt(deltachk);\n</code></pre> <p>Here is a full content of the header file:</p> <pre><code>#ifndef _EXT_INSTRUCTIONS_H_\n#define _EXT_INSTRUCTIONS_H_\n#define intrinsic_2OP(NAME, MOP, SOP)                                        \\\n    \".extInstruction \" NAME \",\" #MOP \",\" #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n#define chk_pkt(src) ({long __dst;                   \\\n        __asm__ (\"chk_pkt %0, %1\\n\\t\"                \\\n          : \"=r\" (__dst)                             \\\n          : \"rCal\" (src));                           \\\n         __dst;})\n#endif /* _EXT_INSTRUCTIONS_H_ */\n</code></pre>"},{"location":"advanced/intrinsics/","title":"Intrinsics","text":"<p>GCC supports a number of built-in functions for ARC targets. Documentation for them may be found in the official manual.</p> <p>All ARC built-ins are stored in <code>arcle.h</code> header file:</p> <pre><code>#include &lt;arcle.h&gt;\n</code></pre> <p>Here is comparison table for MetaWare andd GCC compilers regarding support of intrinsics:</p> MetaWare GCC <code>_abss</code> <code>_abss</code> <code>_abssh</code> <code>_abssh</code> <code>_adcs</code> <code>_adcs</code> <code>_add</code> Not planned <code>_add1</code> Not planned <code>_add1_f</code> Not planned <code>_add2</code> Not planned <code>_add2_f</code> Not planned <code>_add3</code> Not planned <code>_add3_f</code> Not planned <code>_add_f</code> Not planned <code>_adds</code> <code>_adds</code> <code>_adds_f</code> Not planned <code>_aex</code> Unsupported <code>_and</code> Not planned <code>_and_f</code> Not planned <code>_asl</code> Not planned <code>_asl_f</code> Not planned <code>_aslacc</code> <code>_aslacc</code> <code>_asls</code> <code>_asls</code> <code>_asls_f</code> Not planned <code>_aslsacc</code> <code>_aslsacc</code> <code>_asr</code> Not planned <code>_asr_f</code> Not planned <code>_asrs</code> <code>_asrs</code> <code>_asrs_f</code> Not planned <code>_asrsr</code> <code>_asrsr</code> <code>_asrsr_f</code> Not planned <code>_bclr</code> Not planned <code>_bclr_f</code> Not planned <code>_bmsk</code> Not planned <code>_bmsk_f</code> Not planned <code>_bset</code> Not planned <code>_bset_f</code> Not planned <code>_btst_f</code> Not planned <code>_bxor</code> Not planned <code>_bxor_f</code> Not planned <code>_cbflyhf0r</code> <code>_cbflyhf0r</code> <code>_cbflyhf1r</code> <code>_cbflyhf1r</code> <code>_cmacchfr</code> <code>_cmacchfr</code> <code>_cmacchnfr</code> <code>_cmacchnfr</code> <code>_cmachfr</code> <code>_cmachfr</code> <code>_cmachnfr</code> <code>_cmachnfr</code> <code>_cmpychfr</code> <code>_cmpychfr</code> <code>_cmpychnfr</code> <code>_cmpychnfr</code> <code>_cmpyhfmr</code> <code>_cmpyhfmr</code> <code>_cmpyhfr</code> <code>_cmpyhfr</code> <code>_cmpyhnfr</code> <code>_cmpyhnfr</code> <code>_divf</code> <code>_divf</code> <code>_dmach</code> <code>_dmach</code> <code>_dmachbl</code> <code>_dmachbl</code> <code>_dmachbm</code> <code>_dmachbm</code> <code>_dmachf</code> <code>_dmachf</code> <code>_dmachfr</code> <code>_dmachfr</code> <code>_dmachu</code> <code>_dmachu</code> <code>_dmacwh</code> <code>_dmacwh</code> <code>_dmacwhf</code> <code>_dmacwhf</code> <code>_dmacwhu</code> <code>_dmacwhu</code> <code>_dmpyh</code> <code>_dmpyh</code> <code>_dmpyhbl</code> <code>_dmpyhbl</code> <code>_dmpyhbm</code> <code>_dmpyhbm</code> <code>_dmpyhf</code> <code>_dmpyhf</code> <code>_dmpyhfr</code> <code>_dmpyhfr</code> <code>_dmpyhu</code> <code>_dmpyhu</code> <code>_dmpyhwf</code> <code>_dmpyhwf</code> <code>_dmpywh</code> <code>_dmpywh</code> <code>_dmpywhf</code> <code>_dmpywhf</code> <code>_dmpywhu</code> <code>_dmpywhu</code> <code>_ex</code> Unsupported <code>_ex_di</code> Unsupported <code>_ffs</code> Unsupported <code>_flagacc</code> <code>_flagacc</code> <code>_fls</code> Unsupported <code>_getacc</code> <code>_getacc</code> <code>_kflag</code> <code>_kflag</code> <code>_lr</code> <code>_lr</code> <code>_lsr</code> Not planned <code>_lsr_f</code> Not planned <code>_mac</code> <code>_mac</code> <code>_macd</code> <code>_macd</code> <code>_macdf</code> <code>_macdf</code> <code>_macdu</code> <code>_macdu</code> <code>_macf</code> <code>_macf</code> <code>_macfr</code> <code>_macfr</code> <code>_macu</code> <code>_macu</code> <code>_macwhfl</code> <code>_macwhfl</code> <code>_macwhflr</code> <code>_macwhflr</code> <code>_macwhfm</code> <code>_macwhfm</code> <code>_macwhfmr</code> <code>_macwhfmr</code> <code>_macwhkl</code> <code>_macwhkl</code> <code>_macwhkul</code> <code>_macwhkul</code> <code>_macwhl</code> <code>_macwhl</code> <code>_macwhul</code> <code>_macwhul</code> <code>_max_f</code> Not planned <code>_min_f</code> Not planned <code>_modif</code> Not planned <code>_mov_f</code> Not planned <code>_mpy</code> Not planned <code>_mpyd</code> Not planned <code>_mpydf</code> <code>_mpydf</code> <code>_mpydu</code> Not planned <code>_mpyf</code> <code>_mpyf</code> <code>_mpyfr</code> <code>_mpyfr</code> <code>_mpym</code> Not planned <code>_mpymu</code> Not planned <code>_mpyu</code> Not planned <code>_mpywhfl</code> <code>_mpywhfl</code> <code>_mpywhflr</code> <code>_mpywhflr</code> <code>_mpywhfm</code> <code>_mpywhfm</code> <code>_mpywhfmr</code> <code>_mpywhfmr</code> <code>_mpywhkl</code> <code>_mpywhkl</code> <code>_mpywhkul</code> <code>_mpywhkul</code> <code>_mpywhl</code> <code>_mpywhl</code> <code>_mpywhul</code> <code>_mpywhul</code> <code>_msubdf</code> <code>_msubdf</code> <code>_msubf</code> <code>_msubf</code> <code>_msubfr</code> <code>_msubfr</code> <code>_msubwhfl</code> <code>_msubwhfl</code> <code>_msubwhflr</code> <code>_msubwhflr</code> <code>_msubwhfm</code> <code>_msubwhfm</code> <code>_msubwhfmr</code> <code>_msubwhfmr</code> <code>_negs</code> <code>_negs</code> <code>_negs_f</code> Not planned <code>_negsh</code> <code>_negsh</code> <code>_negsh_f</code> Not planned <code>_norm</code> Not planned <code>_norm_f</code> Not planned <code>_normacc</code> <code>_normacc</code> <code>_normh</code> Not planned <code>_normh_f</code> Not planned <code>_normw</code> Not planned <code>_normw_f</code> Not planned <code>_or</code> Not planned <code>_or_f</code> Not planned <code>_qmach</code> <code>_qmach</code> <code>_qmachf</code> <code>_qmachf</code> <code>_qmachu</code> <code>_qmachu</code> <code>_qmpyh</code> <code>_qmpyh</code> <code>_qmpyhf</code> <code>_qmpyhf</code> <code>_qmpyhu</code> <code>_qmpyhu</code> <code>_rndh</code> <code>_rndh</code> <code>_rndh_f</code> Not planned <code>_ror</code> Not planned <code>_ror_f</code> Not planned <code>_rrc</code> Not planned <code>_rrc_f</code> Not planned <code>_satf</code> <code>_satf</code> <code>_sath</code> <code>_sath</code> <code>_sath_f</code> Not planned <code>_sbcs</code> <code>_sbcs</code> <code>_setacc</code> <code>_setacc</code> <code>_sqrt</code> <code>_sqrt</code> <code>_sqrtf</code> <code>_sqrtf</code> <code>_sr</code> <code>_sr</code> <code>_sub</code> Not planned <code>_sub1</code> Not planned <code>_sub1_f</code> Not planned <code>_sub2</code> Not planned <code>_sub2_f</code> Not planned <code>_sub3</code> Not planned <code>_sub3_f</code> Not planned <code>_sub_f</code> Not planned <code>_subs</code> <code>_subs</code> <code>_subs_f</code> Not planned <code>_trap</code> <code>_trap</code> <code>_vabs2h</code> <code>_vabs2h</code> <code>_vabss2h</code> <code>_vabss2h</code> <code>_vadd2</code> <code>_vadd2</code> <code>_vadd2h</code> <code>_vadd2h</code> <code>_vadd4b</code> <code>_vadd4b</code> <code>_vadd4h</code> <code>_vadd4h</code> <code>_vadds2</code> <code>_vadds2</code> <code>_vadds2h</code> <code>_vadds2h</code> <code>_vadds4h</code> <code>_vadds4h</code> <code>_vaddsub</code> <code>_vaddsub</code> <code>_vaddsub2h</code> <code>_vaddsub2h</code> <code>_vaddsub4h</code> <code>_vaddsub4h</code> <code>_vaddsubs</code> <code>_vaddsubs</code> <code>_vaddsubs2h</code> <code>_vaddsubs2h</code> <code>_vaddsubs4h</code> <code>_vaddsubs4h</code> <code>_valgn2h</code> <code>_valgn2h</code> <code>_vasl2h</code> <code>_vasl2h</code> <code>_vasls2h</code> <code>_vasls2h</code> <code>_vasr2h</code> <code>_vasr2h</code> <code>_vasrs2h</code> <code>_vasrs2h</code> <code>_vasrsr2h</code> <code>_vasrsr2h</code> <code>_vext2bhl</code> <code>_vext2bhl</code> <code>_vext2bhlf</code> <code>_vext2bhlf</code> <code>_vext2bhm</code> <code>_vext2bhm</code> <code>_vext2bhmf</code> <code>_vext2bhmf</code> <code>_vlsr2h</code> <code>_vlsr2h</code> <code>_vmac2h</code> <code>_vmac2h</code> <code>_vmac2hf</code> <code>_vmac2hf</code> <code>_vmac2hfr</code> <code>_vmac2hfr</code> <code>_vmac2hnfr</code> <code>_vmac2hnfr</code> <code>_vmac2hu</code> <code>_vmac2hu</code> <code>_vmax2h</code> <code>_vmax2h</code> <code>_vmin2h</code> <code>_vmin2h</code> <code>_vmpy2h</code> <code>_vmpy2h</code> <code>_vmpy2hf</code> <code>_vmpy2hf</code> <code>_vmpy2hfr</code> <code>_vmpy2hfr</code> <code>_vmpy2hu</code> <code>_vmpy2hu</code> <code>_vmpy2hwf</code> <code>_vmpy2hwf</code> <code>_vmsub2hf</code> <code>_vmsub2hf</code> <code>_vmsub2hfr</code> <code>_vmsub2hfr</code> <code>_vmsub2hnfr</code> <code>_vmsub2hnfr</code> <code>_vneg2h</code> <code>_vneg2h</code> <code>_vnegs2h</code> <code>_vnegs2h</code> <code>_vnorm2h</code> <code>_vnorm2h</code> <code>_vpack2hbl</code> <code>_vpack2hbl</code> <code>_vpack2hblf</code> <code>_vpack2hblf</code> <code>_vpack2hbm</code> <code>_vpack2hbm</code> <code>_vpack2hbmf</code> <code>_vpack2hbmf</code> <code>_vpack2hl</code> <code>_vpack2hl</code> <code>_vpack2hm</code> <code>_vpack2hm</code> <code>_vperm</code> <code>_vperm</code> <code>_vrep2hl</code> <code>_vrep2hl</code> <code>_vrep2hm</code> <code>_vrep2hm</code> <code>_vsext2bhl</code> <code>_vsext2bhl</code> <code>_vsext2bhm</code> <code>_vsext2bhm</code> <code>_vsub2</code> <code>_vsub2</code> <code>_vsub2h</code> <code>_vsub2h</code> <code>_vsub4b</code> <code>_vsub4b</code> <code>_vsub4h</code> <code>_vsub4h</code> <code>_vsubadd</code> <code>_vsubadd</code> <code>_vsubadd2h</code> <code>_vsubadd2h</code> <code>_vsubadd4h</code> <code>_vsubadd4h</code> <code>_vsubadds</code> <code>_vsubadds</code> <code>_vsubadds2h</code> <code>_vsubadds2h</code> <code>_vsubadds4h</code> <code>_vsubadds4h</code> <code>_vsubs2</code> <code>_vsubs2</code> <code>_vsubs2h</code> <code>_vsubs2h</code> <code>_vsubs4h</code> <code>_vsubs4h</code> <code>_wevt</code> Unsupported"},{"location":"advanced/jli/","title":"JLI Instructions","text":""},{"location":"advanced/jli/#overview","title":"Overview","text":"<p>The ARCv2 ISA provides the JLI instruction, which is two-byte instructions that can be used to reduce code size for an application. To make use of it, we provide two new function attributes <code>jli_always</code> and <code>jli_fixed</code> which will force the compiler to call the indicated function using a <code>jli_s</code> instruction. The compiler also generates the entries in the JLI table for the case when we use <code>jli_always</code> attribute. In the case of <code>jli_fixed</code> the compiler assumes a fixed position of the function in JLI table. Thus, the user needs to provide an assembly file with the JLI table for the final link. This is useful when we want to have a table in ROM and a second table in the RAM memory.</p> <p>The jli instruction usage can be also forced without the need to annotate the source code via <code>-mjli-always</code> command.</p>"},{"location":"advanced/jli/#using-jli-attributes","title":"Using JLI Attributes","text":"<p>The usual way of using jli calls is to use the attribute <code>jli_always</code> with a function. For example:</p> <pre><code>int func (int i) __attribute__((jli_always));\nint func (int i) {\nreturn i*i;\n}\nint main ()\n{\nprintf (\"func returned = %d \\n\", func (100));\nreturn 0;\n}\n</code></pre> <p>Here is an assembler translation:</p> <pre><code>main:\npush_s blink\nst.a fp,[sp,-4] ;28\nmov_s fp,sp     ;4\nmov_s r0,100    ;3\njli_s @__jli.func\nmov_s r2,r0     ;4\nmov_s r1,r2     ;4\nmov_s r0,@.LC0  ;14\nbl @printf;1\nmov_s r2,0      ;3\nmov_s r0,r2     ;4\nld.ab fp,[sp,4] ;25\npop_s blink\nj_s [blink]\n</code></pre> <p>As we can see the call to func is done via the <code>jli_s</code> instruction, while the other calls are done using regular <code>bl</code> instruction. If we want all calls to non-local functions to be done using <code>jli_s</code> then we can use <code>-mjli-always</code> compiler option. However, we need to be careful in using this option as the JLI table can hold only 1024 entries. The compiler cannot efficiently check the number of entries as it only has a limited view over the whole application. In this case the GNU tool takes care of generating the JLI table, patching the <code>jli_s</code> instruction with the correct entry number corresponding to the called function, and the initialization of the <code>jli_base</code> auxiliary register.</p> <p>A special way to use the <code>jli_s</code> instruction is for ROM patching. Because with the <code>jli_s</code> instruction function calls are made indirectly through the JLI table, the JLI table entries can be changed to invoke alternative functions without affecting the executable code. Thus, in this case the location of each function called via jli instruction must be fixed and known at compile time. To achieve this, we have introduced a new <code>jli_fixed</code> function attribute which accept a numerical parameter to specify the function call entry in the JLI table. This attribute is GNU specific.</p> <p>Consider the following example:</p> <pre><code>int func (int i) __attribute__((jli_fixed(2)));\nint func (int i)\n{\nreturn i*i;\n}\nint main ()\n{\nprintf (\"func returned = %d \\n\", func (100));\nreturn 0;\n}\n</code></pre> <p>Here is an assembler translation:</p> <pre><code>main:\npush_s blink\nst.a fp,[sp,-4] ;28\nmov_s fp,sp     ;4\nmov_s r0,100    ;3\njli_s 2 ; @func\nmov_s r2,r0     ;4\nmov_s r1,r2     ;4\nmov_s r0,@.LC0  ;14\nbl @printf;1\nmov_s r2,0      ;3\nmov_s r0,r2     ;4\nld.ab fp,[sp,4] ;25\npop_s blink\nj_s [blink]\n</code></pre> <p>As we can see now, the operand of <code>jli_s</code> instruction is already resolved and points to entry 2 in the JLI table. In this case, the compiler does not generate the JLI table, as it needs to be provided by the user. A JLI table can be something like this:</p> <pre><code>.section .jlitab\n.align  4\nJLI_table:\n__jli.entry0:   b       entry0  ; 0\n__jli.entry1:   b       entry1  ; 1\n__jli.func:     b       func    ; 2\n</code></pre> <p>The initialization of the <code>jli_base</code> is again done by the <code>crt0</code>. However, in the case of RAM/ROM patching, one may want to overwrite the initial value with a new value based on the location of a patched JLI table. N.B. the RAM/ROM patching approach may require special startup and/or linker scripts which are not provided.</p>"},{"location":"advanced/jli/#compatibility-with-metaware","title":"Compatibility with MetaWare","text":"<p>In general the GNU JLI implementation is compatible with MWDT implementation, except for the code that invokes the MetaWare runtime initialization code that sets the <code>JLI_BASE</code> register to address the JLI table. GNU additionally introduces the <code>jli_fixed</code> attribute to closely mimic the MWDT <code>jli_call_fixed</code> pragma.</p>"},{"location":"advanced/optimizations/","title":"Optimization Options","text":"<p>There are cases when using solely the <code>-Ox</code> options will not bring the desired optimization (either size or speed) for a compiled function/application. In these cases we need to understand where is the program\u2019s bottleneck and if it can be solved either by passing various options to the compiler or by source code modifications. In this section, we look into compiler\u2019s command-line options and how they can help us in achieving better results.</p>"},{"location":"advanced/optimizations/#architecture-independent-optimizations","title":"Architecture-Independent Optimizations","text":"<p>The first step in optimizing your code is by experimenting with architecture-independent optimizations. Almost any GCC pass (i.e., optimization) can be turned on or off or steered using parameters. These optimizations are denoted by the notation <code>-fxxxx</code>, where <code>xxxx</code> is the GCC pass that is turned on. To turn off a gcc pass, we need to pass <code>-fno-xxxx</code> to the compiler. The same observation holds for other types of optimizations such as the architecture-specific ones. For more information about GCC options, please check the GCC manual. It is highly desirable to know and understand how these options work in order to properly use them.</p> <p>Here is a list of most reasonable options:</p> <code>-ftree-loop-ivcanon</code> <p>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</p> <code>-ftree-vectorize</code> <p>Perform loop vectorization on trees. This flag is enabled by default at <code>-O3</code>. This option is useful to use either if the ARC processor does not have the SIMD extensions as it performs extra code analysis and may improve the following optimizations.</p> <code>-ftree-loop-if-convert</code> <p>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</p> <code>-f[no-]tree-dominator-opts</code> <p>Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps). This flag is enabled by default at <code>-O</code> and higher.</p> <code>-f(no-)ivopts</code> <p>Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees. Disabling the <code>ivopts</code> optimization may improve the number of hardware loops recognized by the compiler.</p> <code>-fselective-scheduling</code> <p>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the first scheduler pass.</p> <code>-fgcse</code> <p>Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation. It may be useful to disable this step specially when we want to have more <code>SUB1/2/3</code>, <code>ADD1/2/3</code> type of operations generated.</p> <code>-frename-registers</code> <p>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a \"home register\". Enabled by default with <code>-funroll-loops</code> and <code>-fpeel-loops</code>.</p> <code>-fira-loop-pressure</code> <p>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&gt;= 32 registers), but it can slow the compiler down.</p> <code>-fsched-pressure</code> <p>Enable register pressure sensitive instruction scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with <code>-fschedule-insns</code>. Usage of this option can improve the generated code and decrease its size by preventing register pressure increase above the number of available hard registers and subsequent spills in register allocation.</p> <code>-f[no-]regmove</code> <p>Attempt to reassign register numbers in move instructions and as operands of other simple instructions in order to maximize the amount of register tying. This is especially helpful on machines with two-operand instructions. Disabling this optimization may result in faster code.</p>"},{"location":"advanced/optimizations/#optimizations-for-code-size","title":"Optimizations for Code Size","text":"<p>If code size is our target, beside the GCC's <code>-Os</code> option, it may make sense to use it in conjunction with following command-line options:</p> <ul> <li><code>-fsection-anchors</code></li> <li><code>-fno-branch-count-reg</code></li> <li><code>-fira-loop-pressure</code></li> <li><code>-fira-region=all</code></li> <li><code>-fno-sched-spec-insn-heuristic</code></li> <li><code>-fno-move-loop-invariants</code></li> <li><code>-fno-tree-dominator-opts</code></li> <li><code>-ftree-vectorize</code></li> <li><code>-fno-cse-follow-jumps</code></li> <li><code>-fno-jump-tables</code></li> </ul>"},{"location":"advanced/optimizations/#optimization-for-speed","title":"Optimization for Speed","text":"<p>If the cycle count is our target, the best is to start with <code>-O2</code> option then with <code>-O3</code> and for each compiler optimization level to combine one or more of the suggested GCC command-line options. Finally, gather and compare runtime performance and size for each command-line combination. Consider plotting these numbers on a 2D graph, where one axis will represent the cycle count, and the other will represent the size. Hence, we can choose the best combination size/speed for a given problem.</p> <p>If one wants to try a large number of option combinations, then an automatic scripting process is required. One of those tools that searches through more than 1.3 zillion gcc option combination is <code>Acovea</code>. <code>Acovea</code> is using genetic algorithms to search for the best option combination for a given program. However, one can make an script that uses only the suggested gcc options to search for the best combination by exhaustively generating (most) of the option combinations.</p>"},{"location":"advanced/optimizations/#using-optimize-attribute","title":"Using <code>optimize</code> attribute","text":"<p>In GNU C, you declare certain things about functions called in your program which help the compiler optimize function calls and check your code more carefully. In the case when we want a certain function/kernel not to change its speed/size characteristics, we can use the <code>optimize</code> function attribute. The <code>optimize</code> attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Arguments can either be numbers or strings. Numbers are assumed to be an optimization level. Strings that begin with O are assumed to be an optimization option, while other options are assumed to be used with a <code>-f</code> prefix.</p>"},{"location":"advanced/optimizations/#default-arc-optimizations","title":"Default ARC Optimizations","text":"Opitimization <code>-O0</code> <code>-O1</code> <code>-Os</code> <code>-O2</code> <code>-O3</code> <code>-fomit-frame-pointer</code> On On On On <code>-fschedule-insns</code> On On On On <code>-fschedule-insns2</code> On On On On <code>-mearly-cbranchsi</code> On On On On On <code>-mbbit-peephole</code> On On On On On <code>-mcase-vector-pcrel</code> On <code>-mcompact-casesi</code> On"},{"location":"advanced/optimizations/#default-arc-parameters","title":"Default ARC Parameters","text":"Parameter Value <code>simultaneous-prefetches</code> 4 <code>prefetch-latency</code> 4 <code>l1-cache-line-size</code> 64"},{"location":"advanced/sanitizers/","title":"Sanitizers","text":""},{"location":"advanced/sanitizers/#overview","title":"Overview","text":"<p>Sanitizers functionality is available for ARC. Support for the sanitizers is limited for Linux, when running with glibc (GNU C Library).</p> <p>ARC supports the following sanitizers:</p> <ul> <li>Address</li> <li>Memory</li> <li>Undefined behavior</li> <li>Leak sanitizers</li> </ul>"},{"location":"advanced/sanitizers/#addresssanitizer","title":"AddressSanitizer","text":"<p>AddressSanitizer is a fast memory error detector. It consists of a compiler instrumentation module and a run-time library. Typical slowdown introduced by AddressSanitizer is 2x. The tool can detect the following types of bugs:</p> <ul> <li>Out-of-bounds accesses to heap, stack and globals</li> <li>Use-after-free</li> <li>Use-after-return (runtime flag <code>ASAN_OPTIONS=detect_stack_use_after_return=1</code>)</li> <li>Use-after-scope (clang flag <code>-fsanitize-address-use-after-scope</code>)</li> <li>Double-free, invalid free</li> <li>Memory leaks (experimental)</li> </ul>"},{"location":"advanced/sanitizers/#memorysanitizer","title":"MemorySanitizer","text":"<p>MemorySanitizer is a detector of uninitialized reads. It consists of a compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is 3x.</p>"},{"location":"advanced/sanitizers/#undefinedbehaviorsanitizer","title":"UndefinedBehaviorSanitizer","text":"<p>UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector. UBSan modifies the program at compile-time to catch various kinds of undefined behavior during program execution, for example:</p> <ul> <li>Using misaligned or null pointer.</li> <li>Signed integer overflow.</li> <li>Conversion to, from, or between floating-point types which would overflow the destination.</li> <li>See the full list of available checks below.</li> </ul> <p>UBSan has an optional run-time library which provides better error reporting. The checks have small runtime cost and no impact on address space layout or ABI.</p>"},{"location":"advanced/sanitizers/#leaksanitizer","title":"LeakSanitizer","text":"<p>LeakSanitizer is a run-time memory leak detector. It can be combined with AddressSanitizer to get both memory error and leak detection, or used in a stand-alone mode. LSan adds almost no performance overhead until the very end of the process, at which point there is an extra leak detection phase.</p> <p>We included in this document a few example as reference to the use of the sanitizers. For a clearer view of how to use the sanitizers, or further examples, please refer to Clang documentation</p>"},{"location":"advanced/sanitizers/#examples-for-x86","title":"Examples for x86","text":""},{"location":"advanced/sanitizers/#heap-use-after-free","title":"Heap-use-after-free","text":"<pre><code>// To compile: clang++ -O -g -fsanitize=address heap-use-after-free.cc\nint main(int argc, char **argv) {\nint *array = new int[100];\ndelete [] array;\nreturn array[argc];  // BOOM\n}\n</code></pre> <pre><code>$ ./a.out\n==5587==ERROR: AddressSanitizer: heap-use-after-free on address 0x61400000fe44 at pc 0x47b55f bp 0x7ffc36b28200\n sp 0x7ffc36b281f8\nREAD of size 4 at 0x61400000fe44 thread T0\n    #0 0x47b55e in main /home/test/example_UseAfterFree.cc:7\n    #1 0x7f15cfe71b14 in __libc_start_main (/lib64/libc.so.6+0x21b14)\n    #2 0x47b44c in _start (/root/a.out+0x47b44c)\n\n0x61400000fe44 is located 4 bytes inside of 400-byte region [0x61400000fe40,0x61400000ffd0)\nfreed by thread T0 here:\n    #0 0x465da9 in operator delete[](void*) (/root/a.out+0x465da9)\n    #1 0x47b529 in main /home/test/example_UseAfterFree.cc:6\n\npreviously allocated by thread T0 here:\n    #0 0x465aa9 in operator new[](unsigned long) (/root/a.out+0x465aa9)\n    #1 0x47b51e in main /home/test/example_UseAfterFree.cc:5\n\nSUMMARY: AddressSanitizer: heap-use-after-free /home/test/example_UseAfterFree.cc:7 main\nShadow bytes around the buggy address:\n  0x0c287fff9f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9f80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9f90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9fa0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9fb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=&gt;0x0c287fff9fc0: fa fa fa fa fa fa fa fa[fd]fd fd fd fd fd fd fd\n  0x0c287fff9fd0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c287fff9fe0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c287fff9ff0: fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa fa\n  0x0c287fffa000: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fffa010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:     fa\n  Heap right redzone:    fb\n  Freed heap region:     fd\n  Stack left redzone:    f1\n  Stack mid redzone:     f2\n  Stack right redzone:   f3\n  Stack partial redzone: f4\n  Stack after return:    f5\n  Stack use after scope: f8\n  Global redzone:        f9\n  Global init order:     f6\n  Poisoned by user:      f7\n  ASan internal:         fe\n==5587==ABORTING\n</code></pre>"},{"location":"advanced/sanitizers/#heap-buffer-overflow","title":"Heap-buffer-overflow","text":"<pre><code>// RUN: clang++ -O -g -fsanitize=address %t &amp;&amp; ./a.out\nint main(int argc, char **argv) {\nint *array = new int[100];\narray[0] = 0;\nint res = array[argc + 100];  // BOOM\ndelete [] array;\nreturn res;\n}\n</code></pre> <pre><code>==25372==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x61400000ffd4 at pc 0x0000004ddb59 bp 0x7fffea6005a0 sp 0x7fffea600598\nREAD of size 4 at 0x61400000ffd4 thread T0\n    #0 0x46bfee in main /tmp/main.cpp:4:13\n\n0x61400000ffd4 is located 4 bytes to the right of 400-byte region\n[0x61400000fe40,0x61400000ffd0)\nallocated by thread T0 here:\n    #0 0x4536e1 in operator delete[](void*)\n    #1 0x46bfb9 in main /tmp/main.cpp:2:16\n</code></pre>"},{"location":"advanced/sanitizers/#stack-buffer-overflow","title":"Stack-buffer-overflow","text":"<pre><code>// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out\nint main(int argc, char **argv) {\nint stack_array[100];\nstack_array[1] = 0;\nreturn stack_array[argc + 100];  // BOOM\n}\n</code></pre> <pre><code>==7405==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff64740634 at pc 0x46c103 bp 0x7fff64740470 sp 0x7fff64740468\nREAD of size 4 at 0x7fff64740634 thread T0\n    #0 0x46c102 in main /tmp/example_StackOutOfBounds.cc:5\n\nAddress 0x7fff64740634 is located in stack of thread T0 at offset 436 in frame\n    #0 0x46bfaf in main /tmp/example_StackOutOfBounds.cc:2\n\n  This frame has 1 object(s):\n        [32, 432) 'stack_array' &lt;== Memory access at offset 436 overflows this variable\n</code></pre>"},{"location":"advanced/sanitizers/#global-buffer-overflow","title":"Global-buffer-overflow","text":"<pre><code>// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out\nint global_array[100] = {-1};\nint main(int argc, char **argv) {\nreturn global_array[argc + 100];  // BOOM\n}\n</code></pre> <pre><code>==7455==ERROR: AddressSanitizer: global-buffer-overflow on address 0x000000689b54 at pc 0x46bfd8 bp 0x7fff515e5ba0 sp 0x7fff515e5b98\nREAD of size 4 at 0x000000689b54 thread T0\n    #0 0x46bfd7 in main /tmp/example_GlobalOutOfBounds.cc:4\n\n0x000000689b54 is located 4 bytes to the right of\n  global variable 'global_array' from 'example_GlobalOutOfBounds.cc' (0x6899c0) of size 400\n</code></pre>"},{"location":"advanced/secure-shield/","title":"SecureShield Programming","text":""},{"location":"advanced/secure-shield/#secureshield-api","title":"SecureShield API","text":"<p>A secure-callable API is a set of functions executing in secure mode that can be called from code executing in normal mode. The processor contains a special function call instruction, SJLI, that the compiler uses to implement a secure-mode API. This instruction transfers execution from normal mode to secure mode. Any other call or jump into secure mode from normal mode results in a processor exception.</p> <p>The GNU tools support a secure-callable API with a two-executable approach:</p> <ul> <li>One linked executable contains the secure-mode code;</li> <li>The second linked executable contains the normal-mode code.</li> </ul> <p>The normal-mode code is compiled normally - no special code is generated for calls to the secure-mode API. However, such calls are resolved by the linker in the normal executable with special function entry points that transfer control to the normal executable using the SJLI instruction. In the secure-mode executable, functions that are designate as belonging to the secure API need an index into the SJLI table. Also the runtime initialization for the secure-mode needs to be carried on by the user.</p>"},{"location":"advanced/secure-shield/#identifying-the-secure-callable-apis","title":"Identifying the Secure-Callable APIs","text":"<p>To indicate to the compiler that a secure-mode function is callable from normal mode, you can use <code>__attribute__((secure_call (IndexNumber)))</code> with secure-callable function. Where <code>IndexNumber</code> is the entry of that particular function into the SJLI table.</p>"},{"location":"advanced/secure-shield/#programming-cautions","title":"Programming Cautions","text":"<p>Using function pointer of a secure call function is not supported. However, one can make a stub which can be called indirectly, the stub itself calls the secure call normally.</p>"},{"location":"advanced/secure-shield/#example","title":"Example","text":"<p>Let us consider the following example:</p> <pre><code>#include &lt;stdio.h&gt;\nextern int foo (int) __attribute__((secure_call(2)));\nint bar (void)\n{\nprintf (\"%d\\n\", foo (100));\nreturn 0;\n}\nint bar2 (void)\n{\nreturn foo(100);\n}\n</code></pre> <p>Where function <code>foo()</code> is an external secure function located at index 2 in the SJLI table.</p> <p>The result is:</p> <pre><code>.cpu EM\n.section .rodata.str1.4,\"aMS\",@progbits,1\n.align 4\n.LC0:\n.string \"%d\\n\"\n.section    .text\n.align 4\n.global bar\n.type   bar, @function\nbar:\npush_s blink\nmov_s r0,100    ;3\nsjli  2 ; @foo\nmov_s r1,r0 ;4\nmov_s r0,@.LC0  ;14\nbl @printf;1\npop_s blink\nj_s.d [blink]\nmov_s r0,0  ;3\n.size   bar, .-bar\n.align 4\n.global bar2\n.type   bar2, @function\nbar2:\npush_s blink\nmov_s r0,100    ;3\nsjli  2 ; @foo\npop_s blink\nj_s [blink]\n.size  bar2, .-bar2\n</code></pre> <p>Where, we can easily spot the call to <code>foo()</code> function via <code>SJLI</code> instruction.</p>"},{"location":"advanced/small-data/","title":"Small Data Sections","text":"<p>Warning</p> <p>These articles is applicable to ARC GCC starting only with 2017.09 release.</p>"},{"location":"advanced/small-data/#small-data-available-access-range","title":"Small Data Available Access Range","text":"Data type Range Number of elements Size <code>char</code> [-256, 255] 512 512 bytes <code>short</code> [-256, 510] 383 766 bytes <code>int</code> [-256, 1020] 319 1276 bytes <p>The lower limit depends on the possibility to access byte-aligned datum, hence, it is hard connected to the range of <code>s9</code> short immediate (i.e., -256). Any other access can be done using address-scaling feature of the load/store instructions.</p> <p>The number of elements which we can fit in <code>sdata</code> section highly depends on the data alignment properties. For example if we use only 4 byte datum, 1 byte aligned, we can fit up to 128 elements in the section.</p>"},{"location":"advanced/small-data/#address-scaling-mode","title":"Address Scaling Mode","text":"<p>To increase the access range for small data area, the compiler uses scaled addresses whenever it is possible. Thus, we can extend theoretically this range to [-1024, 1020] for 32-bit data (e.g., <code>int</code>) if type aligned (i.e., 4-bytes). However, as we cannot be 100% sure that we address only 32-bit/4-byte aligned data, we need to consider the worst case which is byte-aligned data. Thus, the effective range is [-256, 255], with possibilities to access 16-bit aligned data (e.g., <code>short</code>) up to 510, and 32-bit aligned data (e.g., <code>int</code> or <code>long long</code>) up to 1020. While the lower limit remains -256. This is because we set the linker script defined variable <code>__SDATA_BEGIN__</code> with an offset of <code>0x100</code>. However, this rule can be overwritten by using a custom linker script.</p>"},{"location":"advanced/small-data/#storing-global-data-in-small-data-section","title":"Storing Global Data in Small Data Section","text":"<p>Global data smaller than a given number in bytes can be placed into the <code>sdata</code> section. The number of bytes can be controlled via <code>-G&lt;number&gt;</code> option. For ARC, by default this number is set to 8 whenever we have double load/store operations available (i.e., ARC HS architecture), otherwise to 4.</p> <p>For example, a 8 bytes setting will allow us to place into <code>sdata</code> the following variables:</p> <pre><code>char gA[8];\nshort gB[4];\nint gC[2];\nlong long gD;\n</code></pre> <p>Notable exceptions:</p> <ul> <li>Volatile global data will not be placed into <code>sdata</code> section when   <code>-mno-volatile-cache</code> option is used.</li> <li>Strings and functions never end in small data area.</li> <li>Weak variables as well not.</li> <li>No constant will end in small data area as those one, we would like to place into ROM.</li> </ul>"},{"location":"advanced/small-data/#using-named-sections","title":"Using Named Sections","text":"<p>Another way to control which data goes into small data area is to use named sections like this:</p> <pre><code>int a __attribute__((section (\".sdata\"))) = 1;\nint b __attribute__((section (\".sbss\")));\n</code></pre> <p>Variables <code>a</code> and <code>b</code> will go into <code>sdata</code>/<code>sbss</code> sections without checking the data type size against the <code>-G&lt;number&gt;</code> value. Thus, we can always control which data is accessed via <code>gp</code> register by setting <code>-G0</code> and using named sections.</p>"},{"location":"baremetal/general/heap-and-stack/","title":"Heap and Stack Size","text":"<p>To change size of heap in baremetal applications the following option should be specified to the linker: <code>--defsym=__DEFAULT_HEAP_SIZE=${SIZE}</code>, where <code>${SIZE}</code> is desired heap size, in bytes. It also possible to use size suffixes, like <code>k</code> and <code>m</code> to specify size in kilobytes and megabytes respectively. For stack size respective option is <code>--defsym=__DEFAULT_STACK_SIZE=${STACK_SIZE}</code>. Note that those are linker commands - they are valid only when passed to <code>ld</code> application, if <code>gcc</code> driver is used for linking, then those options should be prefixed with <code>-Wl</code>. For example:</p> <pre><code>$ arc-elf32-gcc -Wl,--defsym=__DEFAULT_HEAP_SIZE=256m \\\n-Wl,--defsym=__DEFAULT_STACK_SIZE=1024m --specs=nosys.specs \\\nhello.o -o hello.bin\n</code></pre> <p>Those options are valid only when default linker script is used. If custom linker script is used, then effective way to change stack/heap size depends on properties of that linker script - it might be the same, or it might be different.</p>"},{"location":"baremetal/general/specs/","title":"Specs Files","text":"<p>Warning</p> <p>This article is under construction!</p>"},{"location":"baremetal/general/tcf/","title":"Using TCF","text":"<p>Warning</p> <p>GNU toolchain has a partial support of TCF, however it is not complete and in particular scenarios TCFs cannot be used as-is. ARCv3 toolchains (<code>arc32-</code> and <code>arc64-</code> prefixes) do not support TCF at all.</p>"},{"location":"baremetal/general/tcf/#overview","title":"Overview","text":"<p>If you are using Eclipse IDE for ARC, please refer to a Building User Guide. Eclipse IDE for ARC supports only GCC compiler and GNU linker script sections of TCF, it doesn\u2019t support preprocessor defines sections as of version 2016.03.</p> <p>If you are using GNU toolchain without IDE on Linux hosts you can use a special script <code>arc-elf32-tcf-gcc</code> (for big-endian toolchain this file has <code>arceb-</code> prefix) that is located in the same bin directory as rest of the toolchain executable files. This executable accepts all of the same options as GCC driver and also an option <code>--tcf &lt;path/to/tcf&gt;</code>. <code>arc-elf32-tcf-gcc</code> will extract compiler options, linker script and preprocessor defines from TCF and will pass them to GCC along with other options.</p> <ul> <li>GCC options from <code>gcc_compiler</code> section will be passed as-is, but can be   overridden by <code>-m&lt;value&gt;</code> options passed directly to <code>arc-elf32-tcf-gcc</code>.</li> <li>GNU linker script will be extracted from <code>gnu_linker_command_file</code> will be   used as a <code>memory.x</code> file for <code>-Wl,marcv2elfx</code> linker emulation.   Option <code>-Wl,-marcv2elfx</code> is added by this wrapper - there is no need to   pass it explicitly.</li> <li>Preprocessor defines from section C_defines will be passed with <code>-include</code>   option of GCC.</li> </ul> <p><code>arc-elf32-tcf-gcc</code> is a Perl script that requires <code>XML:LibXML</code> package. It is likely to work on most Linux hosts, however it will not work on Windows hosts, unless Perl with required library has been installed and added to the PATH environment variable. TCF is a text file in XML format, so in case of need it is trivial to extract compiler flags and linker script from TCF and use them directly with GCC and ld without IDE or wrapper script.</p> <p>Value of <code>-mcpu=</code> option is selected by TCF generator to have best match with the target processor. This option ARC Toolchain Variants not only sets various hardware options but also selects a particular build of standard library. Values of hardware extensions can be overridden with individual <code>-m&lt;value&gt;</code> options, but that will not change standard library to a matching build - it still will use standard library build selected by <code>-mcpu=</code> value.</p>"},{"location":"baremetal/general/tcf/#compiler-options","title":"Compiler Options","text":"<p>GCC options are stored in the gcc_compiler section of TCF. These options are passed to GCC as-is. These are machine-specific options applicable only to ARC, and which define configuration of target architecture - which of the optional hardware extensions (like bitscan instructions, barrel shifter instructions, etc) are present. Application that uses hardware extensions will not work on ARC processor without those extensions - there will be an Illegal instruction exception (although application may emulate instruction via handling of this exception, but that is out of scope of this document). Application that doesn\u2019t use hardware extensions present in the target ARC processor might be ineffective, if those extensions allow more optimal implementation of same algorithm. Usually hardware extensions allow improvement of both code size and performance at the expense of increased gate count, with all respective consequences.</p> <p>When TCF is selected in the IDE respective compiler options are disabled in GUI and cannot be changed by user. However if TCF is deselected those options remain at selected values, so it is possible to import options from TCF and then modify it for particular need.</p> <p>When using <code>arc-elf32-tcf-gcc</code> compiler options passed to this wrapper script has a higher precedence then options in TCF, so it is possible to use TCF as a baseline and then modify if needed.</p>"},{"location":"baremetal/general/tcf/#memory-map","title":"Memory Map","text":"<p>Info</p> <p>Please refer Memory Maps and Linker Scripts page for more details.</p> <p>TCF does not contain a linker script for GNU linker in the strict meaning of this term. Instead TCF contains a special memory map, which can be used together with a linker emulation called <code>arcv2elfx</code>. This linker emulation reads a special file called <code>memory.x</code> to get several defines which denote location of particular memory areas, and then emulation allocates ELF sections to those areas. So, for example, <code>memory.x</code> may specify address and size of ICCM and DCCM memories and linker would put code sections into ICCM and data sections to DCCM. TCF contains this <code>memory.x</code> file as content of <code>gnu_linker_command_file</code> section. IDE and <code>arc-elf32-tcf-gcc</code> simply create this file and specify to linker to use <code>arcv2elfx</code> emulation. This is done by passing option <code>-marcv2elfx</code> to linker, but note that when invoking gcc driver it is required to specify this option as <code>-Wl,-marcv2elfx</code>, so driver would know that this is an option to pass to linker.</p> <p>It is very important that memory map in TCF matches the one in the hardware, otherwise application will not work. By default linker places all application code and data as a continuous sections starting from address <code>0x0</code>. Designs with CCMs usually has ICCM mapped at address <code>0x0</code>, and DCCM at addresses</p> <p>= <code>0x8000_0000</code> (or simply an upper half of address space, which can be less then 32 bits wide). If application has both code and data put into ICCM, it may technically work (load/store unit in ARC has a port to ICCM), however this underutilizes DCCM and creates a risk of memory overflow where code and data will not fit into the ICCM, so overflown content will be lost, likely causing an error message in simulator or in debugger. For this reason it is recommended to use <code>memory.x</code> file from TCF when linking applications that use CCM memory. Typically TCF-generator would automatically assign instruction memory area to ICCM and data memory area to DCCM, because parameters of those memories can be read from BCRs, although it does not support such features as ICCM1 or NV ICCM.</p> <p>When memory is connected via external memory bus TCF-generator cannot know where memory will be actually located, so it will put all sections continuously, starting from address <code>0x0</code>. This is basically same as what happens when no memory map has been passed to linker. Therefore memory map in such TCF is effectively useless, instead it is needed to manually enter a proper memory map into <code>gnu_linker_command_file</code> section. However when using an nSIM simulator such TCF will work nice, as it will make nSIM simulate whole address space, so there is no risk that application will be loaded into non-existing address.</p> <p>When using IDE there is an option to ignore memory map specified in TCF and use default memory mapping or custom linker script. This is the default setting - to ignore linker script embedded into TCF. However if target design uses closely-coupled memories then it is highly advised to use memory map (embedded into TCF or manually written).</p>"},{"location":"baremetal/general/tcf/#c-preprocessor-defines","title":"C Preprocessor Defines","text":"<p>TCF section <code>C_defines</code> contains preprocessor defines that specify presence of various hardware optional extensions and values of Build Configuration Registers. <code>arc-elf32-tcf-gcc</code> wrapper extracts content of this section into temporary file and includes into compiled files via <code>-include</code> option of GCC.</p>"},{"location":"baremetal/general/tcf/#command-line-options","title":"Command Line Options","text":""},{"location":"baremetal/general/tcf/#-compiler","title":"<code>--compiler</code>","text":"<p>Overwrites the default compiler name. The compiler tool chain needs to be in the <code>PATH</code>. Default value depends on the name of this file - it will call compiler that has the same name, only without <code>-tcf</code> part. Therefore:</p> <ul> <li><code>arc-elf32-tcf-gcc</code> -&gt; <code>arc-elf32-gcc</code></li> <li><code>arceb-elf32-tcf-gcc</code> -&gt; <code>arceb-elf32-gcc</code></li> <li><code>arc-linux-tcf-gcc</code> -&gt; <code>arc-linux-gcc</code></li> <li><code>arceb-linux-tcf-gcc</code> -&gt; <code>arceb-linux-gcc</code></li> <li><code>arc-a-b-tcf-gcc</code> -&gt; <code>arc-a-b-gcc</code></li> <li><code>arc-tcf-elf32-tcf-gcc</code> -&gt; <code>arc-tcf-elf32-gcc</code></li> </ul>"},{"location":"baremetal/general/tcf/#-tcf","title":"<code>--tcf</code>","text":"<p>The name and the location of the TCF file.</p>"},{"location":"baremetal/general/tcf/#-verbose","title":"<code>--verbose</code>","text":"<p>Verbose output. Prints the compiler invocation command.</p>"},{"location":"baremetal/hardware/debugging/","title":"Building Applications and Debugging on Development Platforms","text":""},{"location":"baremetal/hardware/debugging/#preface","title":"Preface","text":"<ul> <li>Refer to Development Platforms Table section   for options for all available configurations of the board.</li> <li>Follow Memory Maps and Linker Scripts guide for details   about <code>memory.x</code> files and where they may be obtained.</li> <li>Follow a corresponding manual to obtain   and configure OpenOCD.</li> </ul>"},{"location":"baremetal/hardware/debugging/#connecting-using-uart","title":"Connecting Using UART","text":"<p>Connecting a board to the host computer allows you using a serial port terminal for interacting with the board. You can use any software to connect to the serial port terminal:</p> <ul> <li>On Windows you can use HyperTerminal or Putty.</li> <li>On Linux you can use <code>minicom</code>, <code>gtkterm</code>, <code>cutecom</code>, etc.</li> </ul> <p>You can find detailed instructions for particular boards in corresponding sections.</p>"},{"location":"baremetal/hardware/debugging/#em-starter-kit","title":"EM Starter Kit","text":"<p>Info</p> <p>Please refer to board's documentation for detailed information about how to setup the board for initial operation.</p>"},{"location":"baremetal/hardware/debugging/#building-an-application","title":"Building an Application","text":"<p>Suppose, that EMSK 2.2 is used and EM7D core is selected. Consider a simple application <code>main.c</code>:</p> <pre><code>int main()\n{\nint a = 1;\nint b = 2;\nint c = a + b;\nreturn c;\n}\n</code></pre> <p>Build an application with support of UART:</p> <pre><code>$ cp &lt;path-to-toolchain&gt;/arc-*/lib/emsk2.2_em9d.x memory.x\n$ arc-elf32-gcc -mcpu=em4_dmips -specs=emsk.specs main.c -o main.elf\n</code></pre> <p>Build without support of UART:</p> <pre><code>$ cp &lt;path-to-toolchain&gt;/arc-*/lib/emsk2.2_em9d.x memory.x\n$ arc-elf32-gcc -mcpu=em4_dmips -specs=nosys.specs -Wl,-marcv2elfx main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/debugging/#running-an-application","title":"Running an Application","text":"<p>Follow Running OpenOCD Server section and start OpenOCD with 49101 port and <code>snps_em_sk_v2.2.cfg</code> configuration file. Here is a possible output:</p> <pre><code>Open On-Chip Debugger 0.9.0-dev (2023-05-21-06:23)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nadapter speed: 5000 kHz\nInfo : clock speed 5000 kHz\nInfo : JTAG tap: arc-em.cpu tap/device found: 0x200044b1 (mfg: 0x258, part: 0x0004, ver: 0x2)\nInfo : JTAG tap: arc-em.cpu tap/device found: 0x200044b1 (mfg: 0x258, part: 0x0004, ver: 0x2)\ntarget state: halted\n</code></pre> <p>Then connect to the server using GDB:</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\n\n# Connect. Replace 49101 with port of your choice if you changed it when starting OpenOCD\n(gdb) target remote :49101\n\n# Increase timeout, because OpenOCD sometimes can be slow\n(gdb) set remotetimeout 15\n\n# Load application into target\n(gdb) load\n\n# Go to start of main function\n(gdb) tbreak main\n(gdb) continue\n\n# Resume with usual GDB commands\n(gdb) step\n(gdb) next\n\n# Go to end of the application\n(gdb) tbreak exit\n(gdb) continue\n\n# For example, check exit code of application\n(gdb) info reg r0\n</code></pre>"},{"location":"baremetal/hardware/debugging/#connecting-using-uart_1","title":"Connecting Using UART","text":"<p>If you are going to use input/output, then you need to configure these parameters of a serial terminal to interact with the serial port:</p> <ul> <li>baud-rate 115200</li> <li>8 data bits</li> <li>1 stop Bit</li> </ul> <p>For <code>minicom</code> use this command:</p> <pre><code>$ minicom -8 -b 115200 -D /dev/ttyUSB1\n</code></pre> <p>After resetting the EMSK 2.2 you will see this output of the bootloader:</p> <pre><code>***********************************\n**       Synopsys, Inc.          **\n**     ARC EM Starter kit        **\n**                               **\n** Comprehensive software stacks **\n**   available from embARC.org   **\n**                               **\n***********************************\nFirmware   Jan 11 2016, v2.2\nBootloader Dec 29 2015, v1.1\nARC EM11D, core configuration #3 \n\nARC IDENTITY = 0x42\nRF_BUILD = 0xc902\nTIMER_BUILD = 0x10304\nICCM_BUILD = 0x804\nDCCM_BUILD = 0x10804\nI_CACHE_BUILD = 0x135104\nD_CACHE_BUILD = 0x215104\n\nSelfTest PASSED\n\nInfo: No boot image found\n</code></pre>"},{"location":"baremetal/hardware/debugging/#hs-development-kit","title":"HS Development Kit","text":"<p>Info</p> <p>Please refer to board's documentation for detailed information about how to setup the board for initial operation:</p> <ul> <li>ARC HS Development Kit</li> <li>ARC HS4x/HS4xD Development Kit</li> </ul>"},{"location":"baremetal/hardware/debugging/#building-an-applications","title":"Building an Applications","text":"<p>Consider a simple application <code>main.c</code>:</p> <pre><code>int main()\n{\nint a = 1;\nint b = 2;\nint c = a + b;\nreturn c;\n}\n</code></pre> <p>Build an application with support of UART:</p> <pre><code>$ cp &lt;path-to-toolchain&gt;/arc-*/lib/hsdk.x memory.x\n$ arc-elf32-gcc -mcpu=hs38_linux -specs=hsdk.specs main.c -o main.elf\n</code></pre> <p>Build without support of UART, but if you are going to use interrupts (it allows to catch memory errors):</p> <pre><code>$ cp &lt;path-to-toolchain&gt;/arc-*/lib/hsdk.x memory.x\n$ arc-elf32-gcc -mcpu=hs38_linux -specs=nosys.specs -Wl,-marcv2elfx \\\n-Wl,--defsym=ivtbase_addr=0x90000000 main.c -o main.elf\n</code></pre> <p>A simple build if you are not going to use UART and interrupts:</p> <pre><code>$ arc-elf32-gcc -mcpu=hs38_linux -specs=nosys.specs main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/debugging/#running-an-application_1","title":"Running an Application","text":"<p>Follow Running OpenOCD Server section and start OpenOCD with 49101 port and <code>snps_hsdk.cfg</code> (for HSDK) of <code>snps_hsdk_4xd.cfg</code> (for HSDK 4xD) configuration file. Here is a possible output for HSDK 4xD:</p> <pre><code>Open On-Chip Debugger 0.12.0+dev-gffa52f0e0 (2023-08-02-10:41)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.org/doc/doxygen/bugs.html\nInfo : target has l2 cache enabled is enabled\nInfo : target has l2 cache enabled is enabled\nInfo : target has l2 cache enabled is enabled\nInfo : target has l2 cache enabled is enabled\n32768\nInfo : Listening on port 6666 for tcl connections\nInfo : Listening on port 4444 for telnet connections\nInfo : ftdi: if you experience problems at higher adapter clocks, try the command \"ftdi tdo_sample_edge falling\"\nInfo : clock speed 10000 kHz\nInfo : JTAG tap: arc-em.cpu4 tap/device found: 0x100c54b1 (mfg: 0x258 (ARC International), part: 0x00c5, ver: 0x1)\nInfo : JTAG tap: arc-em.cpu3 tap/device found: 0x100854b1 (mfg: 0x258 (ARC International), part: 0x0085, ver: 0x1)\nInfo : JTAG tap: arc-em.cpu2 tap/device found: 0x100454b1 (mfg: 0x258 (ARC International), part: 0x0045, ver: 0x1)\nInfo : JTAG tap: arc-em.cpu1 tap/device found: 0x100054b1 (mfg: 0x258 (ARC International), part: 0x0005, ver: 0x1)\nInfo : starting gdb server for arc-em.cpu4 on 49101\nInfo : Listening on port 49101 for gdb connections\nInfo : starting gdb server for arc-em.cpu3 on 49102\nInfo : Listening on port 49102 for gdb connections\nInfo : starting gdb server for arc-em.cpu2 on 49103\nInfo : Listening on port 49103 for gdb connections\nInfo : starting gdb server for arc-em.cpu1 on 49104\nInfo : Listening on port 49104 for gdb connections\n</code></pre> <p>Then connect to the server using GDB (49104 port is used below in GDB session, because cores are numbered in reverse order and 49104 port corresponds to the first core):</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\n(gdb) target remote :49104\n\n# Increase timeout, because OpenOCD sometimes can be slow\n(gdb) set remotetimeout 15\n\n# Load application into target\n(gdb) load\n\n# Go to start of main function\n(gdb) tbreak main\n(gdb) continue\n\n# Resume with usual GDB commands\n(gdb) step\n(gdb) next\n\n# Go to end of the application\n(gdb) tbreak exit\n(gdb) continue\n\n# For example, check exit code of application\n(gdb) info reg r0\n</code></pre>"},{"location":"baremetal/hardware/debugging/#connecting-using-uart_2","title":"Connecting Using UART","text":"<p>If you are going to use input/output, then you need to configure these parameters of a serial terminal to interact with the serial port:</p> <ul> <li>baud-rate 115200</li> <li>8 data bits</li> <li>1 stop Bit</li> <li>No HW/SW flow control</li> </ul> <p>For <code>minicom</code> use this command:</p> <pre><code>$ minicom -8 -b 115200 -D /dev/ttyUSB0 -s\n</code></pre> <p>Then choose <code>Serial port setup</code>, press <code>F</code> to disable <code>Hardware Flow Control</code>, press <code>Enter</code> key and then choose <code>Exit</code> to close the configuration menu.</p> <p>After resetting HSDK you will see this output of the bootloader:</p> <pre><code>********************************\n**       Synopsys, Inc.       **\n**   ARC HS Development Kit   **\n********************************\n** IC revision: Rev 2.0\n** Bootloader verbosity: Normal\n** Starting HS Core 1\n** HS Core running @ 500 MHz\nfptr = 8** HS Core fetching application from SPI flash\n** HS Core starting application\n&lt;debug_uart&gt; \n\nU-Boot 2020.01 (Apr 26 2020 - 22:30:20 +0300)\n\nCPU:   ARC HS v4.0 at 500 MHz\nModel: snps,hsdk-4xd\nBoard: Synopsys ARC HS4x/HS4xD Development Kit\nDRAM:  1 GiB\nRelocation Offset is: 3ef8a000\nMMC:   mmc0@f000a000: 0\nLoading Environment from FAT... MMC: no card present\nIn:    serial0@f0005000\nOut:   serial0@f0005000\nErr:   serial0@f0005000\nClock values are saved to environment\nNet:   \nWarning: ethernet@f0008000 (eth0) using random MAC address - c2:26:b0:99:98:4a\neth0: ethernet@f0008000\nhsdk-4xd# \n</code></pre>"},{"location":"baremetal/hardware/debugging/#development-platforms-table","title":"Development Platforms Table","text":"Board Core <code>-specs=</code> Memory map OpenOCD config GCC options EMSK 1 EM4 <code>emsk.specs</code> <code>emsk1_em4.x</code> <code>snps_em_sk_v1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh5</code> EMSK 1 EM6 <code>emsk.specs</code> <code>emsk1_em6.x</code> <code>snps_em_sk_v1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh5</code> EMSK 2.0 EM5D <code>emsk.specs</code> <code>emsk2.1_em5d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4 -mswap -mnorm -mmpy-option=wlh3 -mbarrel-shifter</code> EMSK 2.0 EM7D <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4 -mswap -mnorm -mmpy-option=wlh3 -mbarrel-shifter</code> EMSK 2.0 EM7DFPU <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4 -mswap -mnorm -mmpy-option=wlh3 -mbarrel-shifter -mfpu=fpuda_all</code> EMSK 2.1 EM5D <code>emsk.specs</code> <code>emsk2.1_em5d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh3</code> EMSK 2.1 EM7D <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh3</code> EMSK 2.1 EM7DFPU <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4_fpuda -mmpy-option=wlh3</code> EMSK 2.2 EM7D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.2.cfg</code> <code>-mcpu=em4_dmips</code> EMSK 2.2 EM9D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.2.cfg</code> <code>-mcpu=em4_fpus -mfpu=fpus_all</code> EMSK 2.2 EM11D <code>emsk.specs</code> <code>emsk2.2_em11d.x</code> <code>snps_em_sk_v2.2.cfg</code> <code>-mcpu=em4_fpuda -mfpu=fpuda_all</code> EMSK 2.3 EM7D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.3.cfg</code> <code>-mcpu=em4_dmips</code> EMSK 2.3 EM9D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.3.cfg</code> <code>-mcpu=em4_fpus -mfpu=fpus_all</code> EMSK 2.3 EM11D <code>emsk.specs</code> <code>emsk2.2_em11d.x</code> <code>snps_em_sk_v2.3.cfg</code> <code>-mcpu=em4_fpuda -mfpu=fpuda_all</code> HSDK HS3x <code>hsdk.specs</code> <code>hsdk.x</code> <code>snps_hsdk.cfg</code> <code>-mcpu=hs38_linux</code> HSDK 4x/4xD HS4x/HS4xD <code>hsdk.specs</code> <code>hsdk.x</code> <code>snps_hsdk_4xd.cfg</code> <code>-mcpu=hs38_linux</code> IoTDK ??? <code>iotdk.specs</code> <code>iotdk.x</code> <code>snps_iotdk.cfg</code> <code>-mcpu=em4_dmips</code>"},{"location":"baremetal/hardware/debugging/#running-openocd-server","title":"Running OpenOCD Server","text":"<p>OpenOCD is used for starting a GDB server for connecting to a board. Suppose, that EM Starter Kit 2.3 is used. If you\u2019ve downloaded IDE bundle for Linux then you can run OpenOCD this way (replace <code>&lt;ide&gt;</code> by a path to the directory of IDE bundle):</p> <pre><code>$ &lt;ide&gt;/bin/openocd -s &lt;ide&gt;/share/openocd/scripts -c 'gdb_port 49101' -f board/snps_em_sk_v2.3.cfg\n</code></pre> <p>If you\u2019ve built and installed OpenOCD manually then you can run OpenOCD this way:</p> <pre><code>$ openocd  -c 'gdb_port 49101' -f board/snps_em_sk_v2.2.cfg\n</code></pre> <p>If you\u2019ve downloaded and installed IDE bundle for Windows then you can run OpenOCD this way:</p> <pre><code>$ openocd -s C:\\arc_gnu\\share\\openocd\\scripts -c \"gdb_port 49101\" -f board\\snps_em_sk_v2.3.cfg\n</code></pre>"},{"location":"baremetal/hardware/memory/","title":"Memory Maps and Linker Scripts","text":""},{"location":"baremetal/hardware/memory/#linker-scripts-and-linker-emulation","title":"Linker Scripts and Linker Emulation","text":"<p>Linker script is a special file which specifies where to put different sections of ELF file and defines particular symbols which may be referenced by an application. Linker emulation is basically way to select one of the predetermined linker scripts of the GNU linker. A linker script for a default linker emulation for ARCv2 may be observed this way:</p> <pre><code>$ arc-elf32-ld --verbose\nGNU ld (ARCompact/ARCv2 ISA elf32 toolchain - build 1360) 2.40.50.20230314\n  Supported emulations:\n   arcelf\n   arclinux\n   arclinux_nps\n   arcv2elf\n   arcv2elfx\nusing internal linker script:\n==================================================\n/* Default linker script, for normal executables */\nOUTPUT_FORMAT(\"elf32-littlearc\", \"elf32-bigarc\",\n              \"elf32-littlearc\")\nOUTPUT_ARCH(arc)\nENTRY(__start)\n\n...\n\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x100)); . = SEGMENT_START(\"text-segment\", 0x100);\n  .interp         : { *(.interp) }\n  .hash           : { *(.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rel.init       : { *(.rel.init) }\n  .rela.init      : { *(.rela.init) }\n\n...\n</code></pre> <p>Linux user-space applications are loaded by the dynamic linker in their own virtual memory address space, where they do not collide with other applications. On the other side, baremetal applications are loaded into target's memory by debugger, bootloader or they are already in the ROM mapped to a specific location.</p> <p>If linker uses an invalid memory map for a particular platform, then some parts of the application will be loaded to the memory incorrectly. For example, it may be accidentally written to peripherals' region and cause an error.</p> <p>That default linker emulation places all loadable ELF sections in a row after each other starting at address <code>0x0</code>. This is usually enough for an application prototyping, however real systems often have much more complex memory maps with CCM regions, peripherals' region, etc.</p> <p>Default linker emulation also puts interrupt vector table (<code>.ivt</code> section) between code and data sections and doesn't align <code>.ivt</code> properly (<code>.ivt</code> must be 1KiB-aligned for ARC processors). Here is an example:</p> <pre><code>$ arc-elf32-gcc -mcpu=em4_dmips main.c -o main.elf\n$ arc-elf32-objdump -h main.elf\n\nmain.elf:     file format elf32-littlearc\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .init         00000022  00000100  00000100  00000100  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .text         00003c28  00000124  00000124  00000124  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  2 .fini         00000016  00003d4c  00003d4c  00003d4c  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  3 .rodata       00000014  00003d64  00003d64  00003d64  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .ivt          00000054  00003d78  00003d78  00003d78  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  5 .data         00000530  00005dcc  00005dcc  00003dcc  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n</code></pre> <p>Therefore the default linker emulation is not applicable for applications which handle interrupts. It can be used safely only with applications which don't handle interrupts and only on simulations which simulate whole address space, like following templates: <code>em6_dmips</code>, <code>em6_gp</code>, <code>em6_mini</code>, <code>em7d_nrg</code>, <code>em7d_voice_audio</code>, <code>em11d_nrg</code>, <code>em11d_voice_audio</code>, <code>hs36_base</code>, <code>hs36</code>, <code>hs38_base</code>, <code>hs38</code>, <code>hs38_full</code>, <code>hs38_slc_full</code>.</p>"},{"location":"baremetal/hardware/memory/#using-arcv2elfx-linker-emulation","title":"Using <code>arcv2elfx</code> linker emulation","text":"<p>If you use <code>arcv2elfx</code> linker emulation, then linker searches for <code>memory.x</code> file with definition of a custom memory map. It is searched in the current working directory and in directories listed via <code>-L</code> option.</p>"},{"location":"baremetal/hardware/memory/#em-starter-kit","title":"EM Starter Kit","text":"<p>Here is an example of <code>memory.x</code> for EM11D core in EM Starter Kit v2.3:</p> <pre><code>MEMORY\n{\n    ICCM : ORIGIN = 0x00000000, LENGTH = 64K\n    DRAM : ORIGIN = 0x10000000, LENGTH = 128M\n    DCCM : ORIGIN = 0x80000000, LENGTH = 64K\n}\n\nREGION_ALIAS(\"startup\", ICCM)\nREGION_ALIAS(\"text\", ICCM)\nREGION_ALIAS(\"data\", DRAM)\nREGION_ALIAS(\"sdata\", DRAM)\n\nPROVIDE (__stack_top = (0x17FFFFFF &amp; -4) );\nPROVIDE (__end_heap = (0x17FFFFFF) );\n</code></pre> <p><code>MEMORY</code> section specifies platform's memory regions: base addresses and lengths. You can use arbitrary names for these regions. <code>REGION_ALIAS</code> commands translate platform's regions to standard region names expected by the linker emulation. There are 4 such standard regions:</p> <ul> <li><code>startup</code> - interrupt vector table and initialization code. By default it's mapped to <code>0x0</code> address and if you map <code>startup</code> to a different one, then you also need to pass this address to the linker using <code>--defsym=ivtbase_addr=&lt;...&gt;</code> option or to GCC itself using <code>-Wl,--defsym=ivtbase_addr=&lt;...&gt;</code> option.</li> <li><code>text</code> - other code sections.</li> <li><code>data</code> - data sections.</li> <li><code>sdata</code> - small data sections.</li> </ul> <p>Also, the example provides these symbols (both of them may be omitted and default values will be used):</p> <ul> <li><code>__stack_top</code> points to the top of the stack. It must be 4-byte aligned In the example it points to the end   of DRAM regions, because stack grows downward.</li> <li><code>__end_heap</code> points to the end of the heap. Heap starts at the end of data sections   and grows upward to <code>__end_heap</code>.</li> </ul> <p>You can compile your application against that <code>memory.x</code> file by passing <code>-marcv2elfx</code> to the linker or <code>-Wl,-marcv2elfx</code> to GCC itself:</p> <pre><code>$ ls\nmain.c memory.x\n$ arc-elf32-gcc -mcpu=em4_dmips -Wl,-marcv2elfx main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/memory/#hs-development-kit","title":"HS Development Kit","text":"<p>Here is an example of <code>memory.x</code> for HS Development Kit:</p> <pre><code>MEMORY\n{\n    DRAM : ORIGIN = 0x90000000, LENGTH = 0x50000000\n}\n\nREGION_ALIAS(\"startup\", DRAM)\nREGION_ALIAS(\"text\", DRAM)\nREGION_ALIAS(\"data\", DRAM)\nREGION_ALIAS(\"sdata\", DRAM)\n</code></pre> <p><code>startup</code> is mapped to <code>0x90000000</code>. It means that you have to pass <code>-Wl,--defsym=ivtbase_addr=&lt;...&gt;</code> option too. You can compile your application against that <code>memory.x</code> this way:</p> <pre><code>$ ls\nmain.c memory.x\n$ arc-elf32-gcc -mcpu=archs -Wl,-marcv2elfx -Wl,--defsym=ivtbase_addr=0x90000000 main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/memory/#memory-maps-for-hardware-platforms","title":"Memory Maps for Hardware Platforms","text":"<p>You can find valid memory mappings for particular hardware platforms in documentation. Here is a list of resources with memory maps for Synopsys' development platforms:</p> <ul> <li>ARC Development Systems Forum Wiki contains documentation for all Synopsys' development platforms. User guides contain descriptions of memory mappings.</li> <li>Newlib repository for ARC contains predefined   memory maps for some of development platforms  in <code>libgloss/arc</code> directory.</li> <li>toolchain repository also contains predefined   memory maps for some of development platforms in <code>extras/dev_systems</code> directory.</li> </ul>"},{"location":"baremetal/simulators/nsim/","title":"Building Applications and Debugging on nSIM","text":""},{"location":"baremetal/simulators/nsim/#building-and-debugging-applications","title":"Building and Debugging Applications","text":"<p>nSIM supports running and debugging applications for all ARC families. Debugging is not supported for ARCv3 families yet.</p> <p>There is no a definite match between TCF templates for nSIM and <code>-mcpu</code> values for GNU toolchain. If you want to build a program using GNU toolchain and run it on nSIM simulator , then you have two ways of finding right nSIM options:</p> <ol> <li>Find proper nSIM options in a compatibility table (link to another page).</li> <li>Use default TCF templates and additional nSIM options.</li> </ol> <p>There is a table with an a rough matching between <code>-mcpu</code> values and TCF templates with additional options:</p> Compiler <code>-mcpu</code> TCF Additional nSIM options <code>arc-elf32-gcc</code> <code>hs</code> <code>hs36_base</code> <code>arc-elf32-gcc</code> <code>hs34</code> <code>hs36</code> <code>arc-elf32-gcc</code> <code>hs38</code> <code>hs38_full</code> <code>arc-elf32-gcc</code> <code>hs38_linux</code> <code>hs38_full</code> <code>-on nsim_isa_fpud_option -on nsim_isa_fpud_div_option -on nsim_isa_fpu_mac_option -on nsim_isa_fpu_hp_option</code> <code>arc-elf32-gcc</code> <code>archs</code> <code>hs38_full</code> <code>-p\u00a0nsim_isa_mpy_option=2</code> <code>arc-elf32-gcc</code> <code>em</code> <code>em6_mini</code> <code>-p\u00a0nsim_isa_shift_option=3 -p\u00a0nsim_isa_rgf_num_regs=32</code> <code>arc-elf32-gcc</code> <code>em4</code> <code>em6_mini</code> <code>-p\u00a0nsim_isa_shift_option=3 -p\u00a0nsim_isa_rgf_num_regs=32</code> <code>arc-elf32-gcc</code> <code>em4_dmips</code> <code>em6_dmips</code> <code>arc-elf32-gcc</code> <code>em4_fpus</code> <code>em6_dmips</code> <code>-on\u00a0nsim_isa_fpus_option</code> <code>arc-elf32-gcc</code> <code>em4_fpuda</code> <code>em6_dmips</code> <code>-on\u00a0nsim_isa_fpus_option -on\u00a0nsim_isa_fpuda_option</code> <code>arc-elf32-gcc</code> <code>arcem</code> <code>em6_dmips</code> <code>-off\u00a0nsim_isa_bitscan_option -off\u00a0nsim_isa_div_rem_option</code> <code>arc-elf32-gcc</code> <code>arc700</code> <code>arc770d</code> <code>arc-elf32-gcc</code> <code>arc600</code> <code>arc625d</code> <code>arc64-elf-gcc</code> <code>hs5x</code> <code>hs58_full</code> <code>-on\u00a0nsim_isa_ll64_option</code> <code>arc64-elf-gcc</code> <code>hs58</code> <code>hs58_full</code> <code>-on\u00a0nsim_isa_ll64_option</code> <code>arc64-elf-gcc</code> <code>hs6x</code> <code>hs68_full</code> <code>arc64-elf-gcc</code> <code>hs68</code> <code>hs68_full</code> <p>You need to use <code>arceb-</code> prefix for tools instead for <code>arc-</code> for big endian targets. Also you need to pass <code>-on nsim_isa_big_endian</code> to nSIM for big endian targets. Note that the toolchain for ARCv3 targets does not support big endian targets yet.</p> <p>Suppose that <code>main.c</code> contains an application to be debugged on nSIM:</p> <pre><code>int main()\n{\nreturn 0;\n}\n</code></pre> <p>Then build it (we use <code>-specs=nosys.specs</code> if input/output operations are not needed) for ARC HS3x using <code>-mcpu=hs38</code>:</p> <pre><code>$ arc-elf32-gcc -mcpu=hs38 -specs=nosys.specs -g main.c -o main.elf\n</code></pre> <p>Start nSIM with a GDB server with 12345 port:</p> <pre><code>$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -gdb -port 12345\n</code></pre> <p>Run GDB in another terminal and debug the application:</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\nReading symbols from main.elf...\n(gdb) target remote :12345\nRemote debugging using :12345\n0x80000000 in ?? ()\n(gdb) load\nLoading section .init, size 0x22 lma 0x100\nLoading section .text, size 0x1548 lma 0x124\nLoading section .fini, size 0x16 lma 0x166c\nLoading section .ivt, size 0x54 lma 0x1682\nLoading section .data, size 0x534 lma 0x36d8\nLoading section .ctors, size 0x8 lma 0x3c0c\nLoading section .dtors, size 0x8 lma 0x3c14\nLoading section .sdata, size 0x10 lma 0x3c1c\nStart address 0x00000124, load size 6952\nTransfer rate: 188 KB/sec, 869 bytes/write.\n(gdb) b main\nBreakpoint 1 at 0x276: file main.c, line 3.\n(gdb) c\nContinuing.\n\nBreakpoint 1, main () at main.c:3\n3           return 0;\n(gdb)\n</code></pre>"},{"location":"baremetal/simulators/nsim/#building-and-running-hello-world","title":"Building and Running \"Hello, World!\"","text":"<p>Consider a simple example code (save it as <code>main.c</code>):</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\nprintf(\"Hello, World!\\n\");\nreturn 0;\n}\n</code></pre> <p>You need to use <code>-specs=nsim.specs</code> to use input/output features and to pass <code>-on nsim_emt</code> option to nSIM to use ARC GNU input/output protocol:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=nsim.specs main.c -o main.elf\n$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on nsim_emt main.elf\nHello, World!\n</code></pre> <p>You can use MetaWare's own hostlink protocol for input/output operations by passing <code>-specs=hl.specs</code> to GCC. In this case you don't have to pass any additional options to nSIM:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=hl.specs main.c -o main.elf\n$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf main.elf\nHello, World!\n</code></pre>"},{"location":"baremetal/simulators/qemu/","title":"Building Applications and Debugging on QEMU","text":""},{"location":"baremetal/simulators/qemu/#building-and-debugging-applications","title":"Building and Debugging Applications","text":"<p>QEMU supports running and debugging applications for ARC HS3x/HS4x, HS5x and HS6x families. Here is a table of tools and options for a particular family:</p> CPU family Toolchain <code>-mcpu=</code> QEMU binary ARC-specific QEMU options ARC HS3x/HS4x <code>arc-elf32-gcc</code> <code>-mcpu=archs</code> <code>qemu-system-arc</code> <code>-M arc-sim -cpu archs</code> ARC HS5x <code>arc64-elf-gcc</code> <code>-mcpu=hs5x</code> <code>qemu-system-arc</code> <code>-M arc-sim -cpu hs5x</code> ARC HS6x <code>arc64-elf-gcc</code> <code>-mcpu=hs6x</code> <code>qemu-system-arc64</code> <code>-M arc-sim -cpu hs6x</code> <p>Suppose that <code>main.c</code> contains an application to be debugged on QEMU for ARC HS3x/4x:</p> <pre><code>int main()\n{\nreturn 0;\n}\n</code></pre> <p>Then build it (we use <code>-specs=nosys.specs</code> if input/output operations are not needed):</p> <pre><code>arc-elf32-gcc -mcpu=archs -specs=nosys.specs -g main.c -o main.elf\n</code></pre> <p>Start a GDB server in port 1234 (this is the default port, so we could use the alias <code>-s</code> instead of <code>-gdb tcp::1234</code>):</p> <pre><code>qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic -no-reboot \\\n-gdb tcp::1234 -S -kernel main.elf\n</code></pre> <p>Debug the application:</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\nReading symbols from main.elf...\n(gdb) target remote :1234\nRemote debugging using :1234\n0x00000124 in __start ()\n(gdb) load\nLoading section .init, size 0x22 lma 0x100\nLoading section .text, size 0x1554 lma 0x124\nLoading section .fini, size 0x16 lma 0x1678\nLoading section .ivt, size 0x54 lma 0x168e\nLoading section .data, size 0x534 lma 0x36e8\nLoading section .ctors, size 0x8 lma 0x3c1c\nLoading section .dtors, size 0x8 lma 0x3c24\nLoading section .sdata, size 0x10 lma 0x3c2c\nStart address 0x00000124, load size 6964\nTransfer rate: 1700 KB/sec, 696 bytes/write.\n(gdb) b main\nBreakpoint 1 at 0x276: file main.c, line 3.\n(gdb) c\nContinuing.\n\nBreakpoint 1, main () at main.c:3\n3               return 0;\n(gdb)\n</code></pre>"},{"location":"baremetal/simulators/qemu/#using-a-socket-instead-of-port","title":"Using a Socket Instead of Port","text":"<p>If known ports are busy then you can connect to the GDB server using a socket. Expose GDB server through socket instead of port</p> <pre><code>qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic -no-reboot \\\n-chardev socket,path=/tmp/gdb-socket,server=on,wait=off,id=gdb0 \\\n-gdb chardev:gdb0 -S -kernel main.elf\n</code></pre> <p>Connect to the GDB server <pre><code>$ arc-elf32-gdb -quiet main.elf\nReading symbols from main.elf...\n(gdb) target remote /tmp/gdb-socket\nRemote debugging using /tmp/gdb-socket\n0x00000124 in __start ()\n...\n</code></pre></p>"},{"location":"baremetal/simulators/qemu/#building-and-running-hello-world","title":"Building and Running \"Hello, World!\"","text":"<p>Consider a simple example code (save it as <code>main.c</code>):</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\nprintf(\"Hello, World!\\n\");\nreturn 0;\n}\n</code></pre> <p>You need to use <code>-specs=qemu.specs</code> to use input/output features and pass <code>-serial stdio</code> to link a virtual character device with host's <code>stdio</code>:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=qemu.specs main.c -o main.elf\n$ qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic \\\n                  -no-reboot -serial stdio -kernel main.elf\nHello, World!\n</code></pre> <p>By default, QEMU creates a character device for <code>arc-sim</code> board on hard coded <code>0x90000000</code> address. A program built with <code>-specs=qemu.specs</code> uses this address for all input/output operations. However, if <code>-semihosting</code> option is passed to QEMU, then it uses the same input/output interface as nSIM with <code>-on nsim_emt</code> option. It allows to use the same binary for running both on QEMU and nSIM:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=nsim.specs main.c -o main.elf\n$ qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic \\\n                  -no-reboot -serial stdio -semihosting -kernel main.elf\nHello, World!\n</code></pre>"},{"location":"baremetal/simulators/qemu/#building-and-running-hello-world-using-metaware-development-toolkit","title":"Building and Running \"Hello, World!\" Using MetaWare Development Toolkit","text":"<p>MetaWare\u2019s standard runtime library does not support input/output interfaces of QEMU for ARC. But it is possible to implement your own basic <code>hostlink</code> library for MetaWare to meet QEMU's requirements. You have to implement at least one function to add support of simple output:</p> <pre><code>int _write (int handle, const char *buf, unsigned int count)\n{\nunsigned int i = 0;\nwhile (i &lt; count)\n{\n*(char *) 0x90000000 = buf[i++];\n}\nreturn count;\n}\n</code></pre> <p>It's a slightly modified <code>_write</code> from <code>libqemu.a</code> for Newlib. Save it as <code>write.c</code> file and compile it along with <code>main.c</code>:</p> <pre><code># For ARC HS3x/HS4x\nccac -av2hs -Hhostlib= main.c write.c -o main.elf\n\n# For ARC HS5x\nccac -av3hs -Hhostlib= main.c write.c -o main.elf\n\n# For ARC HS6x\nccac -arc64 -Hhostlib= main.c write.c -o main.elf\n</code></pre> <p>Run it using QEMU:</p> <pre><code># For ARC HS3x/HS4x\nqemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic \\\n-no-reboot -serial stdio -kernel main.elf\n\n# For ARC HS5x\nqemu-system-arc -M arc-sim -cpu hs5x -monitor none -display none -nographic \\\n-no-reboot -serial stdio -kernel main.elf\n\n# For ARC HS6x\nqemu-system-arc64 -M arc-sim -cpu hs6x -monitor none -display none -nographic \\\n-no-reboot -serial stdio -kernel main.elf\n</code></pre>"},{"location":"eclipse/","title":"Eclipse IDE","text":"<p>The ARC GNU Eclipse IDE consists of the Eclipse IDE combined with an Eclipse CDT Managed Build Extension plug-in for the ARC GNU Toolchain and GDB embedded debugger plug-in for ARC, based on the Zylin Embedded CDT plug-in.  The ARC GNU IDE supports the development of managed C/C++ applications for ARC processors using the ARC GNU toolchain for bare metal applications (elf32).</p> <p>The ARC GNU IDE provides support for the following functionality:</p> <ul> <li>Support for the ARC EM, ARC HS, ARC 600 and ARC 700 Processors</li> <li>Support for little and big endian configurations</li> <li>Ability to create C/C++ projects using the ARC elf32 cross-compilation   toolchain</li> <li>Configuration of toolchain parameters per project</li> <li> <p>Configuration of individual options (such as preprocessor, optimization,   warnings, libraries, and debugging levels) for each toolchain component:</p> <ul> <li>GCC Compiler</li> <li>GDB Debugger</li> <li>GAS assembler</li> <li>Size binutils utility, etc.</li> </ul> </li> <li> <p>Support for Synopsys EM Starter Kit and AXS10x.</p> </li> <li>Configuration of debug and run configurations for supported FPGA Development   Systems and debug probes (Digilent HS1/HS2 or Ashling Opella-XD).</li> <li>GDB-based debugging using Debug perspective providing detailed debug   information (including breakpoints, variables, registers, and disassembly)</li> </ul> <p>ARC GNU plugins for Eclipse have following requirements to the system:</p> <ul> <li>OS: Windows 10, Ubuntu Linux 16.04 LTS and CentOS 7 development host systems</li> <li>Eclipse 2018-12 (part of Windows installer)</li> <li>CDT version 9.6.0 (part of Windows installer)</li> <li>Java VM version &gt;= 1.8 is required (part of Windows installer)</li> </ul>"},{"location":"eclipse/installation/linux/","title":"Installing Eclipse IDE on Linux","text":""},{"location":"eclipse/installation/linux/#installing-eclipse-ide","title":"Installing Eclipse IDE","text":"<p>Eclipse IDE for ARC GNU toolchain may be downloaded as <code>.tar.gz</code> archive from the releases page. It contains toolchains, OpenOCD and Eclipse itself.</p>"},{"location":"eclipse/installation/linux/#adjusting-rights-for-varlock","title":"Adjusting Rights for <code>/var/lock</code>","text":"<p>If you plan to connect to UART port on target board with RxTx plugin controlled by IDE you need to change permissions of directory <code>/var/lock</code> in your system. Usually by default only users with root access are allowed to write into this directory, however RxTx tries to write file into this directory, so unless you are ready to run IDE with sudo, you need to allow write access to <code>/var/lock</code> directory for everyone. Note that if <code>/var/lock</code> is a symbolic link to another directory then you need to change permissions for this directory as well.</p> <p>Here is an example of adjusting rights for <code>/var/lock</code>:</p> <pre><code>$ ls -l /var/lock\nlrwxrwxrwx 1 root root 9 Jun 10 18:24 /var/lock -&gt; /run/lock\n$ ls -ld /run/lock\ndrwxrwxrwt 3 root root 100 Aug  1 15:12 /run/lock\n$ sudo chmod go+w /run/lock \n$ ls -ld /run/lock\ndrwxrwxrwt 3 root root 100 Aug  1 15:12 /run/lock\n</code></pre> <p>If it is not possible or not desirable to change permissions for this directory, then serial port connection must be disabled in Eclipse debugger configuration window.</p>"},{"location":"eclipse/installation/linux/#adding-a-user-to-dialout-group","title":"Adding a User to <code>dialout</code> Group","text":"<p>Add a user to <code>dialout</code> group to allow the user to connect to the UART device (<code>/dev/ttyUSBx</code>):</p> <pre><code>$ sudo usermod -a -G dialout `whoami`\n</code></pre>"},{"location":"eclipse/installation/linux/#configuring-openocd","title":"Configuring OpenOCD","text":"<p>Follow Getting OpenOCD guide to configure OpenOCD.</p>"},{"location":"eclipse/installation/manual/","title":"Manual Installation","text":""},{"location":"eclipse/installation/manual/#installing-eclipse","title":"Installing Eclipse","text":"<p>Download Eclipse IDE for C/C++ Developers 2020.03 from the official download page. Extract it to <code>eclipse</code> directory.</p>"},{"location":"eclipse/installation/manual/#install-java-se-11-runtime","title":"Install Java SE 11 Runtime","text":"<p>Download Java SE 11 runtime from the official Java download page. Suppose, that the archive contains <code>jdk-11.0.19</code> directory, then extract it to <code>eclipse</code> directory and rename to <code>jre</code>.</p>"},{"location":"eclipse/installation/manual/#downloading-the-plugin","title":"Downloading the Plugin","text":"<p>User can get the latest plugin from the release page. For example, filename of the archive with the plugin for 2023.03 release is <code>arc_gnu_2023.03_ide_plugins.zip</code>.</p> <p>Here is an example of plugin's directory contents:</p> <pre><code>$ tree\n.\n\u251c\u2500\u2500 artifacts.jar\n\u251c\u2500\u2500 content.jar\n\u251c\u2500\u2500 features\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 com.arc.cdt.feature_2019.9.0.202306091135.jar\n\u2514\u2500\u2500 plugins\n    \u251c\u2500\u2500 com.arc.embeddedcdt_2019.9.0.202306091135.jar\n    \u2514\u2500\u2500 com.synopsys.arc.gnu.elf_2019.9.0.202306091135.jar\n\n3 directories, 5 files\n</code></pre>"},{"location":"eclipse/installation/manual/#installing-the-plugin","title":"Installing the Plugin","text":""},{"location":"eclipse/installation/manual/#installing-tm-terminal","title":"Installing \"TM Terminal\"","text":"<p>Install \"TM Terminal\" plugin through \"Help\" -&gt; \"Install New Software...\" menu. Choose \"--All Available Sites--\" in \"Work with\" field. Wait until a list of available plugins is updated and select \"General Purpose Tools\" -&gt; \"TM Terminal\" plugin. Press \"Next\" button and proceed with the installation process.</p>"},{"location":"eclipse/installation/manual/#installing-arc-gnu-plugin","title":"Installing ARC GNU Plugin","text":"<p>Open \"Help\" -&gt; \"Install New Software...\" -&gt; Add -&gt; Archive menu and and select the downloaded plugin's archive (e.g., <code>arc_gnu_2023.03_ide_plugins.zip</code>). Then choose \"ARC GNU Tools Support\", press \"Next\" button and proceed with the installation process:</p> <p></p> <p>Press \"Install anyway\" when \"Security Warning\" is shown:</p> <p></p> <p>You can find information about the installed plugins in \"Help\" -&gt; \"About Eclipse IDE\" -&gt; \"Installation Details\" window.</p>"},{"location":"eclipse/installation/manual/#updating-the-existing-plugin","title":"Updating the Existing Plugin","text":"<p>To update the existing plugin follow Installing Eclipse guide but for the newer plugin version.</p>"},{"location":"eclipse/installation/preferences/","title":"Plugin Preferences","text":"<p>ARC plugins in IDE support preferences that can alter their behavior. These preferences are unlikely to be useful for end-user, so they are not exposed via GUI, but they can be modified via preferences files located in Eclipse workspace folder in <code>.metadata/.plugins/org.eclipse.core.runtime/.settings</code> folder.</p> <p>Debugger plugin preferences are located in file <code>com.arc.embeddedcdt.prefs</code>:</p> <code>gdbserver_startup_delay</code> <p>Delay in milliseconds that this plugin wait for after starting <code>gdbserver</code> and before starting the GDB, thus allowing server to start listening on TCP port. Default value is 500.</p> <code>gdbserver_use_adaptive_delay</code> <p>Whether to try to use adaptive server startup delay or use only default fixed delay time. Default value is true.</p> <code>gdbserver_startup_timeout</code> <p>Amount of time in milliseconds given to <code>gdbserver</code> to start in adaptive startup procedure. Default value is 30000.</p> <code>gdbserver_startup_delay_step</code> <p>Amount of time to sleep in milliseconds after adaptive gdbserver startup delay procedure failed to connect to the server. In practice this can be very small, because <code>Socket.connect()</code> itself waits for 1 second. However I\u2019ve measured this value on my machine, so I\u2019m not sure it is equally valid everywhere, so I leave this is a possible parameter to modify if needed. Default value is 1.</p> <code>nsim_pass_reconnect_option</code> <p>Whether to start nSIM with option <code>-reconnect</code>. This is required for adaptive delay to work with nSIM. Default value is true.</p>"},{"location":"eclipse/installation/windows/","title":"Installing Eclipse IDE on Windows","text":""},{"location":"eclipse/installation/windows/#using-the-installer-for-windows","title":"Using the Installer for Windows","text":"<p>Windows users are advised to use our Windows installer for Eclipse for GNU Toolchain for IDE, that can be downloaded from this releases page. Installer already contains all of the necessary components. ARC GNU IDE should be installed in the path no longer than 50 characters and cannot contain white spaces.</p> <p>After downloading the installer, accept a license agreement and follow other steps. By default, Eclipse IDE is installed in <code>C:\\arc_gnu</code> directory. Eclipse IDE executable is <code>C:\\arc_gnu\\eclipse\\eclipse.exe</code>.</p>"},{"location":"eclipse/installation/windows/#installing-a-big-endian-toolchain","title":"Installing a Big Endian Toolchain","text":"<p>By default, Eclipse IDE installer does not choose a big endian toolchain for installing. Select this toolchain manually on \"Choose Components\" stage:</p> <p></p>"},{"location":"eclipse/other/building/","title":"Building the Eclipse Plugin","text":""},{"location":"eclipse/other/building/#preparing-an-environment","title":"Preparing an Environment","text":"<p>Info</p> <p>All builds and mirrors for Eclipse IDE itself may be found on release's page.</p> <p>We will assume that our build directory is <code>/build/eclipse</code>. All necessary tools, directories and prerequisite will be place there. Thus, go to this directory first:</p> <pre><code>$ mkdir /build/eclipse\n$ cd /build/eclipse\n</code></pre> <p>Also create a directory for storing downloaded Maven packages:</p> <pre><code>$ mkdir /build/eclipse/repository\n</code></pre> <p>Download and extract Maven:</p> <pre><code>$ wget https://dlcdn.apache.org/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz\n$ tar -xf apache-maven-3.5.4-bin.tar.gz\n</code></pre> <p>Download and extract JDK 11 to <code>/build/eclipse/jdk-11.0.17</code>.</p> <p>Download and extract Eclipse 2020.03 with CDT for Linux:</p> <pre><code>$ wget https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2020-03/R/eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64.tar.gz\n$ tar -xf eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64.tar.gz\n</code></pre> <p>Download and extract Eclipse 2020.03 with CDT for Windows:</p> <pre><code>wget https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2020-03/R/eclipse-cpp-2020-03-R-incubation-win32-x86_64.zip\ntar -xf eclipse-cpp-2020-03-R-incubation-win32-x86_64.zip\n</code></pre> <p>Clone a plugin's repository:</p> <pre><code>$ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/arc_gnu_eclipse\n</code></pre>"},{"location":"eclipse/other/building/#building-the-plugin","title":"Building the Plugin","text":"<p>Use this commands:</p> <pre><code>$ export JAVA_HOME=/build/eclipse/jdk-11.0.17\n$ export PATH=$JAVA_HOME/bin:$PATH\n$ /build/eclipse/apache-maven-3.5.4/bin/mvn \\\n-Dmaven.repo.local=/build/eclipse/repository clean install\n</code></pre> <p>After that an archive with the plugin will be saved here:</p> <pre><code>arc_gnu_eclipse/repository/target/repository-2019.9.0-SNAPSHOT.zip\n</code></pre>"},{"location":"eclipse/other/building/#installing-the-plugin","title":"Installing the Plugin","text":"<p>You can install the plugin to Eclipse for Linux this way:</p> <pre><code>$ unzip arc_gnu_eclipse/repository/target/repository-2019.9.0-SNAPSHOT.zip \\\n-d eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/dropins\n$ rm -f eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/dropins/artifacts.jar \\\neclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/dropins/content.jar\n$ echo \"-Dosgi.instance.area.default=@user.home/ARC_GNU_IDE_Workspace\" &gt;&gt; eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/eclipse.ini\n</code></pre> <p>You can install the plugin to Eclipse for Windows this way:</p> <pre><code>$ unzip arc_gnu_eclipse/repository/target/repository-2019.9.0-SNAPSHOT.zip \\\n-d eclipse-cpp-2020-03-R-incubation-win32-x86_64/dropins\n$ rm -f eclipse-cpp-2020-03-R-incubation-win32-x86_64/dropins/artifacts.jar \\\neclipse-cpp-2020-03-R-incubation-win32-x86_64/dropins/content.jar\n$ echo \"-Dosgi.instance.area.default=@user.home/ARC_GNU_IDE_Workspace\" &gt;&gt; eclipse-cpp-2020-03-R-incubation-win32-x86_64/eclipse.ini\n</code></pre>"},{"location":"general/processors/","title":"Synopsys ARC Processors","text":"<p>Synopsys ARC processors are represented by three generations of Instruction Set Architectures (ISA). Each ISA consists of one or more processor families with different microarchitectures. All cores may be configured to support little or big endianness. All families except ARC EM and ARC 600 families may be configured to support running complex operation systems like Linux. Some of them are listed here:</p> <ol> <li> <p>ARCv1 ISA:</p> <ul> <li>ARC 600 Processor Family of 32-bit cores</li> <li>ARC 700 Processor Family of 32-bit cores</li> </ul> </li> <li> <p>ARCv2 ISA:</p> <ul> <li>ARC EM Processor Family of 32-bit cores</li> <li>ARC HS Processor Family of 32-bit cores (HS3x, HS4x, HS4xD)</li> </ul> </li> <li> <p>ARCv3 ISA:</p> <ul> <li>ARC HS Processor Family of 32-bit cores (HS5x, HS5xD)</li> <li>ARC HS Processor Family of 64-bit cores (HS6x)</li> </ul> </li> </ol> <p>You can find programmer's reference manuals and datasheets for each core on corresponding web pages.</p>"},{"location":"general/target-options/","title":"Target Specific Options","text":""},{"location":"general/target-options/#overview","title":"Overview","text":"<p>In addition GCC options common to all targets, ARC GNU toolchains supports a set of <code>-m&lt;value&gt;</code> target specific options. Each of them configures a particular feature. For example, <code>-mno-code-density</code> option disables generating code density instructions.</p> <p><code>-mcpu=&lt;core&gt;</code> selects a particular ISA and CPU family and enables/disables a set of other <code>-m</code> options. Each <code>-mcpu</code> value leads to linking with a prebuilt library which corresponds to this particular <code>-mcpu=&lt;value&gt;</code> and is built using this <code>-mcpu=&lt;value&gt;</code>.</p> <p>For example, options combination <code>-mcpu=em4 -mno-code-density</code> generates code that doesn't use code density instructions, however it is linked with standard library that has been built with just <code>-mcpu=em4</code>, which uses code density instructions. Therefore a final application still may use code density instructions.</p> <p>All available target specific options may be found in an official GCC manual.</p>"},{"location":"general/target-options/#arcv1-and-arcv2-toolchains","title":"ARCv1 and ARCv2 Toolchains","text":""},{"location":"general/target-options/#target-options","title":"Target Options","text":"<p>Here is a table of target options for ARCv1 and ARCv2 CPU families with default values for CPU families (On, Off or N/A).</p> Options ARC HS ARC EM ARC 700 ARC 600 <code>-mbarrel-shifter</code> On Off On Off <code>-mnorm</code> On Off On Off <code>-mswap</code> On Off On Off <code>-rf16</code> Off Off Off Off <code>-mfpu=&lt;...&gt;</code> Off Off \u2014 \u2014 <code>-mmpy-option=&lt;...&gt;</code> Off Off \u2014 \u2014 <code>-mcode-density</code> On Off \u2014 \u2014 <code>-mdiv-rem</code> Off Off \u2014 \u2014 <code>-matomic</code> On \u2014 Off \u2014 <code>-mll64</code> Off \u2014 \u2014 \u2014 <code>-mspfp</code> \u2014 Off Off Off <code>-mdpfp</code> \u2014 Off Off Off <code>-msimd</code> \u2014 Off Off \u2014 <code>-mmargonaut</code> \u2014 \u2014 Off Off <code>-mea</code> \u2014 \u2014 Off \u2014 <code>-mmul64</code> \u2014 \u2014 \u2014 Off <code>-mmul32x16</code> \u2014 \u2014 \u2014 Off <code>-munaligned-access</code> <p>You can find a short description for all target options using <code>--target-help</code> option. For example:</p> <pre><code>$ arc-elf32-gcc --target-help\n...\n  -mbranch-index              Enable use of BI/BIH instructions when available.\n  -mcase-vector-pcrel         Use pc-relative switch case tables - this enables case table shortening.\n  -mcmem                      Enable use of NPS400 xld/xst extension.\n  -mcode-density              Enable code density instructions for ARCv2.\n  -mcode-density-frame        Enable ENTER_S and LEAVE_S opcodes for ARCv2.\n  -mcompact-casesi            Enable compact casesi pattern.  Uses of this option are diagnosed.\n  -mcpu=CPU                   Compile code for ARC variant CPU.\n  -mcrc                       Enable variable polynomial CRC extension.  Uses of this option are diagnosed.\n  -mdiv-rem                   Enable DIV-REM instructions for ARCv2.\n  -mdpfp                      FPX: Generate Double Precision FPX (compact) instructions.\n  -mdpfp-compact              FPX: Generate Double Precision FPX (compact) instructions.\n...\n</code></pre> <p>You can find what target options are enabled or disabled by a particular <code>-mcpu=&lt;...&gt;</code> using <code>-Q</code> options. For example:</p> <pre><code>$ arc-elf32-gcc -Q --target-help -mcpu=archs\n...\n  -mbranch-index                        [disabled]\n  -mcase-vector-pcrel                   [disabled]\n  -mcmem                                [disabled]\n  -mcode-density                        [enabled]\n  -mcode-density-frame                  [disabled]\n  -mcompact-casesi                      [disabled]\n  -mcpu=CPU                             archs\n  -mcrc                                 [disabled]\n  -mdiv-rem                             [enabled]\n  -mdpfp                                [disabled]\n  -mdpfp-compact                        [disabled]\n...\n</code></pre> <p>Also, there are several configuration files in GCC's source tree that describe target options for all targets. All of them may be found in <code>gcc/config/arc</code> directory:</p> <ul> <li><code>arc-options.def</code>, <code>arc-opts.h</code>, <code>arc.opt</code> -  definitions and descriptions for all target options.</li> <li><code>arc-arches.def</code> - definitions of CPU families with all available and default target options.</li> <li><code>arc-cpus.def</code> - definitions of particular <code>-mcpu=&lt;core&gt;</code> targets.</li> </ul>"},{"location":"general/target-options/#multiplication-options-for-arc-em-hs3x-and-hs4x-families","title":"Multiplication Options for ARC EM, HS3x and HS4x Families","text":"<p>Here is a table which matches <code>-mmpy-option=</code> values to corresponding features for ARC EM and ARC HS as they defined in ARChitect.</p> <code>-mmpy-option=</code> Aliases ARChitect option for ARC HS ARChitect option for ARC EM 0 <code>none</code> <code>-mpy_option=none</code> <code>-mpy_option=none</code> 1 <code>w</code> \u2014 \u2014 2 <code>wlh1</code>, <code>mpy</code> <code>-mpy_option=mpy</code> <code>-mpy_option=wlh1</code> 3 <code>wlh2</code> \u2014 <code>-mpy_option=wlh2</code> 4 <code>wlh3</code> \u2014 <code>-mpy_option=wlh3</code> 5 <code>wlh4</code> \u2014 <code>-mpy_option=wlh4</code> 6 <code>wlh5</code> \u2014 <code>-mpy_option=wlh5</code> 7 <code>plus_dmpy</code> <code>-mpy_option=plus_dmpy</code> \u2014 8 <code>plus_macd</code> <code>-mpy_option=plus_macd</code> \u2014 9 <code>plus_qmacw</code> <code>-mpy_option=plus_qmacw</code> \u2014"},{"location":"general/target-options/#floating-point-options-for-arc-em-hs3x-and-hs4x-families","title":"Floating Point Options for ARC EM, HS3x and HS4x Families","text":"<p>Here is a table which matches <code>-mfpu=</code> values to corresponding features for ARC EM and ARC HS as they defined in ARChitect.</p> <code>-mfpu=</code> Families <code>-has_fpu</code> <code>-fpu_dp_option</code> <code>-fpu_div_option</code> <code>-fpu_fma_option</code> <code>-fpu_dp_assist</code> <code>fpus</code> EM, HS On \u2014 \u2014 \u2014 \u2014 <code>fpus_div</code> EM, HS On \u2014 On \u2014 \u2014 <code>fpus_fma</code> EM, HS On \u2014 \u2014 On \u2014 <code>fpus_all</code> EM, HS On \u2014 On On \u2014 <code>fpud</code> HS On On \u2014 \u2014 \u2014 <code>fpud_div</code> HS On On On \u2014 \u2014 <code>fpud_fma</code> HS On On \u2014 On \u2014 <code>fpud_all</code> HS On On On On \u2014 <code>fpuda</code> EM On \u2014 \u2014 \u2014 On <code>fpuda_div</code> EM On \u2014 On \u2014 On <code>fpuda_fma</code> EM On \u2014 \u2014 On On <code>fpuda_all</code> EM On \u2014 On On On"},{"location":"general/target-options/#values-of-mcpu-for-arc-hs3x-and-hs4x-families","title":"Values of <code>-mcpu</code> for ARC HS3x and HS4x Families","text":"<code>-mcpu=</code> <code>-mdiv-rem</code> <code>-matomic</code> <code>-mll64</code> <code>-mmpy-option=</code> <code>-mfpu=</code> <code>hs</code> Y <code>hs34</code> Y <code>mpy</code> <code>archs</code> Y Y Y <code>mpy</code> <code>hs38</code> Y Y Y <code>plus_qmacw</code> <code>hs4x</code> Y Y Y <code>plus_qmacw</code> <code>hs4xd</code> Y Y Y <code>plus_qmacw</code> <code>hs38_linux</code> Y Y Y <code>plus_qmacw</code> <code>fpud_all</code> <p>The above <code>-mcpu</code> values correspond to specific ARC EM Processor templates presented in the ARChitect tool.</p> <ul> <li><code>-mcpu=hs</code> corresponds to a basic ARC HS with only atomic instructions enabled. It corresponds to the following ARC HS templates in ARChitect: <code>hs34_base</code>, <code>hs36_base</code> and <code>hs38_base</code>.</li> <li><code>-mcpu=hs34</code> is like <code>hs</code> but with with additional support for standard hardware multiplier. It corresponds to the following ARC HS templates in ARChitect: <code>hs34</code>, <code>hs36</code> and <code>hs38</code>.</li> <li><code>-mcpu=archs</code> is a generic configuration, which corresponds to the default configuration in older GNU toolchain versions.</li> <li><code>-mcpu=hs38</code> is a full-featured ARC HS. It corresponds to the following ARC HS template in ARChitect: <code>hs38_full</code>.</li> <li><code>-mcpu=hs4x</code> and <code>-mcpu=hs4xd</code> have the same option set as <code>-mcpu=hs38</code>, but compiler will optimize instruction scheduling for specified processors.</li> <li><code>-mcpu=hs38_linux</code> is a full-featured ARC HS with additional support of double-precision FPU.</li> </ul>"},{"location":"general/target-options/#values-of-mcpu-for-arc-em-family","title":"Values of <code>-mcpu</code> for ARC EM Family","text":"<code>-mcpu</code> <code>-mcode-density</code> <code>-mnorm</code> <code>-mswap</code> <code>-mbarrel-shifter</code> <code>-mdiv-rem</code> <code>-mmpy-option=</code> <code>-mfpu=</code> <code>-mrf16</code> <code>-mspfp</code> <code>-mdpfp</code> <code>em</code> <code>em_mini</code> Y <code>em4</code> Y <code>arcem</code> Y Y <code>wlh1</code> <code>em4_dmips</code> Y Y Y Y Y <code>wlh1</code> <code>em4_fpus</code> Y Y Y Y Y <code>wlh1</code> <code>fpus</code> <code>em4_fpuda</code> Y Y Y Y Y <code>wlh1</code> <code>fpuda</code> <code>quarkse_em</code> Y Y Y Y Y <code>wlh2</code> <code>quark</code> Y Y <p>The above <code>-mcpu</code> values correspond to specific ARC EM Processor templates presented in the ARChitect tool. It should be noted however that some ARC features are not currently supported in the GNU toolchain, for example DSP instruction support.</p> <ul> <li><code>-mcpu=em</code> doesn't correspond to any specific template, it simply defines the base ARC EM configuration without any optional instructions.</li> <li><code>-mcpu=em_mini</code> is same as <code>em</code>, but uses reduced register file with only 16 core registers.</li> <li><code>-mcpu=em4</code> is a base ARC EM core configuration with <code>-mcode-density</code> option. It corresponds to the following ARC EM templates in ARChitect: <code>em4_mini</code>, <code>em4_sensor</code>, <code>em4_ecc</code>, <code>em6_mini</code>, <code>em5d_mini</code>, <code>em5d_mini_v3</code>, <code>em5d_nrg</code>, <code>em7d_nrg</code>, <code>em9d_mini</code>. Note that those mini templates have a reduced core register file, but <code>-mcpu=em4</code> doesn't enable this feature.</li> <li><code>-mcpu=arcem</code> doesn't correspond to any specific template, it is a legacy flag preserved for compatibility with older GNU toolchain versions, where <code>-mcpu</code> used to select only a CPU family, while optional features were enabled or disabled by individual <code>-m&lt;something&gt;</code> options.</li> <li><code>-mcpu=em4_dmips</code> is a full-featured ARC EM configuration for integer operations. It corresponds to the following ARC EM templates in ARChitect: <code>em4_dmips</code>, <code>em4_rtos</code>, <code>em6_dmips</code>, <code>em4_dmips_v3</code>, <code>em4_parity</code>, <code>em6_dmips_v3</code>, <code>em6_gp</code>, <code>em5d_voice_audio</code>, <code>em5d_nrg_v3</code>, <code>em7d_nrg_v3</code>, <code>em7d_voice_audio</code>, <code>em9d_nrg</code>, <code>em9d_voice_audio</code>, <code>em11d_nrg</code> and <code>em11d_voice_audio</code>.</li> <li><code>-mcpu=em4_fpus</code> is like <code>em4_dmips</code> but with additional support for single-precision floating point unit. It corresponds to the following ARC EM templates in ARChitect: <code>em4_dmips_fpusp</code>, <code>em4_dmips_fpusp_v3</code>, <code>em5d_nrg_fpusp</code> and <code>em9d_nrg_fpusp</code>.</li> <li><code>-mcpu=em4_fpuda</code> is like <code>em4_fpus</code> but with additional support for double-precision assist instructions. It corresponds to the following ARC EM templates in ARChitect: <code>em4_dmips_fpuspdp</code> and <code>em4_dmips_fpuspdp_v3</code>.</li> <li><code>-mcpu=quarkse_em</code> is a configuration for ARC processor in Intel Quark SE chip. It enables additional floating point instructions which cannot be enable using a particular target option.</li> </ul>"},{"location":"general/target-options/#values-of-mcpu-for-arc-600-and-700-families","title":"Values of <code>-mcpu</code> for ARC 600 and 700 Families","text":"<code>-mcpu=</code> <code>-mnorm</code> <code>-mswap</code> <code>-mbarrel-shifter</code> Multiplier <code>arc700</code> Y Y Y <code>-mmpy</code> <code>arc600</code> Y <code>arc600_norm</code> Y Y <code>arc600_mul64</code> Y Y <code>-mmul64</code> <code>arc600_mul32x16</code> Y Y <code>-mmul32x16</code> <code>arc601</code> <code>arc601_norm</code> Y <code>arc601_mul64</code> Y <code>-mmul64</code> <code>arc601_mul32x16</code> Y <code>-mmul32x16</code>"},{"location":"general/target-options/#controlling-the-memory-model","title":"Controlling the Memory Model","text":"<code>-mcmodel</code> Memory size for Data/Code <code>small</code> 1MB region <code>medium</code> 4GB region (used by <code>-fpic</code>) <code>large</code> Full memory (used by <code>-fPIC</code>)"},{"location":"general/target-options/#other-tweaking-options","title":"Other Tweaking Options","text":"Option Description <code>-mfpmov</code> Reduces the pressure on GPRs by using FPRs for inline memory operations. <code>-mbrcc</code> Generate BRcc instructions early on. <code>-mbbit</code> Likewise but for BBITx instructions."},{"location":"general/target-options/#arcv3-toolchain","title":"ARCv3 Toolchain","text":""},{"location":"general/target-options/#values-of-mcpu-for-arc-hs5x-and-arc-hs6x-families","title":"Values of <code>-mcpu</code> for ARC HS5x and ARC HS6x Families","text":"<code>-mcpu=</code> <code>-msimd</code> <code>-m128</code> <code>-mll64</code> <code>hs5x</code> Y N/A <code>hs58</code> Y N/A Y <code>hs6x</code> Y N/A <code>hs68</code> Y Y N/A"},{"location":"general/toolchains/","title":"Toolchains for ARC Processors","text":""},{"location":"general/toolchains/#toolchains-for-baremetal-targets","title":"Toolchains for Baremetal Targets","text":"<p>GNU toolchains for ARC processors consist of GCC, Binutils and GDB. Newlib standard library is used for building baremetal applications. This table depicts which GCC driver should be used depending on ISA:</p> ISA Driver/Triplet ARCv1 <code>arc-elf32-gcc</code> ARCv2 <code>arc-elf32-gcc</code> ARCv3 <code>arc64-elf-gcc</code> <p>Note that binaries for both ARCv1 and ARCv2 may be built using a single <code>arc-elf32-gcc</code> driver. It means that there is a single toolchain for two ISAs.</p>"},{"location":"general/toolchains/#toolchains-for-linux-targets","title":"Toolchains for Linux Targets","text":"<p>There is a set of GNU toolchains for ARC processors which allow to build and debug applications for Linux. The Linux kernel itself for ARC processors may be built using both baremetal and Linux toolchains.</p> <p>Linux toolchains are presented for all ARC processor families except ARC EM and ARC 600. Two Linux standard libraries are currently supported: glibc and uClibc-ng. This table depicts which GCC driver should be used depending on CPU family:</p> Family Standard library Driver/Triplet ARC 700 glibc <code>arc-linux-gnu-gcc</code> ARC 700 uClibc-ng <code>arc-linux-uclibc-gcc</code> ARC HS3x/4x/4xD glibc <code>arc-linux-gnu-gcc</code> ARC HS3x/4x/4xD uClibc-ng <code>arc-linux-uclibc-gcc</code> ARC HS5x uClibc-ng <code>arc32-linux-uclibc-gcc</code> ARC HS6x glibc <code>arc64-linux-gnu-gcc</code> <p>Note, that in case of Linux toolchains, <code>arc-linux-*</code> drivers for ARC 700 and ARC HS are different toolchains! For example, if you want to build applications for ARC 700 Linux targets, then you need to use a particular toolchain for ARC 700 and the same is applicable for ARC HS, though they have the same names.</p>"},{"location":"general/toolchains/#how-to-get-the-toolchain","title":"How to Get The Toolchain","text":"<p>There are several ways of getting the toolchain:</p> <ol> <li>Download the latest release of the prebuilt toolchain on the release page    of main toolchain's repository. Also, Eclipse IDE    is available for downloading which is shipped with some of toolchains and OpenOCD.</li> <li>You can build toolchains using Crosstool-NG build system. Follow instructions presented in    <code>README.md</code> of main toolchain's repository    on GitHub.</li> <li>You can build some of toolchains using scripts from arc-gnu-toolchain    repository. These scripts are based on the RISC-V scripts.</li> </ol>"},{"location":"platforms/","title":"Development Platforms","text":"<p>Warning</p> <p>This section is under construction.</p>"},{"location":"platforms/digilent/","title":"Installing Digilent Adept","text":"<p>OpenOCD does not use Digilent drivers to communicate with Digilent debug cables. It uses it's own implementation of FTDI MPSSE protocol, which is compatible with FTDI x232 cable. However, you might need to install Digilent Adept drivers and utilities to use some features of Digilent cables.</p> <p>Download an appropriate version of runtime and utilities from Digilent Adept download page. There several options:</p> <ul> <li>Adept for Windows System \u2014 utilities and runtime in a single installer for Windows.</li> <li>Adept for Linux Runtime \u2014 runtime for Linux. <code>rpm</code> and <code>dep</code> packages   are available, as well as a generic <code>.tar.gz</code> archive.</li> <li>Adept Utilities \u2014 utilities for Linux. <code>rpm</code> and <code>dep</code> packages   are available, as well as a generic <code>.tar.gz</code> archive.</li> </ul> <p>You can check, that utilities and runtime are installed correctly using <code>djtgcfg</code> utility:</p> <pre><code>$ djtgcfg enum\n    Found 1 device(s)\n\n    Device: JtagHs2\n        Product Name:   Digilent JTAG-HS2\n        User Name:      JtagHs2\n        Serial Number:  210249810909\n</code></pre>"},{"location":"platforms/get-openocd/","title":"Getting OpenOCD","text":"<p>Warning</p> <p>This section is under construction.</p>"},{"location":"platforms/get-openocd/#important-notes","title":"Important Notes","text":"<ol> <li>This document uses term \"Digilent HS\" to refer to both HS1 and HS2 cables.    Statements, which are applicable only to the selected cable, mention it explicitly.    Digilent HS3 hasn't been tested with OpenOCD for ARC.</li> <li>There is NO Flash support in ARC OpenOCD.</li> </ol>"},{"location":"platforms/get-openocd/#building-openocd-for-linux","title":"Building OpenOCD for Linux","text":"<p>Install prerequisites for Ubuntu:</p> <pre><code>$ sudo apt-get install libtool git-core build-essential autoconf \\\nautomake texinfo libusb-1.0-0 libusb-1.0-0-dev \\\npkg-config\n</code></pre> <p>Install prerequisites for RHEL/CentOS 7:</p> <pre><code>$ sudo yum install libtool gcc autoconf automake texinfo libusb1 libusb1-devel \\\ngit make which\n</code></pre> <p>Download OpenOCD sources and checkout the latest release:</p> <pre><code>git clone -b arc-2021.09 https://github.com/foss-for-synopsys-dwc-arc-processors/openocd\ncd openocd\n</code></pre> <p>Configure OpenOCD (use your own <code>--prefix</code> path):</p> <pre><code>$ ./bootstrap\n$ ./configure --enable-ftdi --disable-werror \\\n--disable-doxygen-html --prefix=/tools/openocd\n</code></pre> <p>Also, you can pass <code>--enable-verbose</code> and <code>--enable-verbose-jtag-io</code> options for development activities.</p> <p>Build and install:</p> <pre><code>$ make\n$ make install\n</code></pre> <p>Configure your environment (use your own installation path):</p> <pre><code>export PATH=/tools/openocd/bin:$PATH\n</code></pre> <p>Finally you need to configure udev rules in such way that OpenOCD would be able to claim your JTAG debug cable. In common case for ARC this is an FTDI-based device. If you already have libftdi package installed on your system, then required rules are already provided to udev. Otherwise create file <code>/etc/udev/rules.d/99-ftdi.rules</code> with the following contents:</p> <pre><code># allow users to claim the device\n# Digilent HS1 and similiar products\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6010\", MODE=\"0664\", GROUP=\"plugdev\"\n# Digilent HS2\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6014\", MODE=\"0664\", GROUP=\"plugdev\"\n</code></pre> <p>You also can use file <code>contrib/99-openocd.udev</code> supplied with OpenOCD sources, however this file doesn't work with Digilent HS2, though on the other hand it mentions many other FTDI-based devices.</p> <p>Then either reboot your system or reload udev configuration and reconnect debug cable to the host computer:</p> <pre><code>$ sudo udevadm control --reload-rules\n# Disconnect JTAG cable from host, then connect again.\n</code></pre>"},{"location":"platforms/get-openocd/#building-openocd-for-windows","title":"Building OpenOCD for Windows","text":"<p>It is possible to use OpenOCD on Windows with FTDI-based debug cables using a <code>ftdi</code> interface and libusb driver (further down called ftdi/libusb). Note, however that this requires replacing the original FTDI proprietary drivers with open source ones. This will render Digilent cable unusable by Digilent tools, like Adept.</p> <p>Install the same prerequisites like for Linux build (except for libusb-dev) and MinGW on your system:</p> <pre><code>$ sudo apt-get install libtool git-core build-essential autoconf automake \\\ntexinfo pkg-config\n</code></pre> <p>Install MinGW cross-compiler to your system:</p> <pre><code>$ sudo apt-get install gcc-mingw-w64\n</code></pre> <p>Download libusb sources sources. Configure and build them with MinGW compiler. It is recommended to build only static libusb, so that OpenOCD will not need this library's dll file to be copied around:</p> <pre><code>$ tar xaf libusb-1.0.20.tar.bz2\n$ cd libusb-1.0.20\n$ ./configure --host=i686-w64-mingw32 --build=x86_64-linux-gnu \\\n--prefix=&lt;/libusbx/install/path&gt; --disable-shared --enable-static\n$ make\n$ make install\n</code></pre> <p>Download OpenOCD sources:</p> <pre><code>$ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/openocd\n$ cd openocd\n$ ./bootstrap\n</code></pre> <p>Configure OpenOCD. Consult <code>configure --help</code> and generic OpenOCD documentation for details. This command line is recommended for ARC with libusb/ftdi:</p> <pre><code>$ PKG_CONFIG_PATH=&lt;/libusb/install/path&gt;/lib/pkgconfig ./configure \\\n  --enable-ftdi --host=i686-w64-mingw32 --build=x86_64-linux-gnu \\\n  --disable-werror --prefix=&lt;openocd/install/path&gt;\n</code></pre> <p>Note that it is required to set PKG_CONFIG_PATH, otherwise configure script will detect host libusb installation, instead of the one cross-compiled for Windows.</p> <p>Build and install:</p> <pre><code>$ make\n$ make install\n</code></pre> <p>If your application uses libusb and is being linked dynamically (this is by default), copy /bin/libusb-1.0.dll to the OpenOCD bin directory. Copy OpenOCD installation to Window host.</p>"},{"location":"platforms/get-openocd/#running-internal-testsuite","title":"Running internal testsuite","text":"<p>There is a set of internal test for ARC and OpenOCD (consisting of just a single test at the moment of this writing, though...). This testsuite aim is to catch some issues with OpenOCD, JTAG or hardware. To run test suite: source <code>tcl/test/arc.cfg</code> then run arc_test_run_all procedure, or run tests individually.</p>"},{"location":"platforms/reset/","title":"Resetting Boards","text":""},{"location":"platforms/reset/#using-rff-reset","title":"Using <code>rff-reset</code>","text":"<p>You can use the <code>rff-reset</code> utility to reset ARC development boards. Follow instructions in the <code>rff-rtdi-reset</code> repository to install and use the utility.</p> <p>Here is an example for a case when only one board is connected to the host:</p> <pre><code># rff-reset --only-one\n</code></pre> <p>Here is an example for a case when it's necessary to reset a particular board (Digilent Adept utility is used to obtain a serial number):</p> <pre><code># djtgcfg enum\nFound 1 device(s)\n\nDevice: HSDK-4xD\n    Device Transport Type: 00020001 (USB)\n    Product Name:          DesignWare ARC SDP\n    User Name:             HSDK-4xD\n    Serial Number:         251642000213\n\n# rff-reset --serial 251642000213\n</code></pre>"},{"location":"platforms/reset/#using-openocd","title":"Using OpenOCD","text":"<p>It is possible to reset ARC SDP board without touching the physical button on the board. This can be done using an OpenOCD script:</p> <pre><code>$ openocd -f test/arc/reset_sdp.tcl\n</code></pre> <p>Note that OpenOCD will crash with a segmentation fault after executing this script - this is expected and happens only after board has been reset, but that means that other OpenOCD scripts cannot be used in chain with <code>reset_sdp.tcl</code>, first OpenOCD should be invoked to reset the board, second it should be invoked to run as an actual debugger.</p>"},{"location":"platforms/use-openocd/","title":"Using OpenOCD","text":"<p>Warning</p> <p>This section is under construction.</p>"},{"location":"platforms/use-openocd/#configuration-files","title":"Configuration Files","text":"Board OpenOCD configuration EMSK 1 <code>snps_em_sk_v1.cfg</code> EMSK 2.0 <code>snps_em_sk_v2.1.cfg</code> EMSK 2.1 <code>snps_em_sk_v2.1.cfg</code> EMSK 2.2 <code>snps_em_sk_v2.2.cfg</code> EMSK 2.3 <code>snps_em_sk_v2.3.cfg</code> HSDK <code>snps_hsdk.cfg</code> HSDK 4x/4xD <code>snps_hsdk_4xd.cfg</code> IoTDK <code>snps_iotdk.cfg</code>"},{"location":"platforms/use-openocd/#running-openocd-server","title":"Running OpenOCD Server","text":"<p>OpenOCD is used for starting a GDB server for connecting to a board. Suppose, that EM Starter Kit 2.3 is used. If you\u2019ve downloaded IDE bundle for Linux then you can run OpenOCD this way (replace <code>&lt;ide&gt;</code> by a path to the directory of IDE bundle):</p> <pre><code>$ &lt;ide&gt;/bin/openocd -s &lt;ide&gt;/share/openocd/scripts -c 'gdb_port 49101' -f board/snps_em_sk_v2.3.cfg\n</code></pre> <p>If you\u2019ve built and installed OpenOCD manually then you can run OpenOCD this way:</p> <pre><code>$ openocd  -c 'gdb_port 49101' -f board/snps_em_sk_v2.2.cfg\n</code></pre> <p>If you\u2019ve downloaded and installed IDE bundle for Windows then you can run OpenOCD this way:</p> <pre><code>$ openocd -s C:\\arc_gnu\\share\\openocd\\scripts -c \"gdb_port 49101\" -f board\\snps_em_sk_v2.3.cfg\n</code></pre>"},{"location":"platforms/use-openocd/#how-to-use-openocd-on-linux","title":"How to use OpenOCD on Linux","text":"<p>Connection host is a host that is connected to the debug target via USB cable and runs OpenOCD. Debug host is a hsot that runs GDB, which connects to the OpenOCD with TCP connection. Ehily typically it is the same host, they actually can be different host and it is important to distinguish them.</p> <p>Connect debug target to the connection host. AXS10x products and EM Starter Kit have built-in debug cable, the don't require a separate Digilent HS cable. HS is required only for other debug targets like ML-509 board, etc.</p> <p>Run lsusb application to ensure that FTDI device is there:</p> <pre><code>$ lsusb\n</code></pre> <p>In case of HS1, EM Starter Kit and AXS10x there should line like this:</p> <pre><code>Bus 001 Device 002: ID 0403:6010 Future Technology Devices International, Ltd FT2232C Dual USB-UART/FIFO IC\n</code></pre> <p>In case if HS2 there should be line like this:</p> <pre><code>Bus 001 Device 003: ID 0403:6014 Future Technology Devices International, Ltd FT232H Single HS USB-UART/FIFO IC\n</code></pre> <p>Note that exact lines could differ from host to host.</p> <p>Run OpenOCD:</p> <pre><code>$ openocd -f &lt;openocd.cfg&gt;\n</code></pre> <p>Valid openocd.cfg files are installed into <code>/usr/local/share/openocd/scripts/board/</code>:</p> <ul> <li>snps_em_sk_v2.3.cfg - ARC EM Starter Kit verison 2.3</li> <li>snps_axs101.cfg - ARC AXS101 Software Development platform</li> <li>snps_axs103_hs36.cfg - ARC AXS103 in configuration with ARC HS36 core</li> <li>snps_hsdk.cfg - ARC HSDK</li> </ul> <p>On the debug host (PC with GDB) start an ELF32 GDB debugger:</p> <pre><code>$ arc-elf32-gdb ./&lt;elf_app_to_debug&gt;\n</code></pre> <p>Make the connection between arc-elf32-gdb and OpenOCD:</p> <pre><code>(gdb) target remote &lt;connection host ip address&gt;:3333\n</code></pre> <p>Load image to be debugged (./.elf) into the target memory: <pre><code>(gdb) load\n</code></pre> <p>Set breakpoints at functions main and exit:</p> <pre><code>(gdb) break main\n(gdb) break exit\n</code></pre> <p>Start the execution on target of the image to debug, to reach function main:</p> <p>(gdb) continue</p> <p>Resume execution to reach function exit:</p> <p>(gdb) continue</p>"},{"location":"platforms/use-openocd/#how-to-use-openocd-on-windows","title":"How to use OpenOCD on Windows","text":"<p>WinUSB driver should be used to allow OpenOCD to connect to debug cable and that driver would replace FTDI proprietary drivers for Digilent cables or EM Starter Kit with it.  Refer to this page or this page for details. In a nutshell, download Zadig, run it and use it to install WinUSB driver for FTDI device. If FTDI device is not shown by Zadig, then tick \"List all devices\" in \"Options\". Note that antivirus might complain about driver files created by Zadig. After installing the driver everything is the same as on Linux: run OpenOCD, connect to it with GDB, etc.</p>"},{"location":"platforms/use-openocd/#how-to-use-openocd-on-macos","title":"How to use OpenOCD on macOS","text":"<p>Connection host is a host that is connected to the debug target via USB cable and runs OpenOCD. Debug host is a hsot that runs GDB, which connects to the OpenOCD with TCP connection. Ehily typically it is the same host, they actually can be different host and it is important to distinguish them.</p> <p>Connect debug target to the connection host. AXS10x products and EM Starter Kit have built-in debug cable, the don't require a separate Digilent HS cable. HS is required only for other debug targets like ML-509 board, etc.</p> <p>Run ioreg application to ensure that FTDI device is there:</p> <pre><code>$ ioreg -p IOUSB -l -w 0\n</code></pre> <p>There should be output like this:     Digilent USB Device@14100000       {       ...     } <p>Note that exact output could differ from host to host.</p> <p>If you're using a USB adapter and have a driver kext matched to it, you will need to unload it prior to running OpenOCD. E.g. with Apple driver (OS X 10.9 or later) for FTDI run:   sudo kextunload -b com.apple.driver.AppleUSBFTDI for FTDI vendor driver use:   sudo kextunload FTDIUSBSerialDriver.kext</p> <p>Run OpenOCD:</p> <p>See for tag Run OpenOCD at How to use OpenOCD on Linux.</p>"},{"location":"platforms/use-openocd/#advanced-debug-commands","title":"Advanced debug commands","text":"<p>With the GDB \"monitor\" command, you have \"direct\" access to the core without any interference from GDB anymore! With other words, GDB has no notion of changes in core state when using the so called  monitor commands (but it is very powerful). In GDB, connect to the OpenOCD target and type following command to get a list of available monitor commands:</p> <pre><code>(gdb) monitor help\n</code></pre> <p>To get a list of some ARC-specific commands, run:</p> <pre><code>(gdb) monitor help arc\n</code></pre> <p>Those are actually internal OpenOCD commands which are also available in configuration scripts and can be passed in OpeOCD command line with <code>-c ...</code> options. Those command allow to enabled some extra features of OpenOCD (disabled by default for one or another reason) or perform some low-level actions bypassing GDB or even OpenOCD. For example it is possible to write/read core and aux registers. However some command for register access will be removed in future, when ARC OpenOCD will fully support flexible register configurations.</p>"},{"location":"platforms/winusb/","title":"Installing WinUSB on Windows","text":"<p>Warning</p> <p>After replacing an original FTDI driver by WinUSB, you cannot use MetaWare Debugger or Digilent Adept utilities with ARC devices.</p>"},{"location":"platforms/winusb/#replacing-ftdi-driver","title":"Replacing FTDI Driver","text":"<p>Before you can start using OpenOCD on Windows, you have to download WinUSB driver and replace with it one of FTDI drivers for your hardware development system. To do that, download Zadig and run it. You should be able to see Digilent Adept USB Device in the list of devices.</p> <p></p> <p>If your device is not shown by Zadig, then click on List all devices in Options.</p> <p>For EM Starter Kit, select Digilent Adept USB Device (Interface 0), choose WinUSB driver and press Replace Driver. Your FTDI driver will be replaced with WinUSB.</p> <p></p> <p>For HS Development Kit, IoT Development Kit, EM SDP and AXS10x SDP, the only thing that differs is that instead of Digilent Adept USB Device (Interface 0) you should select Digilent Adept USB Device (Interface 1).</p> <p>Note that antivirus might complain about drivers files created by Zadig.</p>"},{"location":"platforms/winusb/#restoring-an-original-driver","title":"Restoring an Original Driver","text":"<p>If you want to change driver for your device back for some reason, you can uninstall current driver in \u201cDevices and Printers\u201d and then reconnect your board to the computer, Windows will install the default driver automatically.</p>"},{"location":"simulators/nsim/","title":"nSIM","text":""},{"location":"simulators/nsim/#running-applications","title":"Running Applications","text":"<ul> <li>Building Baremetal Applications and Debugging on nSIM</li> <li>Building Linux and Running on nSIM</li> </ul>"},{"location":"simulators/nsim/#profiling-and-ncam","title":"Profiling and nCAM","text":"<p>You can run nSIM in NCAM mode - Near Cycle-Accurate Mode. This mode activates counters that depend on micro-architectural simulations. It may be a good tool for optimization and exploration. NCAM's model is not cycle-accurate and it's not derived from RTL, but it's much faster than xCAM. If you need a cycle-accurate model then consider using xCAM models.</p> <p>Use <code>-on cycles</code> to enable NCAM:</p> <pre><code>$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on cycles main.elf\n</code></pre> <p>Use <code>-on nsim_print_stats_on_exit</code> and <code>-on ncam_profiling</code> (this option enables more profiling counters) options to print simulation statistics at the end of a simulation:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=hl.specs main.c -o main.elf\n$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on cycles -on ncam_profiling \\\n          -on nsim_print_stats_on_exit main.elf\n&lt;Main_Memory&gt;\n-------------------------------------------------------------------\n Main Memory          |            Frequency|                    %\n Read                 |                   86|                54.09\n Write                |                   73|                45.91\n-------------------------------------------------------------------\n Total                |                  159|               100.00\n&lt;/Main_Memory&gt;\n&lt;L1-I-CACHE&gt;\n-------------------------------------------------------------------\n L1-I-CACHE           |            Frequency|                    %\n-------------------------------------------------------------------\n Read Hits            |                  770|                94.48\n Read Misses          |                   45|                 5.52\n-------------------------------------------------------------------\n Total                |                  815|               100.00\n&lt;/L1-I-CACHE&gt;\n&lt;L1-D-CACHE&gt;\n-------------------------------------------------------------------\n L1-D-CACHE           |            Frequency|                    %\n-------------------------------------------------------------------\n RW Misses            |                   17|                 4.47\n RW Hits              |                  363|                95.53\n Read Hits            |                   89|                23.42\n Read Misses          |                    1|                 0.26\n Write Hits           |                  274|                94.48\n Write Misses         |                   16|                 4.21\n Dirty Misses         |                    0|                 0.00\n-------------------------------------------------------------------\n Span Lines           |                    2|                 0.53\n Double Miss          |                    0|                 0.00\n-------------------------------------------------------------------\n Total                |                  380|               100.00\n&lt;/L1-D-CACHE&gt;\n&lt;Statistics-Branch_Predictor_FB-GShare&gt;\n Description: FB-GShare Branch Predictor Statistics\n-------------------------------------------------------------------\n BPU (Two-Level)      |            Frequency|                    %\n-------------------------------------------------------------------\n Correctly Predicted  |                  327|                76.05\n Miss Predicted       |                  103|                23.95\n Conditional Misses   |                   26|                25.24\n Uconditional Misses  |                   77|                74.76\n-------------------------------------------------------------------\n Total                |                  430|               100.00\n&lt;/Statistics-Branch_Predictor_FB-GShare&gt;\n\n&lt;Histogram-Instructions&gt;\n-------------------------------------------------------------------\n Instruction          |            Frequency|                    %\n-------------------------------------------------------------------\n stw                  |                  302|                25.44\n nop                  |                  197|                16.60\n mov                  |                  128|                10.78\n...\n neg                  |                    1|                 0.08\n div                  |                    1|                 0.08\n-------------------------------------------------------------------\n Delay Slot           |                   55|                 4.63\n-------------------------------------------------------------------\n Total                |                 1187|               100.00\n&lt;/Histogram-Instructions&gt;\n&lt;Summary-Execution_Profile&gt;\n-------------------------------------------------------------------\n Execution Profile    |            Frequency|                    %\n-------------------------------------------------------------------\n Interpreted Inst     |                 1187|               100.00\n Cond Branches        |                  102|                 8.59\n Cond Branch Mispred  |                   26|                 2.19\n Ucond Branches       |                  121|                10.19\n Ucond Branch Mispred |                   77|                 6.49\n-------------------------------------------------------------------\n Total                |                 1187|               100.00\n&lt;/Summary-Execution_Profile&gt;\n&lt;Summary-Simulation_Time&gt;\n-------------------------------------------------------------------\n Simulation Time      |              Seconds|                    %\n-------------------------------------------------------------------\n Simulation           |               0.0032|                99.72\n Hostlink             |               0.0000|                 0.28\n-------------------------------------------------------------------\n Total                |               0.0032|               100.00\n&lt;/Summary-Simulation_Time&gt;\n&lt;Summary-Simulation_Performance&gt;\n Instruction Count =   1187 [# Total]\n Simulation  Time  =   0.00 [Seconds]\n Simulation  Rate  =   0.38 [MIPS]\n Cycle Count       =   2766 [Cycles]\n CPI               =    2.330\n IPC               =    0.429\n Effective Clock   =   0.9 [MHz]\n&lt;/Summary-Simulation_Performance&gt;\n</code></pre> <p>Use <code>-on nsim_trace</code> and <code>-p nsim_trace-output=trace.txt</code> options to trace instructions (omit <code>nsim_trace-output</code> if you want to print trace log right into <code>stdout</code>):</p> <pre><code>$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on nsim_trace \\\n          -p nsim_trace-output=trace.txt main.elf\n$ head trace.txt\n\n                nSIM, Version: 2023.03 (Build: 002)\n\n[0x00000124] 0x226a0280                 K       lr             r2,[0xa] : (w0) r2 &lt;= 0x00000000: aux[0x0a] =&gt; 0x00 *\n[0x00000128] 0x224f04c2                 K       bset           r2,r2,0x13 : (w0) r2 &lt;= 0x00080000 *\n[0x0000012c] 0x20290080                 K       flag           r2 *\n[0x00000130] 0x26ab740a 0x00000122   AD K       sr             00000122,0x290: aux[0x290] &lt;= 0x122 *\n[0x00000138] 0x220a3f80 0x00005c10   AD K       mov            gp,00005c10 : (w0) r26 &lt;= 0x00005c10 *\n[0x00000140] 0x42c3     0x00005b20   AD K       mov_s          r2,00005b20 : (w0) r2 &lt;= 0x00005b20 *\n[0x00000146] 0x26027083 0x00005e34   AD K       sub            r3,00005e34,r2 : (w0) r3 &lt;= 0x00000314 *\n</code></pre>"},{"location":"simulators/qemu/","title":"QEMU","text":""},{"location":"simulators/qemu/#running-applications","title":"Running Applications","text":"<ul> <li>Building Baremetal Applications and Debugging on QEMU</li> <li>Building Linux and Running on QEMU</li> </ul>"},{"location":"simulators/qemu/#building-qemu","title":"Building QEMU","text":"<p>Additional packages and plugins</p> <p>Refer to the official documentation for details about installing additional packages and enabling support of QEMU plugins.</p> <p>Install necessary packages for Arch:</p> <pre><code>sudo pacman -S git cmake ninja gperf ccache dfu-util dtc wget            \\\npython-pip python-setuptools python-wheel xz file make\n</code></pre> <p>Install necessary packages for Fedora:</p> <pre><code>sudo dnf group install \"Development Tools\" \"C Development Tools and Libraries\"\ndnf install git cmake ninja-build gperf ccache dfu-util dtc wget         \\\npython3-pip xz file glibc-devel.i686 libstdc++-devel.i686\n</code></pre> <p>Install necessary packages for Ubuntu:</p> <pre><code>sudo apt-get install --no-install-recommends git cmake ninja-build gperf \\\nccache dfu-util device-tree-compiler wget           \\\npython3-pip python3-setuptools python3-wheel        \\\nxz-utils file make gcc gcc-multilib\n</code></pre> <p>Install necessary packages for Void:</p> <pre><code>sudo xbps-install git cmake ninja gperf ccache dfu-util dtc wget  \\\npython3-pip python3-setuptools python3-wheel xz \\\nfile make\n</code></pre> <p>Then prepare sources and a build directory:</p> <pre><code>git clone https://github.com/foss-for-synopsys-dwc-arc-processors/qemu\nmkdir -p qemu/build\ncd qemu/build\n</code></pre> <p>Configure QEMU inside of the build directory (use your own <code>--prefix</code> value for installation path):</p> <pre><code>../configure --target-list=arc-softmmu,arc64-softmmu,arc-linux-user,arc64-linux-user \\\n             --prefix=/tools/qemu --enable-debug --enable-debug-tcg --enable-trace-backends=simple \\\n             --disable-plugins --skip-meson --disable-werror --disable-pie\n</code></pre> <p>What options are responsible for what:</p> <ul> <li><code>--target-list=arc-softmmu,arc64-softmmu,arc-linux-user,arc64-linux-user</code> \u2014 build QEMU both for these targets:</li> <li><code>qemu-system-arc</code> \u2014 system emulation for ARC HS3x/4x/5x processors family;</li> <li><code>qemu-system-arc64</code> \u2014 system emulation for ARC HS6x processors family;</li> <li><code>qemu-arc</code> \u2014 user space Linux emulation for ARC HS3x/4x/5x processors family;</li> <li><code>qemu-arc64</code> \u2014 user space Linux emulation for ARC HS6x processors family.</li> <li><code>--prefix=/tools/qemu</code> \u2014 an installation path.</li> <li><code>--enable-debug --enable-debug-tcg --enable-trace-backends=simple --disable-plugins</code> \u2014 options for development needs.</li> <li><code>--enable-trace-backends=simple</code> \u2014 for tracing (described in [[Profiling with QEMU]]).</li> <li><code>--skip-meson</code> \u2014 do not run Meson on every build.</li> <li><code>--disable-werror</code> \u2014 in case QEMU emits unexpected warnings.</li> <li><code>--disable-pie</code> \u2014 needed for older GCC (like in CentOS 7).</li> </ul> <p>Build and install:</p> <pre><code>make\nmake install\n</code></pre> <p>Configure your environment:</p> <pre><code>export QEMU_HOME=\"/tools/qemu\"\nexport PATH=\"${QEMU_HOME}/bin:$PATH\"\n</code></pre>"},{"location":"simulators/qemu/#enhanced-logging","title":"Enhanced Logging","text":"<p>To enable logging, it is necessary to provide the enabled log levels with the <code>-d</code> flag. Some of the more relevant ones are:</p> <p><pre><code>in_asm          show target assembly code for each compiled TB\nnochain         do not chain compiled TBs so that \"exec\" and \"cpu\" show complete traces\nexec            show trace before each executed TB (lots of logs)\ncpu             show CPU registers before entering a TB (lots of logs)\nfpu             include FPU registers in the 'cpu' logging\nint             show interrupts/exceptions in short format\nmmu             log MMU-related activities\nunimp           log unimplemented functionality\n</code></pre> To get a complete listing, run <code>qemu-system-arc -d help</code>. Use <code>-D &lt;logfile&gt;</code> to dump the logs into a file instead of standard output.</p>"},{"location":"simulators/qemu/#tracing-internals","title":"Tracing Internals","text":"<p>QEMU provides a tracing infrastructure which may help in debugging or analyzing what happens within a simulation cycle. At this moment, there are two tracers added into ARC backend, one for MMU operations, and another for exceptions:</p> <pre><code># mmu.c\nmmu_command(uint32_t address, const char *command, uint32_t pd0, uint32_t pd1) \"[MMU] at 0x%08x, CMD=%s, PD0=0x%08x, PD1=0x%08x\"\n# helper.c\nexcp_info(uint32_t address, const char *name) \"[IRQ] at 0x08, Exception=%s\"\n</code></pre> <p>Firstly, build QEMU with the <code>--enable-trace-backends=simple</code> configure parameter. Then Create a file with the events you want to trace. For example, here is such file with name <code>events.trc</code>:</p> <pre><code>mmu_command\nexcp_info\n</code></pre> <p>Run the virtual machine to produce a trace file:</p> <pre><code>$ qemu-system-arc --trace events=events.trc ...\n</code></pre> <p>Pretty-print the binary trace file (override <code>&lt;pid&gt;</code> with QEMU process id for you session):</p> <pre><code>$ &lt;QEMU-source-tree-path&gt;/scripts/simpletrace.py &lt;QEMU-source-tree-path&gt;/target/arc/trace-events trace-&lt;pid&gt;\n</code></pre>"},{"location":"testing/gcc/","title":"Running GCC Tests","text":"<p>After building the toolchain using the arc-gnu-toolchain repository, all tests are automatically available as per this section in the readme.</p>"},{"location":"testing/gcc/#standalone-testing","title":"Standalone testing","text":"<p>It might be useful to perform tests without having to build the entire toolchain.</p> <p>The gcc tests are based on dejagnu so it is expected that the framework is installed in your system.</p> <p>Depending on the simulator used (NSIM or QEMU) it is expected that the correct binaries are present in the PATH.</p> <p>The most direct (manual) way to run the tests is to setup the local environment, include the necessary sources and binaries, and run using a site.exp file. A simple test procedure goes as follows:</p> <pre><code>$ mkdir test_env; cd test_env           # There are output binaries and logs, so its' useful to keep them separate\n$ mkdir tmp                             # Directory used to store the generated objects\n$ export TOOLCHAIN_SRC=/path/to/parent  # Path to parent folder of all ARC tool sources (at least gcc, toolchain and arc-gnu-toolchain)\n$ export TOOLCHAIN_INST=/path/to/bins   # Path to installed binaries (only required if not in path already)\n$ export QEMU_CPU=archs                 # CPU to use in simulation\n$ export PATH=$PATH:$TOOLCHAIN_INST/bin:$TOOLCHAIN_SRC/arc-gnu-toolchain/scripts/wrapper/qemu # Add tools and QEMU wrapper to path (used by arc-sim board)\n$ cat &gt; site.exp &lt;&lt; 'EOF'\nset tool gcc\nset tmpdir \"./tmp\"\nset srcdir \"$env(TOOLCHAIN_SRC)/gcc/gcc/testsuite\"\nset target_triplet arc-unknown-elf32\nset target_alias arc-elf32\nset target_list arc-sim\nset CFLAGS_FOR_TARGET \"--specs=nsim.specs\"\nset arc_board_dir \"$env(TOOLCHAIN_SRC)/toolchain\"\nif ![info exists boards_dir] {\n    lappend boards_dir \"$arc_board_dir/dejagnu\"\n    lappend boards_dir \"$arc_board_dir/dejagnu/baseboards\"\n} else {\n    set boards_dir \"$arc_board_dir/dejagnu\"\n    lappend boards_dir \"$arc_board_dir/dejagnu/baseboards\"\n}\nEOF\n$ runtest        # Now we run the tests!\n</code></pre>"},{"location":"testing/gcc/#other-testsuites","title":"Other testsuites","text":"<p>GCC has other testsuites that can be enabled by adding specific configurations to site.exp</p>"},{"location":"testing/gcc/#compatibility-testsuite","title":"Compatibility testsuite","text":"<p>https://gcc.gnu.org/onlinedocs/gcc/Compatibility.html GCC contains a set of compatibility tests named <code>compat.exp</code>. It allows to test compatibility of GCC with different compilers.</p> <p>If you want to run these tests it is necessary to configure additional variables in <code>site.exp</code> file: <pre><code># Enable compat testing\nset is_gcc_compat_suite \"1\"\n# Use GCC as the alternate compiler (sanity checking)\nset compat_same_alt \"1\"/\"0\"\n# Flags to be used by both compilers\nset TEST_ALWAYS_FLAGS  \"$env(TEST_ALWAYS_FLAGS)\"\n# Path to the alternate compiler used for C/C++\nset ALT_CC_UNDER_TEST  \"$env(COMPAT_ALT_PATH)\"\nset ALT_CXX_UNDER_TEST \"$env(COMPAT_ALT_PATH)\"\n# Flags for gcc and alternate compiler respectively\nset COMPAT_OPTIONS [list [list \"$env(GCC_COMPAT_GCC_OPTIONS)\" \"$env(GCC_COMPAT_CCAC_OPTIONS)\"]]\n# Disable tests with packed structures to avoid unaligned access errors\nset COMPAT_SKIPS [list {ATTRIBUTE}]\n</code></pre></p> <p>Afterwards, launch runtest with <code>compat.exp</code> as an argument as well!</p>"},{"location":"testing/gcc/#gcc-and-ccac-compatibility","title":"GCC and CCAC compatibility","text":"<p>Some configurations that have been used to test compatibility between GCC and CCAC:</p> <pre><code># Common global flags\nexport TEST_ALWAYS_FLAGS=\"-O0 -g\"\n# Common GCC flags\nexport GCC_COMPAT_GCC_OPTIONS=\"-Wl,-z,muldefs -Wl,--no-warn-mismatch -lgcc -lnsim -lg -lm -lmw\"\n# Common CCAC flags\nexport GCC_COMPAT_CCAC_OPTIONS=\"-Xbasecase -Hnocopyr -Hnosdata -fstrict-abi\"\n</code></pre>"},{"location":"testing/gcc/#hs6x","title":"hs6x","text":"<pre><code>export GCC_COMPAT_GCC_OPTIONS=\"$GCC_COMPAT_GCC_OPTIONS -mcpu=hs6x -L$METAWARE_ROOT/arc/lib/av2em/le\"\nexport GCC_COMPAT_CCAC_OPTIONS=\"$GCC_COMPAT_CCAC_OPTIONS -arc64\"\n</code></pre>"},{"location":"testing/gcc/#hs5x","title":"hs5x","text":"<pre><code>export GCC_COMPAT_GCC_OPTIONS=\"$GCC_COMPAT_GCC_OPTIONS -mcpu=hs5x -L$METAWARE_ROOT/arc/lib/av3hs/le\"\nexport GCC_COMPAT_CCAC_OPTIONS=\"$GCC_COMPAT_CCAC_OPTIONS -arcv3hs\"\n</code></pre>"},{"location":"testing/gcc/#arcv2","title":"ARCv2","text":"<pre><code>export GCC_COMPAT_GCC_OPTIONS=\"$GCC_COMPAT_GCC_OPTIONS -mcpu=em4_dmips -mno-sdata -fshort-enums -L$METAWARE_ROOT/arc/lib/av2em/le\"  export GCC_COMPAT_CCAC_OPTIONS=\"$GCC_COMPAT_CCAC_OPTIONS -av2em\"\n</code></pre>"},{"location":"testing/gcc/#testing-for-other-configurations","title":"Testing for other configurations","text":"<p>The example above runs for archs. To use other architectures, you can simply: 1. Change the available binaries in <code>$TOOLCHAIN_INST</code> 2. Give qemu the appropriate <code>$QEMU_CPU</code> 3. Set the correct <code>target_triplet</code> and <code>target_alias</code></p> <p>Below are some common setups.</p>"},{"location":"testing/gcc/#hs6x_1","title":"hs6x","text":"<ol> <li>Make available arc64-elf-* tools and necessary resources</li> <li>export QEMU_CPU=hs6x</li> <li>In site.exp above, set the following:</li> </ol> <pre><code>set target_triplet arc64-unknown-elf\nset target_alias arc64-elf\n</code></pre>"},{"location":"testing/gcc/#hs5x_1","title":"hs5x","text":"<ol> <li>Make available arc32-elf-* tools and necessary resources</li> <li>export QEMU_CPU=hs5x</li> <li>In site.exp above, set the following: <pre><code>set target_triplet arc32-unknown-elf\nset target_alias arc32-elf\n</code></pre></li> </ol>"},{"location":"testing/gcc/#using-nsim","title":"Using NSIM","text":"<p>To use nsim simply set in site.exp the following:</p> <pre><code>set target_list arc-sim-nsimdrv\n</code></pre>"},{"location":"testing/glibc/","title":"Running Glibc Tests","text":"<p>Currently our toolchain Makefiles don't support automated testing, but this may change in the near future. Look here for possible support.</p>"},{"location":"testing/glibc/#standalone-testing","title":"Standalone testing","text":"<p>It might be useful to perform tests without having to build the entire toolchain.</p> <p>To perform the tests, it is necessary to build glibc like:</p> <pre><code>$ export TOOLCHAIN_SRC=/absolute/path/to/parent                  # Path to parent of ARC sources (at least glibc, toolchain and arc-gnu-toolchain)\n$ export GLIBC_PARENT=/new/empty/directory; cd $GLIBC_PARENT     # We might need to network share this directory, so create a new one\n$ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/glibc;\n$ cd glibc; git checkout arc64                                   # Setup the glibc source we want to test\n$ cd ../; mkdir glibc_build\n$ ../glibc/configure --host=arc64-linux-gnu --prefix=/usr             \\\n--disable-werror --enable-shared --enable-obsolete-rpc                \\\n--with-headers=$TOOLCHAIN_SRC/arc-gnu-toolchain/linux-headers/include \\\n--disable-multilib --libdir=/usr/lib libc_cv_slibdir=/lib             \\\nlibc_cv_rtlddir=/lib CFLAGS=\"-O2 -g3\"\n$ make -j &lt;NMB_CORES&gt;                                            # set NMB_CORES to whatever amount of cores you want \n</code></pre> <p>There are two ways to run the GLIBC tests for ARC. We can use QEMU usermode or full system emulation.</p>"},{"location":"testing/glibc/#user-mode-testing","title":"User mode testing","text":"<p>If you are running a linux host, usermode provides faster but possibly less accurate testing, since it uses the host kernel instead of a fully simulated one.</p>"},{"location":"testing/glibc/#setting-up","title":"Setting up","text":"<p>There are a few ways to set this up but the most direct one is to setup binfmt. Fortunately, QEMU provides a script that sets up binfmt so the launched executables are interpreted by a shell script at <code>/usr/local/qemu-arc64</code>. An example of which is:</p> <pre><code>$ sudo $QEMU_SOURCE/scripts/qemu-binfmt-conf.sh\n$ sudo cat &gt; /usr/local/bin/qemu-arc64 &lt;&lt; 'EOF'\n#!/bin/bash\n${QEMU_BINPATH}/qemu-arc64 -R 4G -L ${TOOLCHAIN_INST}/sysroot -cpu hs6x $@\nEOF\n</code></pre> <p>Afterwards, launching an ARC executable will run this script and consequently, QEMU.</p>"},{"location":"testing/glibc/#running-the-tests","title":"Running the tests","text":"<p>Running the actual tests is simple. <pre><code>$ cd $GLIBC_PARENT/glibc-build\n$ make tests\n</code></pre></p> <p>The results are then stored in <code>*test-result</code> files. See some debugging tips at the end of this wiki entry</p>"},{"location":"testing/glibc/#full-system","title":"Full system","text":"<p>To run the more accurate but `heavier` full system tests, there are a few intermediary steps required.</p>"},{"location":"testing/glibc/#linux-image","title":"Linux image","text":"<p>We will need to generate local ssh keys (<code>ssh-keygen -t ed25519</code>) Then, configure a linux image. The configurations required are:</p> <ol> <li>eth0 configured via dhcp</li> <li>gdbserver, ssh and ftpd</li> <li>User/Network namespace support</li> <li>An overlay file system such that the generated public key is recognized (present inside '~/.ssh/authorized_keys')</li> </ol>"},{"location":"testing/glibc/#nfs","title":"NFS","text":"<p>Second, we need to be able to share our build and source directories with the qemu instance that will be running the aforementioned Linux image.</p> <p>There are many ways to do this, but the one contemplated here is NFS. Install and enable it for your respective platform and set up $GLIBC_PARENT as a shared directory.</p>"},{"location":"testing/glibc/#running-the-instance","title":"Running the instance","text":"<p>In a separate terminal, we run the QEMU instance that must stay alive for the entirety of the testing.</p> <pre><code>$ qemu-system-arc64 -M virt -cpu hs6x -nographic -no-reboot -global cpu.freq_hz=50000000 -netdev user,id=net0,hostfwd=tcp::2221-:21,hostfwd=tcp::2222-:22,hostfwd=tcp::2223-:23,hostfwd=tcp::6175-:6175 -device virtio-net-device,netdev=net0 -kernel $PATH_TO_LOADER/glicready_loader\nLinux version 5.16.0-711640-g19e84a74062a (YOUR_USER@YOUR_MACHINE) (arc64-linux-gnu-gcc (ARCv3 ARC64 GNU/Linux f2bc3b4c762) 12.2.1 20220829, GNU ld (GNU Binutils) 2.40.50.20230314) #11 PREEMPT Tue May 9 10:32:00 WEST 2054\nMemory @ 80000000 [1024M] Memory @ 100000000 [1024M] Not used\nOF: fdt: Machine model: snps,zebu_hs\nearlycon: uart8250 at MMIO32 0x00000000f0000000 (options '115200n8')\nprintk: bootconsole [uart8250] enabled\n\n...\n\nWelcome to Buildroot\nbuildroot login: root\n# # Mount the network folders\n# export SHARED_DIR=/same/absolute/path/as/for/GLIBC_PARENT\n# mkdir -p $SHARED_DIR\n# mount -t nfs -o nolock 10.0.2.2:$SHARED_DIR $SHARED_DIR\n</code></pre> <p>We can test the connection with:</p> <pre><code>$ ssh -p 2222 root@127.0.0.1\nThe authenticity of host '[127.0.0.1]:2222 ([127.0.0.1]:2222)' cant be established.\nED25519 key fingerprint is SHA256:jbqautMkwc2FSBo4c89RKpTDjaSDlmQ3dGk+TrWOCjo.\nThis key is not known by any other names.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '[127.0.0.1]:2222' (ED25519) to the list of known hosts.\n# exit\nConnection to 127.0.0.1 closed.\n$\n</code></pre>"},{"location":"testing/glibc/#setting-up-the-tests","title":"Setting up the tests","text":"<p>For the tests to automatically run without entering the password for each one, we must setup an ssh host with the keys shared with the linux image</p> <pre><code>$ cat ~/.ssh/config\n...\nHOST arcglibc\n    HostName 127.0.0.1\n    User root\n    Port 2222\nIdentityFile ~/.ssh/id_ed25519\n    HostKeyAlgorithms ssh-ed25519\n...\n$\n</code></pre>"},{"location":"testing/glibc/#running-the-tests_1","title":"Running the tests","text":"<p>With the QEMU instance running, now we can run the actual tests.</p> <pre><code>$ cd $GLIBC_PARENT/glibc-build\n$ make test-wrapper=\"/absolute/path/to/shared/glibc/scripts/cross-test-ssh.sh --timeoutfactor 30 arcglibc\" tests\n</code></pre> <p>The results are then stored in <code>*test-result</code> files.</p>"},{"location":"testing/glibc/#debugging-in-full-system","title":"Debugging in full system","text":"<p>In full system it is not a good idea to use QEMUs' gdbstub unless we want to debug the whole kernel. As such we must use the gdbserver packaged in with the linux image:</p> <pre><code># gdbserver 127.0.0.1:6175 $SHARED_DIR/glibc-build/math/test-float-tgamma\n</code></pre> <p>And then we simply connect GDB</p> <pre><code>$ arc64-elf-gdb $GLIBC_PARENT/glibc-build/math/test-float-tgamma\n(gdb) target remote:6175\n</code></pre> <p>If there is any problem running the image, <code>Ctrl+A X</code> can be used to kill QEMU After an instance has run, we might get the following error which will crash the tests. It is best to run the <code>ssh-keygen</code> command below after stopping QEMU to prevent it.</p> <pre><code>$ ssh -p 2222 root@127.0.0.1\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                        @    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ED25519 key sent by the remote host is\nSHA256:jbqautMkwc2FSBo4c89RKpTDjaSDlmQ3dGk+TrWOCjo.\nPlease contact your system administrator.\nAdd correct host key in /home/YOUR_USER/.ssh/known_hosts to get rid of this message.\nOffending ED25519 key in /home/YOUR_USER/.ssh/known_hosts:16\nHost key for [127.0.0.1]:2222 has changed and you have requested strict checking.\nHost key verification failed.\n$ ssh-keygen -f \"/home/YOUR_USER/.ssh/known_hosts\" -R \"[127.0.0.1]:2222\"\n# Host [127.0.0.1]:2222 found: line 160\n/home/YOUR_USER/.ssh/known_hosts updated.\nOriginal contents retained as /home/YOUR_USER/.ssh/known_hosts.old\n</code></pre> <p>See more debugging tips below</p>"},{"location":"testing/glibc/#general-debugging-tips","title":"General debugging tips","text":""},{"location":"testing/glibc/#single-test","title":"Single test","text":"<p>You can run a single test by replacing 'tests' with the test /, i.e. 'test t=math/test-double-trunc'"},{"location":"testing/glibc/#single-group-of-tests","title":"Single group of tests","text":"<p>You can run a single group of tests by adding 'subdirs='' after 'tests', i.e.  'tests subdirs=math'"},{"location":"testing/newlib/","title":"Running Newlib Tests","text":""},{"location":"testing/newlib/#preface","title":"Preface","text":"<p>After building the toolchain using the arc-gnu-toolchain repository, all tests are automatically available as per this section in the readme.</p>"},{"location":"testing/newlib/#standalone-testing","title":"Standalone testing","text":"<p>It might be useful to perform tests without having to build the entire toolchain.</p> <p>The newlib tests are based on dejagnu so it is expected that the framework is installed in your system.</p> <p>Depending on the simulator used (nSIM or QEMU) it is expected that the correct binaries are present in the <code>PATH</code>.</p> <p>The most direct (manual) way to run the tests is to setup the local environment, include the necessary sources and binaries, and run using a site.exp file. A simple test procedure goes as follows:</p> <pre><code>$ mkdir test_env; cd test_env           # There are output binaries and logs, so its' useful to keep them separate\n$ mkdir tmp                             # Directory used to store the generated objects\n$ export TOOLCHAIN_SRC=/path/to/parent  # Path to parent folder of all ARC tool sources (at least newlib, toolchain and arc-gnu-toolchain)\n$ export TOOLCHAIN_INST=/path/to/bins   # Path to installed binaries (only required if not in path already)\n$ export QEMU_CPU=archs                 # CPU to use in simulation\n$ export PATH=$PATH:$TOOLCHAIN_INST/bin:$TOOLCHAIN_SRC/arc-gnu-toolchain/scripts/wrapper/qemu # Add tools and QEMU wrapper to path (used by arc-sim board)\n$ cat &gt; site.exp &lt;&lt; 'EOF'\nset tool newlib\nset tool_version 4.3.0\nset tmpdir \"./tmp\"\nset srcdir \"$env(TOOLCHAIN_SRC)/newlib/newlib/testsuite\"\nset target_triplet arc-unknown-elf32\nset target_alias arc-elf32\nset target_list arc-sim\nset CFLAGS_FOR_TARGET \"--specs=nsim.specs\"\nset arc_board_dir \"$env(TOOLCHAIN_SRC)/toolchain\"\nif ![info exists boards_dir] {\n    lappend boards_dir \"$arc_board_dir/dejagnu\"\n    lappend boards_dir \"$arc_board_dir/dejagnu/baseboards\"\n} else {\n    set boards_dir \"$arc_board_dir/dejagnu\"\n    lappend boards_dir \"$arc_board_dir/dejagnu/baseboards\"\n}\nEOF\n$ runtest        # Now we run the tests!\n</code></pre>"},{"location":"testing/newlib/#testing-for-other-configurations","title":"Testing for Other Configurations","text":"<p>The example above runs for archs. To use other architectures, you can simply:</p> <ol> <li>Change the available binaries in <code>$TOOLCHAIN_INST</code></li> <li>Give qemu the appropriate <code>$QEMU_CPU</code></li> <li>Set the correct <code>target_triplet</code> and <code>target_alias</code></li> </ol> <p>Below are some common setups.</p>"},{"location":"testing/newlib/#running-tests-for-hs6x","title":"Running Tests for HS6x","text":"<ol> <li>Make available arc64-elf-* tools and necessary resources</li> <li>export QEMU_CPU=hs6x</li> <li>In site.exp above, set the following:</li> </ol> <pre><code>set target_triplet arc64-unknown-elf\nset target_alias arc64-elf\n</code></pre>"},{"location":"testing/newlib/#running-tests-for-hs5x","title":"Running Tests for HS5x","text":"<ol> <li>Make available arc32-elf-* tools and necessary resources</li> <li>export QEMU_CPU=hs5x</li> <li>In site.exp above, set the following:</li> </ol> <pre><code>set target_triplet arc32-unknown-elf\nset target_alias arc32-elf\n</code></pre>"},{"location":"testing/newlib/#running-tests-using-nsim","title":"Running Tests using nSIM","text":"<p>To use nsim simply set in site.exp the following:</p> <pre><code>set target_list arc-sim-nsimdrv\n</code></pre>"},{"location":"testing/qemu/","title":"Running QEMU Tests","text":"<p>TCG is the internal language that powers QEMU. There are some assembly tests that validate the basic function of several instructions in QEMU.</p> <p>Firstly, make sure that QEMU if configured with <code>--cross-cc-arc=arc-elf32-gcc</code> and <code>--cross-cc-arc64=arc64-elf-gcc</code> options. Then after building QEMU use these commands to run TCG tests:</p> <pre><code>make clean-tcg\nmake build-tcg\nmake check-tcg\n</code></pre>"}]}