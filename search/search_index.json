{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GNU Toolchain for ARC User Manual","text":""},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#linker-fails-with-error-undefined-reference-to-_exit","title":"Linker fails with error: <code>undefined reference to _exit</code>","text":"<p>Among other possible functions are also <code>_sbrk</code>, <code>_write</code>, <code>_close</code>, <code>_lseek</code>, <code>_read</code>, <code>_fstat</code>, <code>_isatty</code>.</p> <p>Function <code>_exit</code> is not provided by the <code>libc</code> itself, but must be provided by the <code>libgloss</code>, which is basically a BSP (board support package). Currently several <code>libgloss</code> implementations are provided for ARC:</p> <ul> <li><code>libnosys</code> - a generic implementation with stubs.</li> <li><code>libnsim</code> - implements nSIM and QEMU IO hostlink (GNU version).</li> <li><code>libqemu</code> - implements a simplified IO hostlink for QEMU.</li> <li><code>libhl</code> - implements nSIM IO hostlink (MetaWare version).</li> <li><code>libiotdk_uart</code>, <code>libhsdk_uart</code>, <code>libemsk_uart</code> - implementations for development boards.</li> </ul> <p>In general <code>libnosys</code> is more suitable for hardware targets that does not have hostlink support, however other implementations have a distinct advantage that on exit from an application and in case of many errors it halts the core, while <code>libnosys</code> causes it to infinite loop on one place.</p>"},{"location":"faq/#ive-opened-hs38tcf-and-gcc-options-include-mcpuhs34-why-hs34-instead-of-hs38","title":"I\u2019ve opened <code>hs38.tcf</code> and GCC options include <code>-mcpu=hs34</code>. Why <code>hs34</code> instead of <code>hs38</code>?","text":"<p>Possible values of <code>-mcpu=</code> options are orthogonal to names of IPlib templates and respective TCF. GCC option <code>-mcpu=</code> supports both <code>hs34</code> and <code>hs38</code> values, but they are different - <code>hs38</code> enables more features, like <code>-mll64</code> which are not present in <code>hs34</code>. ARC HS IPlib template <code>hs38</code> doesn\u2019t contain double-word load/store, therefore -mcpu=hs38 is not compatible with this template. <code>-mcpu=hs34</code>, however, is compatible and that is why TCF generator uses this value. Refer Target Specific Options page for a full list of possible <code>-mcpu</code> values and what IPlibrary templates they correspond to.</p>"},{"location":"faq/#there-are-cant-resolve-symbol-error-messages-when-using-gdbserver-on-linux-for-arc-targets","title":"There are <code>can\u2019t resolve symbol</code> error messages when using <code>gdbserver</code> on Linux for ARC targets","text":"<p>This error message might appear when <code>gdbserver</code> is a statically linked application. Even though it is linked statically, <code>gdbserver</code> still opens <code>libthread_db.so</code> library using <code>dlopen()</code> function. There is a circular dependency here, as <code>libthread_db.so</code> expects several dynamic symbols to be already defined in the loading application (<code>gdbserver</code> in this case). However statically linked <code>gdbserver</code> does not export those dynamic symbols, therefore <code>dlopen()</code> invocation causes those error messages. In practice there have not been noticed any downside of this, even when debugging applications with threads, however that was tried only with simple test cases. To fix this issue, either rebuild gdbserver as a dynamically linked application, or pass option <code>--with-libthread-db=-lthread_db</code> to configure script of script. In this case gdbserver will link with <code>libthread_db</code> statically, instead of opening it with <code>dlopen()</code> and dependency on symbols will be resolved at link time.</p>"},{"location":"faq/#gdb-prints-an-error-message-that-xml-support-has-been-disabled-at-compile-time","title":"GDB prints an error message that <code>XML support has been disabled at compile time</code>","text":"<p>GDB uses Expat library to parse XML files. Support of XML files is optional for GDB, therefore it can be built without Expat available, however for ARC it usually required to have support of XML to read target description files. Mentioned error message might happen if GDB has been built without available development files for the Expat. On Linux systems those should be available as package in package manager.</p>"},{"location":"faq/#how-to-reset-arc-sdp-board-programmatically-without-pressing-reset-button","title":"How to reset ARC SDP board programmatically (without pressing <code>Reset</code> button)?","text":"<p>It is possible to reset ARC SDP board without touching the physical button on the board. This can be done using the special OpenOCD script:</p> <pre><code>$ openocd -f test/arc/reset_sdp.tcl\n</code></pre> <p>Note that OpenOCD will crash with a segmentation fault after executing this script - this is expected and happens only after board has been reset, but that means that other OpenOCD scripts cannot be used in chain with <code>reset_sdp.tcl</code>, first OpenOCD should be invoked to reset the board, second it should be invoked to run as an actual debugger.</p>"},{"location":"faq/#can-i-program-fpgas-in-arc-em-starter-kit-or-in-arc-sdp","title":"Can I program FPGA's in ARC EM Starter Kit or in ARC SDP?","text":"<p>OpenOCD has some support for programming of FPGA\u2019s over JTAG, however it is not officially supported for ARC development systems.</p>"},{"location":"faq/#when-debugging-arc-em-core-in-axs101-with-ashling-opella-xd-and-gdbserver-i-get-an-error-messages-and-gdb-shows-that-all-memory-and-registers-are-zeroes","title":"When debugging ARC EM core in AXS101 with Ashling Opella-XD and GDBserver I get an error messages and GDB shows that all memory and registers are zeroes","text":"<p>Decrease a JTAG frequency to no more than 5MHz using an Ashling GDBserver option <code>--jtag-frequency</code>. This particular problem can be noted if GDBserver prints:</p> <pre><code>Error: Core is running (unexpected), attempting to halt...\nError: Core is running (unexpected), attempting to halt...\nError: Unable to halt core\n</code></pre> <p>While GDB shows that whole memory is just zeroes and all register values are also zeroes.</p>"},{"location":"advanced/64-bit-operations/","title":"Impact of 64-bit Integral Operation on GCC Toolchain","text":""},{"location":"advanced/64-bit-operations/#preface","title":"Preface","text":"<p>Some of the new 64 bit integral operations made available for ARCv2HS can be used to map the C-type long long. These are:</p> Operations Hardware option Possible usage <code>LDD</code>/<code>STD</code> <code>LL64_OPTION</code> Load/store 64 bit data type Chained <code>MPYM</code>/<code>MPYMU</code> <code>MPY_OPTION_{5,6}</code> Implementation of 32x32-&gt;64 bit operations <code>MAC</code>/<code>MACU</code> <code>MPY_OPTION_7</code> Multiply and accumulate operations <code>MACD</code>/<code>MACDU</code> <code>MPY_OPTION_8+</code> Multiply and accumulate operations <code>MPYD</code>/<code>MPYDU</code> <code>MPY_OPTION_8+</code> Implementation of 32x32-&gt;64 bit operations <code>VADD2</code> <code>MPY_OPTION_9</code> Register to register move of a 64 bit data type"},{"location":"advanced/64-bit-operations/#64-bit-move-operations","title":"64-bit Move Operations","text":"<p>First step in efficiently supporting the long long data type is implementing an efficient way to move the 64 bit data type in and out register file as well as within register file. The <code>LL64_OPTION</code> provides us with the means for fast transfer of 64 bit data into a processor register pair. The <code>LDD</code>/<code>STD</code> can be used as well to implement a fast way to save/restore the registers in prologue/epilogue of a function.</p> <p>The <code>MPY_OPTION_9</code> also gives us means to move a register to another register or a 32-bit immediate into a 64 bit register. The 32-bit immediate is signed extended to match the 64 bit container. Hence, for a register to register move, we can use the following instruction:</p> <pre><code>VADD2        r0r1,r2r3,0\n</code></pre> <p>The above instruction takes 32 bits in the program memory as it uses the <code>VADD2 A,B,u6</code> encoding. Although <code>VADD2</code> supports predication, we cannot use it for register to register move due to ISA limitations (e.g., the source of the operands needs to be the input argument <code>vadd2 .cc b,b,u6</code>) If we want to move and sign extend a 32-bit immediate into a 64-bit register pair, we can use the following instruction:</p> <pre><code>VADD2        r0r1, 0xAFEF, 0\n</code></pre> <p>The above instruction takes 64 bits in the program memory as we use <code>VADD2 A,limm,u6</code> encoding.</p>"},{"location":"advanced/64-bit-operations/#multiplication-instructions","title":"Multiplication Instructions","text":"<p>The implementation of multiplication instructions depends on the multiplier option used. A special care should be taken for chained operation when <code>MPY_OPTION</code> is either 5 or 6. In these configurations, the multiplier is blocking sequential, hence, the chained option improves the multiplication result. This, however, may be relevant for EM series as the HS will employ a fully pipelined multiplier.</p> <p>In general, for 32x32bit -&gt; 64 bit type of multiplier, we use the <code>MPY-MPYM</code> instructions pair. However, when using <code>MPY_OPTION</code> larger than 7, we can make use of the <code>MPYD</code>/<code>MPYDU</code> instructions. These instructions are faster and are having a smaller impact on memory size than previous used solution. Please remark that the <code>MPYD</code>/<code>MPYDU</code> clobbers also the 64-bit accumulator register <code>(ACCH,ACCL)</code>.</p>"},{"location":"advanced/64-bit-operations/#multiply-and-accumulate-instructions","title":"Multiply and Accumulate Instructions","text":"<p>The ISAv2, provides a number of MAC operations. These are <code>MAC</code>/<code>MACU</code> for <code>MPY_OPTION</code> equals to 7, and additionally <code>MACD</code>/<code>MACDU</code> when using <code>MPY_OPTION</code> eight or more. The latter ones are interesting as they place the 64 bit result in a register pair. All the MAC operations are using the 64-bit accumulator register <code>(ACCH, ACCL)</code> to accumulate with, as well to place the result mac into.</p> <p>Using a MAC operation needs to set up the accumulator register, as well as collecting the result from the accumulator and place it into a general purpose register. Hence,</p> Used instructions Single MAC (instructions) Multiple MACs, unroll case Throughput <code>MAC</code>/<code>MACU</code> 4 (2 loads into <code>(ACCH, ACCL)</code>; 1 <code>MAC</code>; 1 move from <code>ACCH</code> to register) 4 + 1 for each unrolled <code>MAC</code> (2 to initialize <code>(ACCH, ACCL)</code>; 2 to move the accumulator) 3+ (output/anti-dependency on <code>ACC</code>), 1 (otherwise) <code>MACD</code>/<code>MACDU</code> 3 (2 loads to <code>(ACCH, ACCL)</code>; 1 <code>MAC</code>) 2 + 1 for each unrolled <code>MAC</code> 3+ (output/anti-dependency on <code>ACC</code>), 1 (otherwise) <code>ADD</code>/<code>MPYD</code> 3 (2 additions; 1 <code>MPYD</code>) 3 ops for each <code>MAC</code> 3 <code>ADD</code>/<code>MPY</code> 4 (2 additions; 2 multiplications) 4 ops for each <code>MAC</code> 4"},{"location":"advanced/64-bit-operations/#caveats","title":"Caveats","text":"<p>Having the implicit 64-bit accumulator as destination for <code>MPYD</code>/<code>MPYDU</code> operations complicate the generated code when we have an anti-dependency with a <code>MAC</code> operation on the accumulator register.</p> <p>The accumulator register is used as input as well as output for the <code>MAC</code> operation, hence, using them in a pipelined fashion may be difficult (if, for example, between mac operations exist an output/anti-dependency). In this case, it is faster to use an implementation with <code>ADD</code>/<code>MPYD</code> operations.</p>"},{"location":"advanced/64-bit-operations/#case-study","title":"Case Study","text":"<p>Consider the following C-program:</p> <pre><code>long long foo (long long a, int b, int c)\n{\na += (long long) c * (long long) b;\nreturn a;\n}\n</code></pre>  Implementation  Assembler (estimated)  <code>ADD</code>/<code>MPY</code> <pre><code>mpym   r5,r3,r2\nmpy    r4,r3,r2\nadd.f  r0,r0,r4\nadc    r1,r1,r5\n</code></pre> <code>ADD</code>/<code>MPYD</code> <pre><code>mpyd   r2,r3,r2\nadd.f  r0,r2,r0\nadc    r1,r3,r1\n</code></pre> <code>MAC</code> <pre><code>mov    ACCL,r0\nmov    ACCH,r1\nmac    r0,r2,r3\nmov    r1,ACCH\n</code></pre> <code>MACD</code> (option 8) <pre><code>mov    ACCL,r0\nmov    ACCH,r1\nmacd   r0,r2,r3\n</code></pre> <code>MACD</code> (option 9) <pre><code>vadd2  ACC,r0,0\nmacd   r0,r2,r3\n</code></pre>"},{"location":"advanced/64-bit-operations/#implementation-matrix-used-by-gcc","title":"Implementation Matrix Used by GCC","text":"<p>Due to the accumulator caveats, consider the following implementation matrix for <code>MAC</code> operations:</p> <code>MPY_OPTION</code> 2 3 4 5 6 7 8 9 <code>ADD</code>/<code>MPY</code> Y Y Y Y Y Y N N <code>ADD</code>/<code>MPYD</code> N N N N N N Y N <code>MAC</code> N N N N N N N N <code>MACD</code> N N N N N N N Y <p>Refer Target Specific Options for details.</p>"},{"location":"advanced/apex-header/","title":"Migrating APEX Header","text":""},{"location":"advanced/apex-header/#preface","title":"Preface","text":"<p>ARChitect2 tool generates a special header file when APEX instructions are specified/selected in ARChitect. Here is an example:</p> <pre><code>/* **** DO NOT EDIT - this file is generated by ARChitect2 ****\n *\n * Description: Header file declaring the compiler extensions for apex components\n */\n#ifndef _apexextensions_H_\n#define _apexextensions_H_\n#define APEX_EXT_CORE_REGS_EXT_CORE_REGS_PRESENT        1\n// User extension aux register auxreg0\n#define AR_AUXREG0 0xfffff800\n#pragma Aux_register(0xfffff800, name=&gt;\"auxreg0\")\n// User extension aux register auxreg1\n#define AR_AUXREG1 0xfffff801\n#pragma Aux_register(0xfffff801, name=&gt;\"auxreg1\")\n// User extension core register r32\n#define CR_R32 32\n#pragma Core_register(32, name=&gt;\"r32\")\n// User extension core register r33\n#define CR_R33 33\n#pragma Core_register(33, name=&gt;\"r33\")\n// User extension core register r34\n#define CR_R34 34\n#pragma Core_register(34, name=&gt;\"r34\")\n// User extension core register r35\n#define CR_R35 35\n#pragma Core_register(35, name=&gt;\"r35\")\n// User extension instruction insn1\nextern long insn1(long,long);\n#pragma intrinsic(insn1,opcode=&gt;7,sub_opcode=&gt;5, effects=&gt;\"reg=32:is_read:is_written; reg=33:is_read:is_written; reg=34:is_read:is_written; reg=35:is_read:is_written; auxreg=0xfffff800:is_read:is_written; auxreg=0xfffff801:is_read:is_written\")\n// User extension instruction insn2\nextern long insn2(long);\n#pragma intrinsic(insn2,opcode=&gt;7,sub_opcode=&gt;1, effects=&gt;\"reg=32:is_read:is_written; reg=33:is_read:is_written; reg=34:is_read:is_written; reg=35:is_read:is_written; auxreg=0xfffff800:is_read:is_written; auxreg=0xfffff801:is_read:is_written\")\n#endif\n</code></pre>"},{"location":"advanced/apex-header/#auxiliary-registers","title":"Auxiliary Registers","text":"<pre><code>// User extension aux register auxreg0\n#define AR_AUXREG0 0xfffff800\n#pragma Aux_register(0xfffff800, name=&gt;\"auxreg0\")\n</code></pre> <p>MetaWare compiler accepts the definition of various extension features via pragmas. However, this is not the case for GNU. In this case, we need to use inline assembly to make the toolchain aware of the added functionality. Thus, to handle auxiliary register definition at C-level, we may need to define this:</p> <pre><code>#define Aux_register(ADDR, NAME)                \\\n    asm (\".extAuxRegister \" NAME \", \" #ADDR \", r|w\")\n</code></pre> <p>Instantiate the register:</p> <pre><code>Aux_register (0xfffff800, \"auxreg0\");\n</code></pre>"},{"location":"advanced/apex-header/#extension-core-registers","title":"Extension Core Registers","text":"<pre><code>// User extension core register r32\n#define CR_R32 32\n#pragma Core_register(32, name=&gt;\"r32\")\n</code></pre> <p>Usually, GNU recognizes all the extension core registers as <code>r32-r57</code>. Thus, it is not necessary to define a core register which has the same name as in GNU.</p>"},{"location":"advanced/apex-header/#extension-instructions","title":"Extension Instructions","text":"<pre><code>// User extension instruction insn1\nextern long insn1(long,long);\n#pragma intrinsic(insn1,opcode=&gt;7,sub_opcode=&gt;5, effects=&gt;\"reg=32:is_read:is_written; reg=33:is_read:is_written; reg=34:is_read:is_written; reg=35:is_read:is_written; auxreg=0xfffff800:is_read:is_written; auxreg=0xfffff801:is_read:is_written\")\n</code></pre> <p>MetaWare format uses the function <code>insn1</code> declaration to select the instruction syntax, while <code>pragma</code> defines MOP, SOP and sides effects of the instruction. Thus, for our example, <code>insn1</code> must use <code>SYNTAX_3OP</code>:</p> <pre><code>#define intrinsic_3OP(NAME, MOP, SOP)           \\\n    asm (\".extInstruction \" NAME \",\" #MOP \",\"   \\\n    #SOP \",SUFFIX_NONE, SYNTAX_3OP\\n\\t\")\nintrinsic_3OP (\"insn1\", 7, 5);\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\ninsn1 (int32_t __a, int32_t __b)\n{\nint32_t __dst;\n__asm__ (\"insn1 %0, %1, %2\\n\\t\"\n: \"=r\" (__dst)\n: \"r\" (__a), \"rCal\" (__b)\n: \"r32\", \"r33\", \"r34\", \"r35\");\nreturn __dst;\n}\n</code></pre> <p>A list of clobber registers may be ignored as the compiler does not handle <code>r32-r56</code> registers. However, to be safe, it is good to mention them. As for auxiliary register, one can ignore or just add <code>memory</code> to the clobber list as AUX registers is memory.</p>"},{"location":"advanced/apex-header/#final-header-file","title":"Final Header File","text":"<pre><code>#ifndef _apexextensions_H_\n#define _apexextensions_H_\n#include &lt;stdint.h&gt;\n#define Aux_register(ADDR, NAME)                \\\n  asm (\".extAuxRegister \" NAME \", \" #ADDR \", r|w\")\n#define intrinsic_3OP(NAME, MOP, SOP)           \\\n  asm (\".extInstruction \" NAME \",\" #MOP \",\"             \\\n  #SOP \",SUFFIX_NONE, SYNTAX_3OP\\n\\t\")\n#define intrinsic_2OP(NAME, MOP, SOP)           \\\n  asm (\".extInstruction \" NAME \",\" #MOP \",\"             \\\n  #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\")\nAux_register (0xfffff800, \"auxreg0\");\nAux_register (0xfffff801, \"auxreg1\");\nintrinsic_3OP (\"insn1\", 7, 5);\nintrinsic_2OP (\"insn2\", 7, 1);\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\ninsn1 (int32_t __a, int32_t __b)\n{\nint32_t __dst;\n__asm__ (\"insn1 %0, %1, %2\\n\\t\"\n: \"=r\" (__dst)\n: \"r\" (__a), \"rCal\" (__b)\n: \"r32\", \"r33\", \"r34\", \"r35\", \"memory\");\nreturn __dst;\n}\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\ninsn2 (int32_t __a)\n{\nint32_t __dst;\n__asm__ (\"insn2 %0, %1\\n\\t\"\n: \"=r\" (__dst)\n: \"rCal\" (__a)\n: \"r32\", \"r33\", \"r34\", \"r35\", \"memory\");\nreturn __dst;\n}\n#endif\n</code></pre>"},{"location":"advanced/bit-file-fpga/","title":"Writing Bit-file into FPGA with Digilent HS Cable","text":"<p>Below is an example given of how to program a Xilinx ML509 FPGA developers board. NOTE: make sure the Digilent HS cable is connected to the right JTAG connector on the board (programming the FPGA and not the memory). So, it should be connected to PC4 JTAG and not to J51 BDM. Further more, Device 4: XC5VLX110T is the FPGA to program, device 4 in the JTAG scan chain.</p> <pre><code>&gt; djtgcfg enum\nFound 1 device(s)\n\nDevice: JtagHs2\n    Product Name:   Digilent JTAG-HS2\n    User Name:      JtagHs2\n    Serial Number:  210249810909\n\n&gt; djtgcfg -d JtagHs2 init\nInitializing scan chain...\nFound Device ID: a2ad6093\nFound Device ID: 0a001093\nFound Device ID: 59608093\nFound Device ID: f5059093\nFound Device ID: f5059093\n\nFound 5 device(s):\n    Device 0: XCF32P\n    Device 1: XCF32P\n    Device 2: XC95144XL\n    Device 3: XCCACE\n    Device 4: XC5VLX110T\n\n&gt; djtgcfg -d JtagHs2 prog -i 4 -f &lt;fpga bit file to progam&gt;.bit\nProgramming device. Do not touch your board. This may take a few minutes...\nProgramming succeeded.\n</code></pre>"},{"location":"advanced/custom-instructions/","title":"Custom instructions","text":""},{"location":"advanced/custom-instructions/#extension-instructions-encoding","title":"Extension Instructions Encoding","text":"<p>ARC architecture allows users to specify extension instructions. These extension instructions are not macros. The assembler creates encodings for using these instructions according to the specification by the user. Here is a list of supported instructions:</p> Number of operands Major opcode Sub-opcode 1 Sub-opcode 2 Sub-opcode 3 3 <code>0x07</code> <code>0x00-0x2E</code>, <code>0x30-0x3f</code> \u2014 \u2014 2 <code>0x07</code> <code>0x2F</code> <code>0x00-0x3E</code> \u2014 1 <code>0x07</code> <code>0x2F</code> <code>0x3F</code> <code>0x00-0x3F</code> 0 <code>0x07</code> <code>0x2F</code> <code>0x3F</code> <code>0x00-0x3F</code>"},{"location":"advanced/custom-instructions/#three-operand-instructions","title":"Three-operand Instructions","text":"<p>Three-operand instructions have <code>op&lt;.cc&gt;&lt;.f&gt; a,b,c</code> syntax format, and it is the most general form of an ARC instruction:</p> <pre><code>op&lt;.f&gt; a,b,c\nop&lt;.f&gt; a,b,u6\nop&lt;.f&gt; b,b,s12\nop&lt;.cc&gt;&lt;.f&gt; b,b,c\nop&lt;.cc&gt;&lt;.f&gt; b,b,u6\nop&lt;.f&gt; a,limm,c\nop&lt;.f&gt; a,limm,u6\nop&lt;.f&gt; 0,limm,s12\nop&lt;.cc&gt;&lt;.f&gt; 0,limm,c\nop&lt;.cc&gt;&lt;.f&gt; 0,limm,u6\nop&lt;.f&gt; a,b,limm\nop&lt;.cc&gt;&lt;.f&gt; b,b,limm\nop&lt;.f&gt; a,limm,limm\nop&lt;.cc&gt;&lt;.f&gt; 0,limm,limm\nop&lt;.f&gt; 0,b,c\nop&lt;.f&gt; 0,b,u6\nop&lt;.f&gt; 0,limm,c\nop&lt;.f&gt; 0,limm,u6\nop&lt;.f&gt; 0,b,limm\nop&lt;.f&gt; 0,limm,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#two-operand-instructions","title":"Two-operand Instructions","text":"<p>Two-operand instructions have the following syntax format:</p> <pre><code>op&lt;.f&gt; b,c\nop&lt;.f&gt; b,u6\nop&lt;.f&gt; b,limm\nop&lt;.f&gt; 0,c\nop&lt;.f&gt; 0,u6\nop&lt;.f&gt; 0,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#one-operand-and-zero-operand-instructions","title":"One-operand and Zero-operand Instructions","text":"<p>One-operand instructions are having the following syntax format:</p> <pre><code>op&lt;.f&gt; c\nop&lt;.f&gt; u6\nop&lt;.f&gt; limm\n</code></pre> <p>Zero-operand instructions are actually has <code>op&lt;.f&gt; u6</code> one-operand instruction syntax, with <code>u6</code> set to zero.</p> <p>To create a custom instruction, ones need to make use of the <code>.extInstruction</code> pseudo-op, which also allows the user to choose for a particular instruction syntax:</p>"},{"location":"advanced/custom-instructions/#defining-custom-instructions","title":"Defining Custom Instructions","text":"<p><code>.extInstruction</code> pseudo-op is used to create a custom instruction. On top of the formal syntax choices, we have also syntax class modifiers:</p> <ul> <li><code>OP1_MUST_BE_IMM</code> which applies for <code>SYNTAX_3OP</code> type of extension instructions, specifying that the first   operand of a three-operand instruction must be an immediate (i.e., the result is discarded). This is   usually used to set the flags using specific instructions and not retain results.</li> <li><code>OP1_IMM_IMPLIED</code> modifies syntax class <code>SYNTAX_2OP</code>, specifying that there is an implied   immediate destination operand which does not appear in the syntax. In fact this is actually   an 3-operand encoded instruction!</li> </ul>"},{"location":"advanced/custom-instructions/#example-no1-three-operand-instruction","title":"Example \u21161. Three-operand instruction","text":"<p>Definitions of the instruction:</p> <pre><code>.extInstruction insn1, 0x07, 0x2d, SUFFIX_NONE, SYNTAX_3OP|OP1_MUST_BE_IMM\n</code></pre> <p>Using the instruction:</p> <pre><code>insn1  0,b,c\ninsn1  0,b,u6\ninsn1  0,limm,c\ninsn1  0,b,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#example-no2-two-operand-instruction","title":"Example \u21162. Two-operand instruction","text":"<p>Note</p> <p>The encoding of <code>insn2</code> uses the <code>SYNTAX_3OP</code> format (i.e., Major <code>0x07</code> and SubOpcode1: <code>0x00-0x2E</code>, <code>0x30-0x3F</code>)</p> <p>Definitions of the instruction:</p> <pre><code>.extInstruction insn2, 0x07, 0x2d, SUFFIX_NONE, SYNTAX_2OP|OP1_IMM_IMPLIED\n</code></pre> <p>Using the instruction:</p> <pre><code>insn2  b,c\ninsn2  b,u6\ninsn2  limm,c\ninsn2  b,limm\n</code></pre>"},{"location":"advanced/custom-instructions/#example-no3-all-variants","title":"Example \u21163. All Variants","text":"<p>Definitions of the instructions:</p> <pre><code>.extInstruction insn1, 7, 0x21, SUFFIX_NONE, SYNTAX_3OP\n.extInstruction insn2, 7, 0x21, SUFFIX_NONE, SYNTAX_2OP\n.extInstruction insn3, 7, 0x21, SUFFIX_NONE, SYNTAX_1OP\n.extInstruction insn4, 7, 0x21, SUFFIX_NONE, SYNTAX_NOP\n</code></pre> <p>Using the instruction:</p> <pre><code>start:\ninsn1   r0,r1,r2\ninsn2   r0,r1\ninsn3   r1\ninsn4\n</code></pre> <p>Disassembly of section <code>.text</code>:</p> <pre><code>0x0000 &lt;start&gt;:\n   0:   3921 0080               insn1   r0,r1,r2\n   4:   382f 0061               insn2   r0,r1\n   8:   392f 407f               insn3   r1\n   c:   396f 403f               insn4\n</code></pre>"},{"location":"advanced/custom-instructions/#support-in-gcc","title":"Support in GCC","text":""},{"location":"advanced/custom-instructions/#using-inline-functions","title":"Using Inline Functions","text":"<p>Define a macro for a two-operand custom instruction:</p> <pre><code>#define intrinsic_2OP(NAME, MOP, SOP)       \\\n    \".extInstruction \" NAME \",\" #MOP \",\"    \\\n    #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n</code></pre> <p>Instantiate the custom instruction:</p> <pre><code>__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n</code></pre> <p>Create an inline function:</p> <pre><code>__extension__ static __inline int32_t __attribute__ ((__always_inline__))\n__chk_pkt (int32_t __a)\n{\nint32_t __dst;\n__asm__ (\"chk_pkt %0, %1\\n\\t\"\n: \"=r\" (__dst)\n: \"rCal\" (__a));\nreturn __dst;\n}\n</code></pre> <p>Here is a full example:</p> <pre><code>#include &lt;stdint.h&gt;\n#define intrinsic_2OP(NAME, MOP, SOP)       \\\n    \".extInstruction \" NAME \",\" #MOP \",\"    \\\n    #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n__extension__ static __inline int32_t __attribute__ ((__always_inline__))\n__chk_pkt (int32_t __a)\n{\nint32_t __dst;\n__asm__ (\"chk_pkt %0, %1\\n\\t\"\n: \"=r\" (__dst)\n: \"rCal\" (__a));\nreturn __dst;\n}\nint foo (void)\n{\nreturn __chk_pkt (10);\n}\n</code></pre> <p>Here is an assembler translation:</p> <pre><code>     .file   \"t03.c\"\n.cpu HS\n.extInstruction chk_pkt,0x07,0x01,SUFFIX_NONE, SYNTAX_2OP\n.section        .text\n.align 4\n.global foo\n.type   foo, @function\nfoo:\n# 13 \"t03.c\" 1\nchk_pkt r0, 10\n# 0 \"\" 2\nj_s [blink]\n.size   foo, .-foo\n.ident  \"GCC: (ARCompact/ARCv2 ISA elf32 toolchain arc-2016.09-rc1-2-gb04a7b5) 6.2.1 20160824\"\n</code></pre>"},{"location":"advanced/custom-instructions/#using-defines-only","title":"Using Defines Only","text":"<p>Define a macro for a two-operand custom instruction in a header file:</p> <pre><code>#define intrinsic_2OP(NAME, MOP, SOP)       \\\n    \".extInstruction \" NAME \",\" #MOP \",\"    \\\n    #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n</code></pre> <p>Create an inline function:</p> <pre><code>__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n</code></pre> <p>Define a macro for the custom instruction to be used in C sources:</p> <pre><code>#define chk_pkt(src) ({long __dst;                        \\\n__asm__ (\"chk_pkt %0, %1\\n\\t\"                      \\\n: \"=r\" (__dst)                              \\\n: \"rCal\" (src));                            \\\n__dst;})\n</code></pre> <p>Use the custom instruction in C-sources:</p> <pre><code>result = chk_pkt(deltachk);\n</code></pre> <p>Here is a full content of the header file:</p> <pre><code>#ifndef _EXT_INSTRUCTIONS_H_\n#define _EXT_INSTRUCTIONS_H_\n#define intrinsic_2OP(NAME, MOP, SOP)                                        \\\n    \".extInstruction \" NAME \",\" #MOP \",\" #SOP \",SUFFIX_NONE, SYNTAX_2OP\\n\\t\"\n__asm__ (intrinsic_2OP (\"chk_pkt\", 0x07, 0x01));\n#define chk_pkt(src) ({long __dst;                   \\\n        __asm__ (\"chk_pkt %0, %1\\n\\t\"                \\\n          : \"=r\" (__dst)                             \\\n          : \"rCal\" (src));                           \\\n         __dst;})\n#endif /* _EXT_INSTRUCTIONS_H_ */\n</code></pre>"},{"location":"advanced/intrinsics/","title":"Intrinsics","text":"<p>GCC supports a number of built-in functions for ARC targets. Documentation for them may be found in the official manual.</p> <p>All ARC built-ins are stored in <code>arcle.h</code> header file:</p> <pre><code>#include &lt;arcle.h&gt;\n</code></pre> <p>Here is comparison table for MetaWare andd GCC compilers regarding support of intrinsics:</p> MetaWare GCC <code>_abss</code> <code>_abss</code> <code>_abssh</code> <code>_abssh</code> <code>_adcs</code> <code>_adcs</code> <code>_add</code> Not planned <code>_add1</code> Not planned <code>_add1_f</code> Not planned <code>_add2</code> Not planned <code>_add2_f</code> Not planned <code>_add3</code> Not planned <code>_add3_f</code> Not planned <code>_add_f</code> Not planned <code>_adds</code> <code>_adds</code> <code>_adds_f</code> Not planned <code>_aex</code> Unsupported <code>_and</code> Not planned <code>_and_f</code> Not planned <code>_asl</code> Not planned <code>_asl_f</code> Not planned <code>_aslacc</code> <code>_aslacc</code> <code>_asls</code> <code>_asls</code> <code>_asls_f</code> Not planned <code>_aslsacc</code> <code>_aslsacc</code> <code>_asr</code> Not planned <code>_asr_f</code> Not planned <code>_asrs</code> <code>_asrs</code> <code>_asrs_f</code> Not planned <code>_asrsr</code> <code>_asrsr</code> <code>_asrsr_f</code> Not planned <code>_bclr</code> Not planned <code>_bclr_f</code> Not planned <code>_bmsk</code> Not planned <code>_bmsk_f</code> Not planned <code>_bset</code> Not planned <code>_bset_f</code> Not planned <code>_btst_f</code> Not planned <code>_bxor</code> Not planned <code>_bxor_f</code> Not planned <code>_cbflyhf0r</code> <code>_cbflyhf0r</code> <code>_cbflyhf1r</code> <code>_cbflyhf1r</code> <code>_cmacchfr</code> <code>_cmacchfr</code> <code>_cmacchnfr</code> <code>_cmacchnfr</code> <code>_cmachfr</code> <code>_cmachfr</code> <code>_cmachnfr</code> <code>_cmachnfr</code> <code>_cmpychfr</code> <code>_cmpychfr</code> <code>_cmpychnfr</code> <code>_cmpychnfr</code> <code>_cmpyhfmr</code> <code>_cmpyhfmr</code> <code>_cmpyhfr</code> <code>_cmpyhfr</code> <code>_cmpyhnfr</code> <code>_cmpyhnfr</code> <code>_divf</code> <code>_divf</code> <code>_dmach</code> <code>_dmach</code> <code>_dmachbl</code> <code>_dmachbl</code> <code>_dmachbm</code> <code>_dmachbm</code> <code>_dmachf</code> <code>_dmachf</code> <code>_dmachfr</code> <code>_dmachfr</code> <code>_dmachu</code> <code>_dmachu</code> <code>_dmacwh</code> <code>_dmacwh</code> <code>_dmacwhf</code> <code>_dmacwhf</code> <code>_dmacwhu</code> <code>_dmacwhu</code> <code>_dmpyh</code> <code>_dmpyh</code> <code>_dmpyhbl</code> <code>_dmpyhbl</code> <code>_dmpyhbm</code> <code>_dmpyhbm</code> <code>_dmpyhf</code> <code>_dmpyhf</code> <code>_dmpyhfr</code> <code>_dmpyhfr</code> <code>_dmpyhu</code> <code>_dmpyhu</code> <code>_dmpyhwf</code> <code>_dmpyhwf</code> <code>_dmpywh</code> <code>_dmpywh</code> <code>_dmpywhf</code> <code>_dmpywhf</code> <code>_dmpywhu</code> <code>_dmpywhu</code> <code>_ex</code> Unsupported <code>_ex_di</code> Unsupported <code>_ffs</code> Unsupported <code>_flagacc</code> <code>_flagacc</code> <code>_fls</code> Unsupported <code>_getacc</code> <code>_getacc</code> <code>_kflag</code> <code>_kflag</code> <code>_lr</code> <code>_lr</code> <code>_lsr</code> Not planned <code>_lsr_f</code> Not planned <code>_mac</code> <code>_mac</code> <code>_macd</code> <code>_macd</code> <code>_macdf</code> <code>_macdf</code> <code>_macdu</code> <code>_macdu</code> <code>_macf</code> <code>_macf</code> <code>_macfr</code> <code>_macfr</code> <code>_macu</code> <code>_macu</code> <code>_macwhfl</code> <code>_macwhfl</code> <code>_macwhflr</code> <code>_macwhflr</code> <code>_macwhfm</code> <code>_macwhfm</code> <code>_macwhfmr</code> <code>_macwhfmr</code> <code>_macwhkl</code> <code>_macwhkl</code> <code>_macwhkul</code> <code>_macwhkul</code> <code>_macwhl</code> <code>_macwhl</code> <code>_macwhul</code> <code>_macwhul</code> <code>_max_f</code> Not planned <code>_min_f</code> Not planned <code>_modif</code> Not planned <code>_mov_f</code> Not planned <code>_mpy</code> Not planned <code>_mpyd</code> Not planned <code>_mpydf</code> <code>_mpydf</code> <code>_mpydu</code> Not planned <code>_mpyf</code> <code>_mpyf</code> <code>_mpyfr</code> <code>_mpyfr</code> <code>_mpym</code> Not planned <code>_mpymu</code> Not planned <code>_mpyu</code> Not planned <code>_mpywhfl</code> <code>_mpywhfl</code> <code>_mpywhflr</code> <code>_mpywhflr</code> <code>_mpywhfm</code> <code>_mpywhfm</code> <code>_mpywhfmr</code> <code>_mpywhfmr</code> <code>_mpywhkl</code> <code>_mpywhkl</code> <code>_mpywhkul</code> <code>_mpywhkul</code> <code>_mpywhl</code> <code>_mpywhl</code> <code>_mpywhul</code> <code>_mpywhul</code> <code>_msubdf</code> <code>_msubdf</code> <code>_msubf</code> <code>_msubf</code> <code>_msubfr</code> <code>_msubfr</code> <code>_msubwhfl</code> <code>_msubwhfl</code> <code>_msubwhflr</code> <code>_msubwhflr</code> <code>_msubwhfm</code> <code>_msubwhfm</code> <code>_msubwhfmr</code> <code>_msubwhfmr</code> <code>_negs</code> <code>_negs</code> <code>_negs_f</code> Not planned <code>_negsh</code> <code>_negsh</code> <code>_negsh_f</code> Not planned <code>_norm</code> Not planned <code>_norm_f</code> Not planned <code>_normacc</code> <code>_normacc</code> <code>_normh</code> Not planned <code>_normh_f</code> Not planned <code>_normw</code> Not planned <code>_normw_f</code> Not planned <code>_or</code> Not planned <code>_or_f</code> Not planned <code>_qmach</code> <code>_qmach</code> <code>_qmachf</code> <code>_qmachf</code> <code>_qmachu</code> <code>_qmachu</code> <code>_qmpyh</code> <code>_qmpyh</code> <code>_qmpyhf</code> <code>_qmpyhf</code> <code>_qmpyhu</code> <code>_qmpyhu</code> <code>_rndh</code> <code>_rndh</code> <code>_rndh_f</code> Not planned <code>_ror</code> Not planned <code>_ror_f</code> Not planned <code>_rrc</code> Not planned <code>_rrc_f</code> Not planned <code>_satf</code> <code>_satf</code> <code>_sath</code> <code>_sath</code> <code>_sath_f</code> Not planned <code>_sbcs</code> <code>_sbcs</code> <code>_setacc</code> <code>_setacc</code> <code>_sqrt</code> <code>_sqrt</code> <code>_sqrtf</code> <code>_sqrtf</code> <code>_sr</code> <code>_sr</code> <code>_sub</code> Not planned <code>_sub1</code> Not planned <code>_sub1_f</code> Not planned <code>_sub2</code> Not planned <code>_sub2_f</code> Not planned <code>_sub3</code> Not planned <code>_sub3_f</code> Not planned <code>_sub_f</code> Not planned <code>_subs</code> <code>_subs</code> <code>_subs_f</code> Not planned <code>_trap</code> <code>_trap</code> <code>_vabs2h</code> <code>_vabs2h</code> <code>_vabss2h</code> <code>_vabss2h</code> <code>_vadd2</code> <code>_vadd2</code> <code>_vadd2h</code> <code>_vadd2h</code> <code>_vadd4b</code> <code>_vadd4b</code> <code>_vadd4h</code> <code>_vadd4h</code> <code>_vadds2</code> <code>_vadds2</code> <code>_vadds2h</code> <code>_vadds2h</code> <code>_vadds4h</code> <code>_vadds4h</code> <code>_vaddsub</code> <code>_vaddsub</code> <code>_vaddsub2h</code> <code>_vaddsub2h</code> <code>_vaddsub4h</code> <code>_vaddsub4h</code> <code>_vaddsubs</code> <code>_vaddsubs</code> <code>_vaddsubs2h</code> <code>_vaddsubs2h</code> <code>_vaddsubs4h</code> <code>_vaddsubs4h</code> <code>_valgn2h</code> <code>_valgn2h</code> <code>_vasl2h</code> <code>_vasl2h</code> <code>_vasls2h</code> <code>_vasls2h</code> <code>_vasr2h</code> <code>_vasr2h</code> <code>_vasrs2h</code> <code>_vasrs2h</code> <code>_vasrsr2h</code> <code>_vasrsr2h</code> <code>_vext2bhl</code> <code>_vext2bhl</code> <code>_vext2bhlf</code> <code>_vext2bhlf</code> <code>_vext2bhm</code> <code>_vext2bhm</code> <code>_vext2bhmf</code> <code>_vext2bhmf</code> <code>_vlsr2h</code> <code>_vlsr2h</code> <code>_vmac2h</code> <code>_vmac2h</code> <code>_vmac2hf</code> <code>_vmac2hf</code> <code>_vmac2hfr</code> <code>_vmac2hfr</code> <code>_vmac2hnfr</code> <code>_vmac2hnfr</code> <code>_vmac2hu</code> <code>_vmac2hu</code> <code>_vmax2h</code> <code>_vmax2h</code> <code>_vmin2h</code> <code>_vmin2h</code> <code>_vmpy2h</code> <code>_vmpy2h</code> <code>_vmpy2hf</code> <code>_vmpy2hf</code> <code>_vmpy2hfr</code> <code>_vmpy2hfr</code> <code>_vmpy2hu</code> <code>_vmpy2hu</code> <code>_vmpy2hwf</code> <code>_vmpy2hwf</code> <code>_vmsub2hf</code> <code>_vmsub2hf</code> <code>_vmsub2hfr</code> <code>_vmsub2hfr</code> <code>_vmsub2hnfr</code> <code>_vmsub2hnfr</code> <code>_vneg2h</code> <code>_vneg2h</code> <code>_vnegs2h</code> <code>_vnegs2h</code> <code>_vnorm2h</code> <code>_vnorm2h</code> <code>_vpack2hbl</code> <code>_vpack2hbl</code> <code>_vpack2hblf</code> <code>_vpack2hblf</code> <code>_vpack2hbm</code> <code>_vpack2hbm</code> <code>_vpack2hbmf</code> <code>_vpack2hbmf</code> <code>_vpack2hl</code> <code>_vpack2hl</code> <code>_vpack2hm</code> <code>_vpack2hm</code> <code>_vperm</code> <code>_vperm</code> <code>_vrep2hl</code> <code>_vrep2hl</code> <code>_vrep2hm</code> <code>_vrep2hm</code> <code>_vsext2bhl</code> <code>_vsext2bhl</code> <code>_vsext2bhm</code> <code>_vsext2bhm</code> <code>_vsub2</code> <code>_vsub2</code> <code>_vsub2h</code> <code>_vsub2h</code> <code>_vsub4b</code> <code>_vsub4b</code> <code>_vsub4h</code> <code>_vsub4h</code> <code>_vsubadd</code> <code>_vsubadd</code> <code>_vsubadd2h</code> <code>_vsubadd2h</code> <code>_vsubadd4h</code> <code>_vsubadd4h</code> <code>_vsubadds</code> <code>_vsubadds</code> <code>_vsubadds2h</code> <code>_vsubadds2h</code> <code>_vsubadds4h</code> <code>_vsubadds4h</code> <code>_vsubs2</code> <code>_vsubs2</code> <code>_vsubs2h</code> <code>_vsubs2h</code> <code>_vsubs4h</code> <code>_vsubs4h</code> <code>_wevt</code> Unsupported"},{"location":"advanced/jli/","title":"JLI Instructions","text":""},{"location":"advanced/jli/#overview","title":"Overview","text":"<p>The ARCv2 ISA provides the JLI instruction, which is two-byte instructions that can be used to reduce code size for an application. To make use of it, we provide two new function attributes <code>jli_always</code> and <code>jli_fixed</code> which will force the compiler to call the indicated function using a <code>jli_s</code> instruction. The compiler also generates the entries in the JLI table for the case when we use <code>jli_always</code> attribute. In the case of <code>jli_fixed</code> the compiler assumes a fixed position of the function in JLI table. Thus, the user needs to provide an assembly file with the JLI table for the final link. This is useful when we want to have a table in ROM and a second table in the RAM memory.</p> <p>The jli instruction usage can be also forced without the need to annotate the source code via <code>-mjli-always</code> command.</p>"},{"location":"advanced/jli/#using-jli-attributes","title":"Using JLI Attributes","text":"<p>The usual way of using jli calls is to use the attribute <code>jli_always</code> with a function. For example:</p> <pre><code>int func (int i) __attribute__((jli_always));\nint func (int i) {\nreturn i*i;\n}\nint main ()\n{\nprintf (\"func returned = %d \\n\", func (100));\nreturn 0;\n}\n</code></pre> <p>Here is an assembler translation:</p> <pre><code>main:\npush_s blink\nst.a fp,[sp,-4] ;28\nmov_s fp,sp     ;4\nmov_s r0,100    ;3\njli_s @__jli.func\nmov_s r2,r0     ;4\nmov_s r1,r2     ;4\nmov_s r0,@.LC0  ;14\nbl @printf;1\nmov_s r2,0      ;3\nmov_s r0,r2     ;4\nld.ab fp,[sp,4] ;25\npop_s blink\nj_s [blink]\n</code></pre> <p>As we can see the call to func is done via the <code>jli_s</code> instruction, while the other calls are done using regular <code>bl</code> instruction. If we want all calls to non-local functions to be done using <code>jli_s</code> then we can use <code>-mjli-always</code> compiler option. However, we need to be careful in using this option as the JLI table can hold only 1024 entries. The compiler cannot efficiently check the number of entries as it only has a limited view over the whole application. In this case the GNU tool takes care of generating the JLI table, patching the <code>jli_s</code> instruction with the correct entry number corresponding to the called function, and the initialization of the <code>jli_base</code> auxiliary register.</p> <p>A special way to use the <code>jli_s</code> instruction is for ROM patching. Because with the <code>jli_s</code> instruction function calls are made indirectly through the JLI table, the JLI table entries can be changed to invoke alternative functions without affecting the executable code. Thus, in this case the location of each function called via jli instruction must be fixed and known at compile time. To achieve this, we have introduced a new <code>jli_fixed</code> function attribute which accept a numerical parameter to specify the function call entry in the JLI table. This attribute is GNU specific.</p> <p>Consider the following example:</p> <pre><code>int func (int i) __attribute__((jli_fixed(2)));\nint func (int i)\n{\nreturn i*i;\n}\nint main ()\n{\nprintf (\"func returned = %d \\n\", func (100));\nreturn 0;\n}\n</code></pre> <p>Here is an assembler translation:</p> <pre><code>main:\npush_s blink\nst.a fp,[sp,-4] ;28\nmov_s fp,sp     ;4\nmov_s r0,100    ;3\njli_s 2 ; @func\nmov_s r2,r0     ;4\nmov_s r1,r2     ;4\nmov_s r0,@.LC0  ;14\nbl @printf;1\nmov_s r2,0      ;3\nmov_s r0,r2     ;4\nld.ab fp,[sp,4] ;25\npop_s blink\nj_s [blink]\n</code></pre> <p>As we can see now, the operand of <code>jli_s</code> instruction is already resolved and points to entry 2 in the JLI table. In this case, the compiler does not generate the JLI table, as it needs to be provided by the user. A JLI table can be something like this:</p> <pre><code>.section .jlitab\n.align  4\nJLI_table:\n__jli.entry0:   b       entry0  ; 0\n__jli.entry1:   b       entry1  ; 1\n__jli.func:     b       func    ; 2\n</code></pre> <p>The initialization of the <code>jli_base</code> is again done by the <code>crt0</code>. However, in the case of RAM/ROM patching, one may want to overwrite the initial value with a new value based on the location of a patched JLI table. N.B. the RAM/ROM patching approach may require special startup and/or linker scripts which are not provided.</p>"},{"location":"advanced/jli/#compatibility-with-metaware","title":"Compatibility with MetaWare","text":"<p>In general the GNU JLI implementation is compatible with MWDT implementation, except for the code that invokes the MetaWare runtime initialization code that sets the <code>JLI_BASE</code> register to address the JLI table. GNU additionally introduces the <code>jli_fixed</code> attribute to closely mimic the MWDT <code>jli_call_fixed</code> pragma.</p>"},{"location":"advanced/optimizations/","title":"Optimization Options","text":"<p>There are cases when using solely the <code>-Ox</code> options will not bring the desired optimization (either size or speed) for a compiled function/application. In these cases we need to understand where is the program\u2019s bottleneck and if it can be solved either by passing various options to the compiler or by source code modifications. In this section, we look into compiler\u2019s command-line options and how they can help us in achieving better results.</p>"},{"location":"advanced/optimizations/#architecture-independent-optimizations","title":"Architecture-Independent Optimizations","text":"<p>The first step in optimizing your code is by experimenting with architecture-independent optimizations. Almost any GCC pass (i.e., optimization) can be turned on or off or steered using parameters. These optimizations are denoted by the notation <code>-fxxxx</code>, where <code>xxxx</code> is the GCC pass that is turned on. To turn off a gcc pass, we need to pass <code>-fno-xxxx</code> to the compiler. The same observation holds for other types of optimizations such as the architecture-specific ones. For more information about GCC options, please check the GCC manual. It is highly desirable to know and understand how these options work in order to properly use them.</p> <p>Here is a list of most reasonable options:</p> <code>-ftree-loop-ivcanon</code> <p>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</p> <code>-ftree-vectorize</code> <p>Perform loop vectorization on trees. This flag is enabled by default at <code>-O3</code>. This option is useful to use either if the ARC processor does not have the SIMD extensions as it performs extra code analysis and may improve the following optimizations.</p> <code>-ftree-loop-if-convert</code> <p>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</p> <code>-f[no-]tree-dominator-opts</code> <p>Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps). This flag is enabled by default at <code>-O</code> and higher.</p> <code>-f(no-)ivopts</code> <p>Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees. Disabling the <code>ivopts</code> optimization may improve the number of hardware loops recognized by the compiler.</p> <code>-fselective-scheduling</code> <p>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the first scheduler pass.</p> <code>-fgcse</code> <p>Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation. It may be useful to disable this step specially when we want to have more <code>SUB1/2/3</code>, <code>ADD1/2/3</code> type of operations generated.</p> <code>-frename-registers</code> <p>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a \"home register\". Enabled by default with <code>-funroll-loops</code> and <code>-fpeel-loops</code>.</p> <code>-fira-loop-pressure</code> <p>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&gt;= 32 registers), but it can slow the compiler down.</p> <code>-fsched-pressure</code> <p>Enable register pressure sensitive instruction scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with <code>-fschedule-insns</code>. Usage of this option can improve the generated code and decrease its size by preventing register pressure increase above the number of available hard registers and subsequent spills in register allocation.</p> <code>-f[no-]regmove</code> <p>Attempt to reassign register numbers in move instructions and as operands of other simple instructions in order to maximize the amount of register tying. This is especially helpful on machines with two-operand instructions. Disabling this optimization may result in faster code.</p>"},{"location":"advanced/optimizations/#optimizations-for-code-size","title":"Optimizations for Code Size","text":"<p>If code size is our target, beside the GCC's <code>-Os</code> option, it may make sense to use it in conjunction with following command-line options:</p> <ul> <li><code>-fsection-anchors</code></li> <li><code>-fno-branch-count-reg</code></li> <li><code>-fira-loop-pressure</code></li> <li><code>-fira-region=all</code></li> <li><code>-fno-sched-spec-insn-heuristic</code></li> <li><code>-fno-move-loop-invariants</code></li> <li><code>-fno-tree-dominator-opts</code></li> <li><code>-ftree-vectorize</code></li> <li><code>-fno-cse-follow-jumps</code></li> <li><code>-fno-jump-tables</code></li> </ul>"},{"location":"advanced/optimizations/#optimization-for-speed","title":"Optimization for Speed","text":"<p>If the cycle count is our target, the best is to start with <code>-O2</code> option then with <code>-O3</code> and for each compiler optimization level to combine one or more of the suggested GCC command-line options. Finally, gather and compare runtime performance and size for each command-line combination. Consider plotting these numbers on a 2D graph, where one axis will represent the cycle count, and the other will represent the size. Hence, we can choose the best combination size/speed for a given problem.</p> <p>If one wants to try a large number of option combinations, then an automatic scripting process is required. One of those tools that searches through more than 1.3 zillion gcc option combination is <code>Acovea</code>. <code>Acovea</code> is using genetic algorithms to search for the best option combination for a given program. However, one can make an script that uses only the suggested gcc options to search for the best combination by exhaustively generating (most) of the option combinations.</p>"},{"location":"advanced/optimizations/#using-optimize-attribute","title":"Using <code>optimize</code> attribute","text":"<p>In GNU C, you declare certain things about functions called in your program which help the compiler optimize function calls and check your code more carefully. In the case when we want a certain function/kernel not to change its speed/size characteristics, we can use the <code>optimize</code> function attribute. The <code>optimize</code> attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Arguments can either be numbers or strings. Numbers are assumed to be an optimization level. Strings that begin with O are assumed to be an optimization option, while other options are assumed to be used with a <code>-f</code> prefix.</p>"},{"location":"advanced/optimizations/#default-arc-optimizations","title":"Default ARC Optimizations","text":"Opitimization <code>-O0</code> <code>-O1</code> <code>-Os</code> <code>-O2</code> <code>-O3</code> <code>-fomit-frame-pointer</code> On On On On <code>-fschedule-insns</code> On On On On <code>-fschedule-insns2</code> On On On On <code>-mearly-cbranchsi</code> On On On On On <code>-mbbit-peephole</code> On On On On On <code>-mcase-vector-pcrel</code> On <code>-mcompact-casesi</code> On"},{"location":"advanced/optimizations/#default-arc-parameters","title":"Default ARC Parameters","text":"Parameter Value <code>simultaneous-prefetches</code> 4 <code>prefetch-latency</code> 4 <code>l1-cache-line-size</code> 64"},{"location":"advanced/sanitizers/","title":"Sanitizers","text":""},{"location":"advanced/sanitizers/#overview","title":"Overview","text":"<p>Sanitizers functionality is available for ARC. Support for the sanitizers is limited for Linux, when running with glibc (GNU C Library).</p> <p>ARC supports the following sanitizers:</p> <ul> <li>Address</li> <li>Memory</li> <li>Undefined behavior</li> <li>Leak sanitizers</li> </ul>"},{"location":"advanced/sanitizers/#addresssanitizer","title":"AddressSanitizer","text":"<p>AddressSanitizer is a fast memory error detector. It consists of a compiler instrumentation module and a run-time library. Typical slowdown introduced by AddressSanitizer is 2x. The tool can detect the following types of bugs:</p> <ul> <li>Out-of-bounds accesses to heap, stack and globals</li> <li>Use-after-free</li> <li>Use-after-return (runtime flag <code>ASAN_OPTIONS=detect_stack_use_after_return=1</code>)</li> <li>Use-after-scope (clang flag <code>-fsanitize-address-use-after-scope</code>)</li> <li>Double-free, invalid free</li> <li>Memory leaks (experimental)</li> </ul>"},{"location":"advanced/sanitizers/#memorysanitizer","title":"MemorySanitizer","text":"<p>MemorySanitizer is a detector of uninitialized reads. It consists of a compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is 3x.</p>"},{"location":"advanced/sanitizers/#undefinedbehaviorsanitizer","title":"UndefinedBehaviorSanitizer","text":"<p>UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector. UBSan modifies the program at compile-time to catch various kinds of undefined behavior during program execution, for example:</p> <ul> <li>Using misaligned or null pointer.</li> <li>Signed integer overflow.</li> <li>Conversion to, from, or between floating-point types which would overflow the destination.</li> <li>See the full list of available checks below.</li> </ul> <p>UBSan has an optional run-time library which provides better error reporting. The checks have small runtime cost and no impact on address space layout or ABI.</p>"},{"location":"advanced/sanitizers/#leaksanitizer","title":"LeakSanitizer","text":"<p>LeakSanitizer is a run-time memory leak detector. It can be combined with AddressSanitizer to get both memory error and leak detection, or used in a stand-alone mode. LSan adds almost no performance overhead until the very end of the process, at which point there is an extra leak detection phase.</p> <p>We included in this document a few example as reference to the use of the sanitizers. For a clearer view of how to use the sanitizers, or further examples, please refer to Clang documentation</p>"},{"location":"advanced/sanitizers/#examples-for-x86","title":"Examples for x86","text":""},{"location":"advanced/sanitizers/#heap-use-after-free","title":"Heap-use-after-free","text":"<pre><code>// To compile: clang++ -O -g -fsanitize=address heap-use-after-free.cc\nint main(int argc, char **argv) {\nint *array = new int[100];\ndelete [] array;\nreturn array[argc];  // BOOM\n}\n</code></pre> <pre><code>$ ./a.out\n==5587==ERROR: AddressSanitizer: heap-use-after-free on address 0x61400000fe44 at pc 0x47b55f bp 0x7ffc36b28200\n sp 0x7ffc36b281f8\nREAD of size 4 at 0x61400000fe44 thread T0\n    #0 0x47b55e in main /home/test/example_UseAfterFree.cc:7\n    #1 0x7f15cfe71b14 in __libc_start_main (/lib64/libc.so.6+0x21b14)\n    #2 0x47b44c in _start (/root/a.out+0x47b44c)\n\n0x61400000fe44 is located 4 bytes inside of 400-byte region [0x61400000fe40,0x61400000ffd0)\nfreed by thread T0 here:\n    #0 0x465da9 in operator delete[](void*) (/root/a.out+0x465da9)\n    #1 0x47b529 in main /home/test/example_UseAfterFree.cc:6\n\npreviously allocated by thread T0 here:\n    #0 0x465aa9 in operator new[](unsigned long) (/root/a.out+0x465aa9)\n    #1 0x47b51e in main /home/test/example_UseAfterFree.cc:5\n\nSUMMARY: AddressSanitizer: heap-use-after-free /home/test/example_UseAfterFree.cc:7 main\nShadow bytes around the buggy address:\n  0x0c287fff9f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9f80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9f90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9fa0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fff9fb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=&gt;0x0c287fff9fc0: fa fa fa fa fa fa fa fa[fd]fd fd fd fd fd fd fd\n  0x0c287fff9fd0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c287fff9fe0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c287fff9ff0: fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa fa\n  0x0c287fffa000: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c287fffa010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:     fa\n  Heap right redzone:    fb\n  Freed heap region:     fd\n  Stack left redzone:    f1\n  Stack mid redzone:     f2\n  Stack right redzone:   f3\n  Stack partial redzone: f4\n  Stack after return:    f5\n  Stack use after scope: f8\n  Global redzone:        f9\n  Global init order:     f6\n  Poisoned by user:      f7\n  ASan internal:         fe\n==5587==ABORTING\n</code></pre>"},{"location":"advanced/sanitizers/#heap-buffer-overflow","title":"Heap-buffer-overflow","text":"<pre><code>// RUN: clang++ -O -g -fsanitize=address %t &amp;&amp; ./a.out\nint main(int argc, char **argv) {\nint *array = new int[100];\narray[0] = 0;\nint res = array[argc + 100];  // BOOM\ndelete [] array;\nreturn res;\n}\n</code></pre> <pre><code>==25372==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x61400000ffd4 at pc 0x0000004ddb59 bp 0x7fffea6005a0 sp 0x7fffea600598\nREAD of size 4 at 0x61400000ffd4 thread T0\n    #0 0x46bfee in main /tmp/main.cpp:4:13\n\n0x61400000ffd4 is located 4 bytes to the right of 400-byte region\n[0x61400000fe40,0x61400000ffd0)\nallocated by thread T0 here:\n    #0 0x4536e1 in operator delete[](void*)\n    #1 0x46bfb9 in main /tmp/main.cpp:2:16\n</code></pre>"},{"location":"advanced/sanitizers/#stack-buffer-overflow","title":"Stack-buffer-overflow","text":"<pre><code>// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out\nint main(int argc, char **argv) {\nint stack_array[100];\nstack_array[1] = 0;\nreturn stack_array[argc + 100];  // BOOM\n}\n</code></pre> <pre><code>==7405==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff64740634 at pc 0x46c103 bp 0x7fff64740470 sp 0x7fff64740468\nREAD of size 4 at 0x7fff64740634 thread T0\n    #0 0x46c102 in main /tmp/example_StackOutOfBounds.cc:5\n\nAddress 0x7fff64740634 is located in stack of thread T0 at offset 436 in frame\n    #0 0x46bfaf in main /tmp/example_StackOutOfBounds.cc:2\n\n  This frame has 1 object(s):\n        [32, 432) 'stack_array' &lt;== Memory access at offset 436 overflows this variable\n</code></pre>"},{"location":"advanced/sanitizers/#global-buffer-overflow","title":"Global-buffer-overflow","text":"<pre><code>// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out\nint global_array[100] = {-1};\nint main(int argc, char **argv) {\nreturn global_array[argc + 100];  // BOOM\n}\n</code></pre> <pre><code>==7455==ERROR: AddressSanitizer: global-buffer-overflow on address 0x000000689b54 at pc 0x46bfd8 bp 0x7fff515e5ba0 sp 0x7fff515e5b98\nREAD of size 4 at 0x000000689b54 thread T0\n    #0 0x46bfd7 in main /tmp/example_GlobalOutOfBounds.cc:4\n\n0x000000689b54 is located 4 bytes to the right of\n  global variable 'global_array' from 'example_GlobalOutOfBounds.cc' (0x6899c0) of size 400\n</code></pre>"},{"location":"advanced/secure-shield/","title":"SecureShield Programming","text":""},{"location":"advanced/secure-shield/#secureshield-api","title":"SecureShield API","text":"<p>A secure-callable API is a set of functions executing in secure mode that can be called from code executing in normal mode. The processor contains a special function call instruction, SJLI, that the compiler uses to implement a secure-mode API. This instruction transfers execution from normal mode to secure mode. Any other call or jump into secure mode from normal mode results in a processor exception.</p> <p>The GNU tools support a secure-callable API with a two-executable approach:</p> <ul> <li>One linked executable contains the secure-mode code;</li> <li>The second linked executable contains the normal-mode code.</li> </ul> <p>The normal-mode code is compiled normally - no special code is generated for calls to the secure-mode API. However, such calls are resolved by the linker in the normal executable with special function entry points that transfer control to the normal executable using the SJLI instruction. In the secure-mode executable, functions that are designate as belonging to the secure API need an index into the SJLI table. Also the runtime initialization for the secure-mode needs to be carried on by the user.</p>"},{"location":"advanced/secure-shield/#identifying-the-secure-callable-apis","title":"Identifying the Secure-Callable APIs","text":"<p>To indicate to the compiler that a secure-mode function is callable from normal mode, you can use <code>__attribute__((secure_call (IndexNumber)))</code> with secure-callable function. Where <code>IndexNumber</code> is the entry of that particular function into the SJLI table.</p>"},{"location":"advanced/secure-shield/#programming-cautions","title":"Programming Cautions","text":"<p>Using function pointer of a secure call function is not supported. However, one can make a stub which can be called indirectly, the stub itself calls the secure call normally.</p>"},{"location":"advanced/secure-shield/#example","title":"Example","text":"<p>Let us consider the following example:</p> <pre><code>#include &lt;stdio.h&gt;\nextern int foo (int) __attribute__((secure_call(2)));\nint bar (void)\n{\nprintf (\"%d\\n\", foo (100));\nreturn 0;\n}\nint bar2 (void)\n{\nreturn foo(100);\n}\n</code></pre> <p>Where function <code>foo()</code> is an external secure function located at index 2 in the SJLI table.</p> <p>The result is:</p> <pre><code>.cpu EM\n.section .rodata.str1.4,\"aMS\",@progbits,1\n.align 4\n.LC0:\n.string \"%d\\n\"\n.section    .text\n.align 4\n.global bar\n.type   bar, @function\nbar:\npush_s blink\nmov_s r0,100    ;3\nsjli  2 ; @foo\nmov_s r1,r0 ;4\nmov_s r0,@.LC0  ;14\nbl @printf;1\npop_s blink\nj_s.d [blink]\nmov_s r0,0  ;3\n.size   bar, .-bar\n.align 4\n.global bar2\n.type   bar2, @function\nbar2:\npush_s blink\nmov_s r0,100    ;3\nsjli  2 ; @foo\npop_s blink\nj_s [blink]\n.size  bar2, .-bar2\n</code></pre> <p>Where, we can easily spot the call to <code>foo()</code> function via <code>SJLI</code> instruction.</p>"},{"location":"advanced/small-data/","title":"Small Data Sections","text":"<p>Warning</p> <p>These articles is applicable to ARC GCC starting only with 2017.09 release.</p>"},{"location":"advanced/small-data/#small-data-available-access-range","title":"Small Data Available Access Range","text":"Data type Range Number of elements Size <code>char</code> [-256, 255] 512 512 bytes <code>short</code> [-256, 510] 383 766 bytes <code>int</code> [-256, 1020] 319 1276 bytes <p>The lower limit depends on the possibility to access byte-aligned datum, hence, it is hard connected to the range of <code>s9</code> short immediate (i.e., -256). Any other access can be done using address-scaling feature of the load/store instructions.</p> <p>The number of elements which we can fit in <code>sdata</code> section highly depends on the data alignment properties. For example if we use only 4 byte datum, 1 byte aligned, we can fit up to 128 elements in the section.</p>"},{"location":"advanced/small-data/#address-scaling-mode","title":"Address Scaling Mode","text":"<p>To increase the access range for small data area, the compiler uses scaled addresses whenever it is possible. Thus, we can extend theoretically this range to [-1024, 1020] for 32-bit data (e.g., <code>int</code>) if type aligned (i.e., 4-bytes). However, as we cannot be 100% sure that we address only 32-bit/4-byte aligned data, we need to consider the worst case which is byte-aligned data. Thus, the effective range is [-256, 255], with possibilities to access 16-bit aligned data (e.g., <code>short</code>) up to 510, and 32-bit aligned data (e.g., <code>int</code> or <code>long long</code>) up to 1020. While the lower limit remains -256. This is because we set the linker script defined variable <code>__SDATA_BEGIN__</code> with an offset of <code>0x100</code>. However, this rule can be overwritten by using a custom linker script.</p>"},{"location":"advanced/small-data/#storing-global-data-in-small-data-section","title":"Storing Global Data in Small Data Section","text":"<p>Global data smaller than a given number in bytes can be placed into the <code>sdata</code> section. The number of bytes can be controlled via <code>-G&lt;number&gt;</code> option. For ARC, by default this number is set to 8 whenever we have double load/store operations available (i.e., ARC HS architecture), otherwise to 4.</p> <p>For example, a 8 bytes setting will allow us to place into <code>sdata</code> the following variables:</p> <pre><code>char gA[8];\nshort gB[4];\nint gC[2];\nlong long gD;\n</code></pre> <p>Notable exceptions:</p> <ul> <li>Volatile global data will not be placed into <code>sdata</code> section when   <code>-mno-volatile-cache</code> option is used.</li> <li>Strings and functions never end in small data area.</li> <li>Weak variables as well not.</li> <li>No constant will end in small data area as those one, we would like to place into ROM.</li> </ul>"},{"location":"advanced/small-data/#using-named-sections","title":"Using Named Sections","text":"<p>Another way to control which data goes into small data area is to use named sections like this:</p> <pre><code>int a __attribute__((section (\".sdata\"))) = 1;\nint b __attribute__((section (\".sbss\")));\n</code></pre> <p>Variables <code>a</code> and <code>b</code> will go into <code>sdata</code>/<code>sbss</code> sections without checking the data type size against the <code>-G&lt;number&gt;</code> value. Thus, we can always control which data is accessed via <code>gp</code> register by setting <code>-G0</code> and using named sections.</p>"},{"location":"baremetal/general/heap-and-stack/","title":"Heap and Stack Size","text":"<p>To change size of heap in baremetal applications the following option should be specified to the linker: <code>--defsym=__DEFAULT_HEAP_SIZE=${SIZE}</code>, where <code>${SIZE}</code> is desired heap size, in bytes. It also possible to use size suffixes, like <code>k</code> and <code>m</code> to specify size in kilobytes and megabytes respectively. For stack size respective option is <code>--defsym=__DEFAULT_STACK_SIZE=${STACK_SIZE}</code>. Note that those are linker commands - they are valid only when passed to <code>ld</code> application, if <code>gcc</code> driver is used for linking, then those options should be prefixed with <code>-Wl</code>. For example:</p> <pre><code>$ arc-elf32-gcc -Wl,--defsym=__DEFAULT_HEAP_SIZE=256m \\\n-Wl,--defsym=__DEFAULT_STACK_SIZE=1024m --specs=nosys.specs \\\nhello.o -o hello.bin\n</code></pre> <p>Those options are valid only when default linker script is used. If custom linker script is used, then effective way to change stack/heap size depends on properties of that linker script - it might be the same, or it might be different.</p>"},{"location":"baremetal/general/specs/","title":"Specs Files","text":"<p>Warning</p> <p>This article is under construction!</p>"},{"location":"baremetal/general/tcf/","title":"Using TCF","text":"<p>Warning</p> <p>GNU toolchain has a partial support of TCF, however it is not complete and in particular scenarios TCFs cannot be used as-is. ARCv3 toolchains (<code>arc32-</code> and <code>arc64-</code> prefixes) do not support TCF at all.</p>"},{"location":"baremetal/general/tcf/#overview","title":"Overview","text":"<p>If you are using Eclipse IDE for ARC, please refer to a Building User Guide. Eclipse IDE for ARC supports only GCC compiler and GNU linker script sections of TCF, it doesn\u2019t support preprocessor defines sections as of version 2016.03.</p> <p>If you are using GNU toolchain without IDE on Linux hosts you can use a special script <code>arc-elf32-tcf-gcc</code> (for big-endian toolchain this file has <code>arceb-</code> prefix) that is located in the same bin directory as rest of the toolchain executable files. This executable accepts all of the same options as GCC driver and also an option <code>--tcf &lt;path/to/tcf&gt;</code>. <code>arc-elf32-tcf-gcc</code> will extract compiler options, linker script and preprocessor defines from TCF and will pass them to GCC along with other options.</p> <ul> <li>GCC options from <code>gcc_compiler</code> section will be passed as-is, but can be   overridden by <code>-m&lt;value&gt;</code> options passed directly to <code>arc-elf32-tcf-gcc</code>.</li> <li>GNU linker script will be extracted from <code>gnu_linker_command_file</code> will be   used as a <code>memory.x</code> file for <code>-Wl,marcv2elfx</code> linker emulation.   Option <code>-Wl,-marcv2elfx</code> is added by this wrapper - there is no need to   pass it explicitly.</li> <li>Preprocessor defines from section C_defines will be passed with <code>-include</code>   option of GCC.</li> </ul> <p><code>arc-elf32-tcf-gcc</code> is a Perl script that requires <code>XML:LibXML</code> package. It is likely to work on most Linux hosts, however it will not work on Windows hosts, unless Perl with required library has been installed and added to the PATH environment variable. TCF is a text file in XML format, so in case of need it is trivial to extract compiler flags and linker script from TCF and use them directly with GCC and ld without IDE or wrapper script.</p> <p>Value of <code>-mcpu=</code> option is selected by TCF generator to have best match with the target processor. This option ARC Toolchain Variants not only sets various hardware options but also selects a particular build of standard library. Values of hardware extensions can be overridden with individual <code>-m&lt;value&gt;</code> options, but that will not change standard library to a matching build - it still will use standard library build selected by <code>-mcpu=</code> value.</p>"},{"location":"baremetal/general/tcf/#compiler-options","title":"Compiler Options","text":"<p>GCC options are stored in the gcc_compiler section of TCF. These options are passed to GCC as-is. These are machine-specific options applicable only to ARC, and which define configuration of target architecture - which of the optional hardware extensions (like bitscan instructions, barrel shifter instructions, etc) are present. Application that uses hardware extensions will not work on ARC processor without those extensions - there will be an Illegal instruction exception (although application may emulate instruction via handling of this exception, but that is out of scope of this document). Application that doesn\u2019t use hardware extensions present in the target ARC processor might be ineffective, if those extensions allow more optimal implementation of same algorithm. Usually hardware extensions allow improvement of both code size and performance at the expense of increased gate count, with all respective consequences.</p> <p>When TCF is selected in the IDE respective compiler options are disabled in GUI and cannot be changed by user. However if TCF is deselected those options remain at selected values, so it is possible to import options from TCF and then modify it for particular need.</p> <p>When using <code>arc-elf32-tcf-gcc</code> compiler options passed to this wrapper script has a higher precedence then options in TCF, so it is possible to use TCF as a baseline and then modify if needed.</p>"},{"location":"baremetal/general/tcf/#memory-map","title":"Memory Map","text":"<p>Info</p> <p>Please refer Memory Maps and Linker Scripts page for more details.</p> <p>TCF does not contain a linker script for GNU linker in the strict meaning of this term. Instead TCF contains a special memory map, which can be used together with a linker emulation called <code>arcv2elfx</code>. This linker emulation reads a special file called <code>memory.x</code> to get several defines which denote location of particular memory areas, and then emulation allocates ELF sections to those areas. So, for example, <code>memory.x</code> may specify address and size of ICCM and DCCM memories and linker would put code sections into ICCM and data sections to DCCM. TCF contains this <code>memory.x</code> file as content of <code>gnu_linker_command_file</code> section. IDE and <code>arc-elf32-tcf-gcc</code> simply create this file and specify to linker to use <code>arcv2elfx</code> emulation. This is done by passing option <code>-marcv2elfx</code> to linker, but note that when invoking gcc driver it is required to specify this option as <code>-Wl,-marcv2elfx</code>, so driver would know that this is an option to pass to linker.</p> <p>It is very important that memory map in TCF matches the one in the hardware, otherwise application will not work. By default linker places all application code and data as a continuous sections starting from address <code>0x0</code>. Designs with CCMs usually has ICCM mapped at address <code>0x0</code>, and DCCM at addresses</p> <p>= <code>0x8000_0000</code> (or simply an upper half of address space, which can be less then 32 bits wide). If application has both code and data put into ICCM, it may technically work (load/store unit in ARC has a port to ICCM), however this underutilizes DCCM and creates a risk of memory overflow where code and data will not fit into the ICCM, so overflown content will be lost, likely causing an error message in simulator or in debugger. For this reason it is recommended to use <code>memory.x</code> file from TCF when linking applications that use CCM memory. Typically TCF-generator would automatically assign instruction memory area to ICCM and data memory area to DCCM, because parameters of those memories can be read from BCRs, although it does not support such features as ICCM1 or NV ICCM.</p> <p>When memory is connected via external memory bus TCF-generator cannot know where memory will be actually located, so it will put all sections continuously, starting from address <code>0x0</code>. This is basically same as what happens when no memory map has been passed to linker. Therefore memory map in such TCF is effectively useless, instead it is needed to manually enter a proper memory map into <code>gnu_linker_command_file</code> section. However when using an nSIM simulator such TCF will work nice, as it will make nSIM simulate whole address space, so there is no risk that application will be loaded into non-existing address.</p> <p>When using IDE there is an option to ignore memory map specified in TCF and use default memory mapping or custom linker script. This is the default setting - to ignore linker script embedded into TCF. However if target design uses closely-coupled memories then it is highly advised to use memory map (embedded into TCF or manually written).</p>"},{"location":"baremetal/general/tcf/#c-preprocessor-defines","title":"C Preprocessor Defines","text":"<p>TCF section <code>C_defines</code> contains preprocessor defines that specify presence of various hardware optional extensions and values of Build Configuration Registers. <code>arc-elf32-tcf-gcc</code> wrapper extracts content of this section into temporary file and includes into compiled files via <code>-include</code> option of GCC.</p>"},{"location":"baremetal/general/tcf/#command-line-options","title":"Command Line Options","text":""},{"location":"baremetal/general/tcf/#-compiler","title":"<code>--compiler</code>","text":"<p>Overwrites the default compiler name. The compiler tool chain needs to be in the <code>PATH</code>. Default value depends on the name of this file - it will call compiler that has the same name, only without <code>-tcf</code> part. Therefore:</p> <ul> <li><code>arc-elf32-tcf-gcc</code> -&gt; <code>arc-elf32-gcc</code></li> <li><code>arceb-elf32-tcf-gcc</code> -&gt; <code>arceb-elf32-gcc</code></li> <li><code>arc-linux-tcf-gcc</code> -&gt; <code>arc-linux-gcc</code></li> <li><code>arceb-linux-tcf-gcc</code> -&gt; <code>arceb-linux-gcc</code></li> <li><code>arc-a-b-tcf-gcc</code> -&gt; <code>arc-a-b-gcc</code></li> <li><code>arc-tcf-elf32-tcf-gcc</code> -&gt; <code>arc-tcf-elf32-gcc</code></li> </ul>"},{"location":"baremetal/general/tcf/#-tcf","title":"<code>--tcf</code>","text":"<p>The name and the location of the TCF file.</p>"},{"location":"baremetal/general/tcf/#-verbose","title":"<code>--verbose</code>","text":"<p>Verbose output. Prints the compiler invocation command.</p>"},{"location":"baremetal/hardware/axs-ashling/","title":"AXS with Ashling Opella-XD","text":""},{"location":"baremetal/hardware/axs-ashling/#preface","title":"Preface","text":"<p>The Ashling GDB Server software for ARC is implemented by Ashling and delivered as part of the Ashling Opella-XD probe for ARC processors product. This guide aims to provide all necessary information to successfully debug ARC applications using the GNU toolchain for ARC and the Ashling GDB server, however for all issues related to the Ashling GDB Server application, user should contact Ashling Microsystems Ltd. for further assistance.</p> <p>Ashling GDB Server can be used to debug application running on the AXS10x family of software development platforms. It is recommended to use latest version of Ashling drivers and software package available.</p>"},{"location":"baremetal/hardware/axs-ashling/#building-an-application","title":"Building an Application","text":"<p>To learn how to build applications for AXS SDP, please refer to corresponding section of OpenOCD manual.</p>"},{"location":"baremetal/hardware/axs-ashling/#board-configuration","title":"Board Configuration","text":"<p>Board should be configured mostly the same way as for the OpenOCD, but it is required to change <code>JP1402</code> and <code>JP1403</code> jumpers - to debug with Opella-XD it is required to set <code>JP1403</code> and unset <code>JP1402</code>, while for OpenOCD it is otherwise. Refer to OpenOCD manual and to the User Guide of the AXC00x CPU card you are using for more details.</p>"},{"location":"baremetal/hardware/axs-ashling/#running-ashling-gdb-server","title":"Running Ashling GDB Server","text":"<p>Note</p> <p>Starting from Ashling ver. 1.2.6 <code>-device</code> option should contain specific cpu name of the board: <code>arc-600</code>, <code>arc-700</code>, <code>arc-em</code>, <code>arc-hs</code>. Using simple <code>arc</code> would cause an error.</p> <p>Options of the Ashling GDB Server are described in its User Manual. It is highly recommended that users be familiar with Ashling GDB Server operation before proceeding. In a nutshell, to run GDB Server with multiple cores in the JTAG chain:</p> <pre><code>$ ./ash-arc-gdb-server --device arc --arc-reg-file &lt;ARC_REG_FILE&gt; \\\n--scan-file arc2core.xml  --tap-number 1,2\n</code></pre> <p>Command for Ashling version starting from 1.2.6:</p> <pre><code>$ ./ash-arc-gdb-server --device arc-{CPU} --arc-reg-file &lt;ARC_REG_FILE&gt; \\\n--scan-file arc2core.xml  --tap-number 1,2\n</code></pre> <p>where <code>arc-{CPU}</code> is equal to <code>arc-600</code>, <code>arc-700</code>, <code>arc-em</code>, <code>arc-hs</code>.</p> <p>That will open GDB server connections on port 2331 (core 1) and 2332 (core 2). Use GDB to connect to the core you want to debug. <code>&lt;ARC_REG_FILE&gt;</code> is a path to a file with AUX register definitions for the core you are going to debug. Actual file that should be used depends on what target core is. A set of files can be found in the toolchain repository in <code>extras/opella-xd</code> directory. In this directory there are <code>arc600-cpu.xml</code>, <code>arc700-cpu.xml</code>, <code>arc-em-cpu.xml</code> and <code>arc-hs-cpu.xml</code> files for GDB server.</p> <p>To run with AXS101 with all four cores in a chain:</p> <pre><code>$ ./ash-arc-gdb-server --device arc --arc-reg-file &lt;ARC_REG_FILE&gt; \\\n--scan-file arc4core.xml  --tap-number 1,2,3,4\n</code></pre> <p>Command for Ashling version starting from 1.2.6:</p> <pre><code>$ ./ash-arc-gdb-server --device arc-{CPU} --arc-reg-file &lt;ARC_REG_FILE&gt; \\\n--scan-file arc4core.xml  --tap-number 1,2,3,4\n</code></pre> <p>where <code>arc-{CPU}</code> is equal to <code>arc-600</code>, <code>arc-700</code>, <code>arc-em</code>, <code>arc-hs</code>.</p> <p>File <code>arc4core.xml</code> is not shipped with Ashling GDB Server, but can be easily created after looking at arc2core.xml and reading Ashling Opella-XD User Manual.</p> <p>To run Ashling GDB Server with JTAG chain of a single core:</p> <pre><code>$ ./ash-arc-gdb-server --device arc --arc-reg-file &lt;ARC_REG_FILE&gt;\n</code></pre> <p>Command for Ashling version starting from 1.2.6:</p> <pre><code>$ ./ash-arc-gdb-server --device arc-{CPU} --arc-reg-file &lt;ARC_REG_FILE&gt;\n</code></pre> <p>where <code>arc-{CPU}</code> is equal to <code>arc-600</code>, <code>arc-700</code>, <code>arc-em</code>, <code>arc-hs</code>.</p> <p>Option <code>--jtag-frequency ...MHz</code> can be passed to GDB server to change JTAG frequency from default 1MHz. Rule of the thumb is that maximum frequency can be no bigger than half of the frequency, but for cores with external memory that value can be much lower. Most of the cores in different SDP models can work safely with JTAG frequencies around 10 ~ 12 MHz. ARC EM6 in the AXS101 is an exception - maximum recommended frequency is 5MHz.</p>"},{"location":"baremetal/hardware/axs-ashling/#running-gdb","title":"Running GDB","text":"<p>Run GDB:</p> <pre><code>$ arc-elf32-gdb ./application.to.debug\n</code></pre> <p>Then it is required to specify description of target core that will be debugged with Ashling GDB Server.</p> <p>Then it is required to specify XML target description file appropriate for the <code>ARC_REG_FILE</code> used to start Ashling GDB server. XML target description files for <code>arc600-cpu.xml</code>, <code>arc700-cpu.xml</code>, <code>arc-em-cpu.xml</code> and <code>arc-hs-cpu.xml</code> can be found in the toolchain repository in <code>extras/opella-xd</code>. Provided files are: <code>opella-arc600-tdesc.xml</code>, <code>opella-arc700-tdesc.xml</code>, <code>opella-arcem-tdesc.xml</code> and <code>opella-archs-tdesc.xml</code>. File <code>aux-minimal.xml</code> should be also downloaded from that folder and put into the same folder as <code>opella-*-tdesc.xml</code>. This file contains description common to all architectures and is included by all \u201ctdesc\u201d files. It is important that <code>ARC_REG_FILE</code> for Ashling GDB server and target description file for GDB match each other, so if Opella's file has been modified, so should be the target description:</p> <pre><code>(gdb) set tdesc filename &lt;path/to/opella-CPU-tdesc.xml&gt;\n</code></pre> <p>Connect to the target GDB server:</p> <pre><code>(gdb) target remote &lt;gdbserver-host&gt;:&lt;port-number&gt;\n</code></pre> <p>where <code>&lt;gdbserver-host&gt;</code> is a hostname/IP-address of the host that runs OpenOCD (can be omitted if it is localhost), and <code>&lt;port-number&gt;</code> is a number of port of the core you want to debug (see previous section).</p> <p>In most cases you need to load application into the target:</p> <pre><code>(gdb) load\n</code></pre> <p>The system is now ready to debug the application.</p> <p>To debug several cores on the AXC00x card simultaneously, start additional GDBs and connect to the required TCP ports. Cores are controlled independently from each other.</p>"},{"location":"baremetal/hardware/axs-ashling/#known-issues","title":"Known Issues","text":"<ul> <li>XML register file is specified only once in the GDB Server argument, that   means that if your JTAG chain includes multiple cores of different model   (e.g. ARC 700 and EM) you cannot debug them simultaneously, but you can debug   multiple cores of they same type (e.g. all EM).</li> <li>GDB on Windows can\u2019t read XML files with Windows line endings (CR/LF) -   tdesc XML file must be converted to UNIX line endings (LF).</li> <li>HS36 core of the AXS102 cannot be used when both cores are in the JTAG   chain - if <code>resume</code> operation is initiated on the core, GDB Server and   GDB will behave like it is running and never halting, but in reality it   never started to run. To workaround this issue remove HS34 from the JTAG   chain (remove <code>JP1200</code> jumper on the AXC002 card, remove <code>--scan-file</code>   and <code>--tap-number</code> options from Ashling GDB Server command line). If you   need both HS34 and HS36 in the JTAG chain use OpenOCD instead of Ashling GDB   Server. Why this problem happens is a mystery, since HS36 works without   problems when it is single in the JTAG chain, and HS34 always work fine;   this is likely a problem with Ashling GDB Server.</li> <li>In Opella software version of 1.0.6 prior to 1.0.6-D it has been observed   that in some cases target core may hang on application load, if target has   external memory attached. This happens when P-packet is disabled, and since   P-packet should be disabled when using new GDB with those versions of Opella   software, effectively it is not possible to use GDB &gt;= 7.9 with Ashling   GDBserver &lt; 1.0.6-D to debug cores that employ external memory.</li> <li>In version of 1.0.6 it has been observed that breakpoint set at <code>main()</code>   function of application may be not hit on first run in HS34 core in AXS102.</li> <li>In version 1.0.6-D it has been observed that GDB server does not invalidate   <code>I$</code> of the second ARC 600 core of AXS101 - if this core hits a software   breakpoint it gets stuck at it forever.</li> <li>On Windows Ashling might not work at the beginning. After installing Ashling   software try to run <code>opxdarc.exe</code> application. If it fails to start with   error like \"mfc110.dll missing\" try to install \"Visual C++ Redistributable   for Visual Studio\". When <code>opxdarc.exe</code> application was launched press <code>Connect</code>   button. If in the list Serial Number the message No Opella-XD Found appears   go to device manager and check if Ashling driver is installed correctly.   If not try to update Ashling driver setting search location with the path   to installed Ashling software.</li> </ul>"},{"location":"baremetal/hardware/axs-ashling/#known-issues-of-previous-versions-of-ashling-software","title":"Known Issues of Previous Versions of Ashling Software","text":"<ul> <li>In version of Ashling software up to 1.0.5B, passing option <code>--tap-number 2</code>   will cause GDB Server to print that it opened connection on port 2331 for   core 2, however that is not true, instead GDB Server will create this   connection for core 1. Therefore if your JTAG chain contains multiple   ARC TAPs you must specify all of them in the argument to <code>--tap-number</code>   option.</li> <li> <p>Up to version 1.0.5F there is an error in handling of 4-byte software   breakpoints at 2-byte aligned addresses. For example in this sample of   code attempt to set breakpoint at <code>0x2b2</code> will fail:</p> <pre><code>0x000002b0 &lt;+0&gt;:    push_s     blink\n0x000002b2 &lt;+2&gt;:    st.a       fp,[sp,-4]\n0x000002b6 &lt;+6&gt;:    mov_s      fp,sp\n0x000002b8 &lt;+8&gt;:    sub_s      sp,sp,16\n</code></pre> </li> <li> <p>Big endian ARC v2 cores are not supported on versions prior to 1.0.5-F.</p> </li> </ul>"},{"location":"baremetal/hardware/axs-openocd/","title":"AXS with OpenOCD","text":"<p>Info</p> <p>Please refer to board's documentation for detailed information about how to setup the board for initial operation:</p> <ul> <li>AXS 101 Software Development Platform</li> <li>AXS 103 Software Development Platform</li> </ul> <p>Also, consider reading these materials regarding memory maps and OpenOCD:</p> <ul> <li>Follow Memory Maps and Linker Scripts guide for details about <code>memory.x</code> files and where they may be obtained.</li> <li>Follow a corresponding manual to obtain and configure OpenOCD.  </li> </ul>"},{"location":"baremetal/hardware/axs-openocd/#preface","title":"Preface","text":"<p>AXS SDP consists of a mainboard and one of the CPU cards:</p> <ul> <li>AXS101 uses AXC001 CPU card;</li> <li>AXS102 uses AXC002 CPU card;</li> <li>AXS103 uses AXC003 CPU card.</li> </ul> <p>For AXS103 currently two firmware releaseses are supported:</p> <ul> <li>Release 1.2: contains firmware for ARC HS36 CPU and ARC dualcore HS38 CPU</li> <li>Release 1.3: contains firmware for ARC HS47D CPU and ARC dualcore HS48 CPU</li> </ul>"},{"location":"baremetal/hardware/axs-openocd/#building-an-application","title":"Building an Application","text":"<p>A memory map appropriate to the selected board should be used to link applications. The toolchain repository includes memory maps for all ARC SDP systems. They can be found in the tree. Memory map files in that directory have <code>.x</code> extension and file to be used should be renamed to <code>memory.x</code>, because <code>arcv2elfx</code> linker emulation does not support ability to override that file name.</p> <p>Here is an example of building an application for AXS103/HS36:</p> <pre><code>$ cp -a toolchain/extras/dev_systems/axs103.x memory.x\n$ arc-elf32-gcc -Wl,-marcv2elfx --specs=nosys.specs -O2 -g \\\n-mcpu=hs38_linux test.c -o test.elf\n</code></pre> <p>Here is a table compiler flags for particular boards and targets:</p> Target GCC flags AXS 101 EM6 <code>-mcpu=em4_dmips -mmpy-option=3</code> AXS 101 ARC 770 <code>-mcpu=arc700</code> AXS 101 AS221 <code>-mcpu=arc600_mul32x16</code> AXS 102 HS34 <code>-mcpu=hs -mdiv-rem -mmpy-option=9 -mll64 -mfpu=fpud_all</code> AXS 102 HS36 <code>-mcpu=hs -mdiv-rem -mmpy-option=9 -mll64 -mfpu=fpud_all</code> AXS 103 HS36 <code>-mcpu=hs38_linux</code> AXS 103 HS38 <code>-mcpu=hs38_linux</code> AXS 103 HS47 <code>-mcpu=hs4x_rel31</code> AXS 103 HS48 <code>-mcpu=hs4x_rel31</code>"},{"location":"baremetal/hardware/axs-openocd/#board-configuration","title":"Board Configuration","text":"<p>Firstly, it is required to set jumpers and switches on the mainboard:</p> <ul> <li><code>PROG_M0</code> (<code>JP1508</code>), <code>PROG_M1</code> (<code>JP1401</code>) and <code>BS_EN</code> (<code>JP1507</code>) jumpers   should be removed (it is their default position);</li> <li><code>PROG_SRC</code> (<code>JP1403</code>) jumper should be removed (default);</li> <li> <p><code>DEBUG_SRC</code> (<code>JP1402</code>) jumper should be placed (default);  <code>SW2501</code>, <code>SW2502</code>, <code>SW2503</code> and <code>SW2401</code> should be set to their default   positions according to the AXC00x CPU Card User Guides depending on what   CPU card is being used. Following changes should be applied then:</p> <ul> <li><code>SW2401.10</code> switch should be set to <code>1</code> (moved to the left), this will   configure bootloader to setup clocks, memory maps and initialize DDR   SDRAM and then halt a CPU.</li> <li>For the core you are going to debug choose <code>Boot mode</code> type <code>Autonomously</code>,   this is done by moving top two switches of the respective switch block to   the position <code>1</code>. Alternatively, if you leave default boot mode   <code>By CPU Start Button</code> you need to press <code>Start</code> button for this CPU,   before trying to connect to it with the OpenOCD.</li> </ul> </li> </ul> <p>Configuration of the JTAG chain on the CPU card must match the configuration in the OpenOCD. By default OpenOCD is configured to expect complete JTAG chain that includes all of the CPU cores available on the card.</p> <ul> <li>For the AXC001 card jumpers <code>TSEL0</code> and <code>TSEL1</code> should be set.</li> <li>For the AXC002 card jumpers <code>JP1200</code> and <code>JP1201</code> should be set.</li> <li>For the AXC003 card it is not possible to modify JTAG chain directly.</li> </ul> <p>Reset board configuration after changing jumpers or switch position, for this press <code>Board RST</code> button <code>SW2410</code> near the power switch. Two seven-segment displays should show a number respective to the core that is selected to start autonomously. Dot should appear on the first display as well, to notify that bootloader was executed in bypass mode. To sum it up, for the AXS101 following numbers should appear:</p> <ul> <li>1.0 for the AS221 core 1</li> <li>2.0 for the AS221 core 2</li> <li>3.0 for the EM6</li> <li>4.0 for the ARC 770D.</li> </ul> <p>For the AXS102 following numbers should appear:</p> <ul> <li>1.0 for the HS34</li> <li>2.0 for the HS36.</li> </ul> <p>For the AXS103 firmware ver 1.2 following numbers should appear:</p> <ul> <li>1.0 for the HS36</li> <li>2.0 for the HS34</li> <li>3.0 for the HS38 (core 0)</li> <li>4.0 for the HS38 (core 1)</li> </ul> <p>For the AXS103 firmware ver 1.3 following numbers should appear:</p> <ul> <li>1.0 for the HS47D</li> <li>3.0 for the HS48 (core 0)</li> <li>4.0 for the HS48 (core 1)</li> </ul>"},{"location":"baremetal/hardware/axs-openocd/#running-openocd","title":"Running OpenOCD","text":"<p>There is a table of commands for running OpenOCD for AXS targets. Note, that AXS103 SDP supports different core configurations, so while in AXS101 and AXS102 there is a chain of several cores, which can operate independently, in AXS103 one of the particular configurations is chosen at startup and it is not possible to modify chain via jumpers. As a result, different OpenOCD configuration files should be used depending on whether AXS103 is configured to implement HS36 or to implement HS38.</p> AXS target Command line AXS101 <code>openocd -f board/snps_axs101.cfg</code> AXS102 <code>openocd -f board/snps_axs102.cfg</code> AXS103 SH36 <code>openocd -f board/snps_axs103_hs36.cfg</code> AXS103 HS38x2 <code>openocd -f board/snps_axs103_hs38.cfg</code> AXS103 HS47D <code>openocd -f board/snps_axs103_hs47D.cfg</code> AXS103 HS48x2 <code>openocd -f board/snps_axs103_hs48.cfg</code> <p>OpenOCD will open a GDB server connection for each CPU core on target (4 for AXS101, 2 for AXS102, 1 or 2 for AXS103). GDBserver for the first core listens on the TCP port 3333, second on port 3334 and so on. Note that OpenOCD discovers cores in the reverse order to core position in the JTAG chain.</p> <p>For AXS101 ports are:</p> <ul> <li>3333 - ARC 770D</li> <li>3334 - ARC EM</li> <li>3335 - AS221 core 2</li> <li>3336 - AS221 core 1.</li> </ul> <p>For AXS102 ports are:</p> <ul> <li>3333 - ARC HS36</li> <li>3334 - ARC HS34.</li> </ul> <p>For AXS103 HS38x2 or HS48x2 ports are:</p> <ul> <li>3333 - ARC HS38 or HS48 core 1</li> <li>3334 - ARC HS38 or HS48 core 0.</li> </ul> <p>For AXS103 HS47D ports are:</p> <ul> <li>3333 - ARC HS47D</li> </ul>"},{"location":"baremetal/hardware/axs-openocd/#running-gdb","title":"Running GDB","text":"<p>Run GDB:</p> <pre><code>$ arc-elf32-gdb ./application.to.debug\n</code></pre> <p>Connect to the target GDB server:</p> <pre><code>(gdb) target remote &lt;gdbserver-host&gt;:&lt;port-number&gt;\n</code></pre> <p>where <code>&lt;gdbserver-host&gt;</code> is a hostname/IP-address of the host that runs OpenOCD (can be omitted if it is a localhost), and <code>&lt;port-number&gt;</code> is a number of port of the core you want to debug (see previous section).</p> <p>In most cases it is needed to load application into the target:</p> <pre><code>(gdb) load\n</code></pre> <p>After that application is ready for debugging.</p> <p>To debug several cores on the AXC00x card simultaneously, it is needed to start additional GDBs and connect to the required TCP ports. Cores are controlled independently from each other.</p>"},{"location":"baremetal/hardware/axs-openocd/#advanced-topics","title":"Advanced topics","text":""},{"location":"baremetal/hardware/axs-openocd/#using-standalone-digilent-hs-debug-cable","title":"Using Standalone Digilent HS Debug Cable","text":"<p>It is possible to use standalone Digilent HS1 or HS2 debug cable instead of the FT2232 chip embedded into the AXS10x mainboard. Follow AXS10x mainboard manual to learn how to connect Digilent cable to mainboard. In the nutshell:</p> <ul> <li>Connect cable to the <code>DEBUG1</code> 6-pin connector right under the CPU card.   TMS pin is on the left (closer to the <code>JP1501</code> and <code>JP1502</code> jumpers), VDD pin   is on the right, closer to the HDMI connector.</li> <li>Disconnect JP1402 jumper.</li> </ul> <p>Then modify board configuration file used (<code>board/snps_axs101.cfg</code>, <code>board/snps_axs102.cfg</code>, etc): replace <code>source</code> of <code>snps_sdp.cfg</code> with <code>source</code> of <code>digilent-hs1.cfg</code> or <code>digilent-hs2.cfg</code> file, depending on what is being used.</p> <p>Then restart OpenOCD.</p>"},{"location":"baremetal/hardware/axs-openocd/#using-openocd-with-only-one-core-in-the-jtag-chain","title":"Using OpenOCD with Only One Core in the JTAG Chain","text":"<p>In AXS101 and AXS102 it is possible to reduce JTAG chain on the CPU card to a single core.</p> <p>Change positions of <code>TSEL0</code>/<code>TSEL1</code> (on AXC001) or <code>JP1200</code>/<code>JP1201</code> (on AXC002) to reduce JTAG chain to a particular core. Follow AXC00x CPU Card User Guide for details.</p> <p>Then modify OpenOCD command line to notify it that some core is not in the JTAG chain, for example:</p> <pre><code>$ openocd -c 'set HAS_HS34 0' -f board/snps_axs102.cfg\n</code></pre> <p>In this case OpenOCD is notified that HS34 is not in the JTAG chain of the AXC002 card. Important notes:</p> <ul> <li>Option <code>-c 'set HAS_XXX 0'</code> must precede option <code>-f</code>, because they are   executed in the order they appear.</li> <li>By default all such variables are set 1, so it is required to disable each   core one-by-one. For example, for AXS101 it is required to set two variables.</li> <li>Alternative solution is to modify <code>target/snps_axc001.cfg</code> or   <code>target/snps_axc002.cfg</code> files to suit exact configuration, in this case    there will be no need to set variables each time, when starting OpenOCD.</li> </ul> <p>Those variables are used in the <code>target/snps_axc001.cfg</code> file: <code>HAS_EM6</code>, <code>HAS_770</code> and <code>HAS_AS221</code> (it is not possible to configure AXC001 to contain only single ARC 600 core in the JTAG chain). Those variables are used in the <code>target/snps_axc002.cfg</code> file: <code>HAS_HS34</code> and <code>HAS_HS36</code>.</p> <p>When JTAG chain is modified, TCP port number for OpenOCD is modified accordingly. If only one core is in the chain, than it is assigned 3333 TCP port number. In case of AS221 TCP port 3333 is assigned to core 2, while port 3334 is assigned to core 1.</p>"},{"location":"baremetal/hardware/axs-openocd/#troubleshooting","title":"Troubleshooting","text":"<p>Question</p> <p>OpenOCD prints \"JTAG scan chain interrogation failed: all ones\", then there is a lot of messages \"Warn : target is still running!\".</p> <p>Answer</p> <p>An invalid JTAG adapter configuration is used: SDP USB data-port is used with configuration for standalone Digilent-HS cable, or vice versa. To resolve problem fix file <code>board/snps_axs10{1,2}.cfg</code> or <code>board/snps_axs103_hs36.cfg</code> depending on what board is being used.</p> <p>Question</p> <p>OpenOCD prints \"JTAG scan chain interrogation failed: all zeros\".</p> <p>Answer</p> <p>It is likely that position of JP1402 jumper does not match the debug interface you are trying to use. Remove jumper if you are using external debug cable, or place jumper if you are using embedded FT2232 chip.</p> <p>Question</p> <p>OpenOCD prints that is has found \"UNEXPECTED\" device in the JTAG chain.</p> <p>Answer</p> <p>This means that OpenOCD configuration of JTAG chain does not match settings of jumpers on your CPU card.</p> <p>Question</p> <p>I am loading application into target memory, however memory is still all zeros.</p> <p>Answer</p> <p>This might happen if you are using AXC001 CPU card and bootloader has not been executed. Either run bootloader for the selected core or configure core to start in autonomous mode and reset board after that - so bootloader will execute.</p> <p>Question</p> <p>OpenOCD prints \"target is still running!\" after a CTRL+C has been done on the GDB client side.</p> <p>Answer</p> <p>There is an issue with EM6 core in AXS101 - after OpenOCD writes <code>DEBUG.FH</code> bit to do a force halt of the core, JTAG TAP of this core still occasionally returns a status that core is running, even though it has been halted. To avoid problem do not try to break execution with Ctrl+C when using EM6 on AXS101.</p>"},{"location":"baremetal/hardware/emsk/","title":"EM Starter Kit","text":"<p>Info</p> <p>Please refer to board's documentation for detailed information about how to setup the board for initial operation.</p>"},{"location":"baremetal/hardware/emsk/#building-an-application","title":"Building an Application","text":"<p>Suppose, that EMSK 2.2 is used and EM7D core is selected. Consider a simple application <code>main.c</code>:</p> <pre><code>int main()\n{\nint a = 1;\nint b = 2;\nint c = a + b;\nreturn c;\n}\n</code></pre> <p>Build an application with support of UART:</p> <pre><code>cp &lt;path-to-toolchain&gt;/arc-*/lib/emsk2.2_em9d.x memory.x\narc-elf32-gcc -mcpu=em4_dmips -specs=emsk.specs main.c -o main.elf\n</code></pre> <p>Build without support of UART:</p> <pre><code>cp &lt;path-to-toolchain&gt;/arc-*/lib/emsk2.2_em9d.x memory.x\narc-elf32-gcc -mcpu=em4_dmips -specs=nosys.specs -Wl,-marcv2elfx main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/emsk/#running-an-application","title":"Running an Application","text":"<p>Follow Using OpenOCD guide and start OpenOCD with 49101 port and <code>snps_em_sk_v2.2.cfg</code> configuration file. Here is a possible output:</p> <pre><code>Open On-Chip Debugger 0.9.0-dev (2023-05-21-06:23)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nadapter speed: 5000 kHz\nInfo : clock speed 5000 kHz\nInfo : JTAG tap: arc-em.cpu tap/device found: 0x200044b1 (mfg: 0x258, part: 0x0004, ver: 0x2)\nInfo : JTAG tap: arc-em.cpu tap/device found: 0x200044b1 (mfg: 0x258, part: 0x0004, ver: 0x2)\ntarget state: halted\n</code></pre> <p>Then connect to the server using GDB:</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\n\n# Connect. Replace 49101 with port of your choice if you changed it when starting OpenOCD\n(gdb) target remote :49101\n\n# Increase timeout, because OpenOCD sometimes can be slow\n(gdb) set remotetimeout 15\n\n# Load application into target\n(gdb) load\n\n# Go to start of main function\n(gdb) tbreak main\n(gdb) continue\n\n# Resume with usual GDB commands\n(gdb) step\n(gdb) next\n\n# Go to end of the application\n(gdb) tbreak exit\n(gdb) continue\n\n# For example, check exit code of application\n(gdb) info reg r0\n</code></pre>"},{"location":"baremetal/hardware/emsk/#connecting-using-uart","title":"Connecting Using UART","text":"<p>If you are going to use input/output, then you need to configure these parameters of a serial terminal to interact with the serial port:</p> <ul> <li>baud-rate 115200</li> <li>8 data bits</li> <li>1 stop Bit</li> </ul> <p>For <code>minicom</code> use this command:</p> <pre><code>minicom -8 -b 115200 -D /dev/ttyUSB1\n</code></pre> <p>After resetting the EMSK 2.2 you will see this output of the bootloader:</p> <pre><code>***********************************\n**       Synopsys, Inc.          **\n**     ARC EM Starter kit        **\n**                               **\n** Comprehensive software stacks **\n**   available from embARC.org   **\n**                               **\n***********************************\nFirmware   Jan 11 2016, v2.2\nBootloader Dec 29 2015, v1.1\nARC EM11D, core configuration #3 \n\nARC IDENTITY = 0x42\nRF_BUILD = 0xc902\nTIMER_BUILD = 0x10304\nICCM_BUILD = 0x804\nDCCM_BUILD = 0x10804\nI_CACHE_BUILD = 0x135104\nD_CACHE_BUILD = 0x215104\n\nSelfTest PASSED\n\nInfo: No boot image found\n</code></pre>"},{"location":"baremetal/hardware/general/","title":"General Topics","text":""},{"location":"baremetal/hardware/general/#preface","title":"Preface","text":"<ul> <li>Refer to Development Platforms Table section   for options for all available configurations of the board.</li> <li>Follow Memory Maps and Linker Scripts guide for details   about <code>memory.x</code> files and where they may be obtained.</li> <li>Follow a corresponding manual to obtain   and configure OpenOCD.</li> </ul>"},{"location":"baremetal/hardware/general/#connecting-using-uart","title":"Connecting Using UART","text":"<p>Connecting a board to the host computer allows you using a serial port terminal for interacting with the board. You can use any software to connect to the serial port terminal:</p> <ul> <li>On Windows you can use HyperTerminal or Putty.</li> <li>On Linux you can use <code>minicom</code>, <code>gtkterm</code>, <code>cutecom</code>, etc.</li> </ul> <p>You can find detailed instructions for particular boards in corresponding sections.</p>"},{"location":"baremetal/hardware/general/#development-platforms-table","title":"Development Platforms Table","text":"Board Core <code>-specs=</code> Memory map OpenOCD config GCC options EMSK 1 EM4 <code>emsk.specs</code> <code>emsk1_em4.x</code> <code>snps_em_sk_v1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh5</code> EMSK 1 EM6 <code>emsk.specs</code> <code>emsk1_em6.x</code> <code>snps_em_sk_v1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh5</code> EMSK 2.0 EM5D <code>emsk.specs</code> <code>emsk2.1_em5d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4 -mswap -mnorm -mmpy-option=wlh3 -mbarrel-shifter</code> EMSK 2.0 EM7D <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4 -mswap -mnorm -mmpy-option=wlh3 -mbarrel-shifter</code> EMSK 2.0 EM7DFPU <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4 -mswap -mnorm -mmpy-option=wlh3 -mbarrel-shifter -mfpu=fpuda_all</code> EMSK 2.1 EM5D <code>emsk.specs</code> <code>emsk2.1_em5d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh3</code> EMSK 2.1 EM7D <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4_dmips -mmpy-option=wlh3</code> EMSK 2.1 EM7DFPU <code>emsk.specs</code> <code>emsk2.1_em7d.x</code> <code>snps_em_sk_v2.1.cfg</code> <code>-mcpu=em4_fpuda -mmpy-option=wlh3</code> EMSK 2.2 EM7D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.2.cfg</code> <code>-mcpu=em4_dmips</code> EMSK 2.2 EM9D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.2.cfg</code> <code>-mcpu=em4_fpus -mfpu=fpus_all</code> EMSK 2.2 EM11D <code>emsk.specs</code> <code>emsk2.2_em11d.x</code> <code>snps_em_sk_v2.2.cfg</code> <code>-mcpu=em4_fpuda -mfpu=fpuda_all</code> EMSK 2.3 EM7D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.3.cfg</code> <code>-mcpu=em4_dmips</code> EMSK 2.3 EM9D <code>emsk.specs</code> <code>emsk2.2_em9d.x</code> <code>snps_em_sk_v2.3.cfg</code> <code>-mcpu=em4_fpus -mfpu=fpus_all</code> EMSK 2.3 EM11D <code>emsk.specs</code> <code>emsk2.2_em11d.x</code> <code>snps_em_sk_v2.3.cfg</code> <code>-mcpu=em4_fpuda -mfpu=fpuda_all</code> HSDK HS3x <code>hsdk.specs</code> <code>hsdk.x</code> <code>snps_hsdk.cfg</code> <code>-mcpu=hs38_linux</code> HSDK 4x/4xD HS4x/HS4xD <code>hsdk.specs</code> <code>hsdk.x</code> <code>snps_hsdk_4xd.cfg</code> <code>-mcpu=hs38_linux</code> IoTDK ??? <code>iotdk.specs</code> <code>iotdk.x</code> <code>snps_iotdk.cfg</code> <code>-mcpu=em4_dmips</code>"},{"location":"baremetal/hardware/hsdk/","title":"HS Development Kit","text":"<p>Info</p> <p>Please refer to board's documentation for detailed information about how to setup the board for initial operation:</p> <ul> <li>ARC HS Development Kit</li> <li>ARC HS4x/HS4xD Development Kit</li> </ul>"},{"location":"baremetal/hardware/hsdk/#building-an-application","title":"Building an Application","text":"<p>Consider a simple application <code>main.c</code>:</p> <pre><code>int main()\n{\nint a = 1;\nint b = 2;\nint c = a + b;\nreturn c;\n}\n</code></pre> <p>Build an application with support of UART:</p> <pre><code>cp &lt;path-to-toolchain&gt;/arc-*/lib/hsdk.x memory.x\narc-elf32-gcc -mcpu=hs38_linux -specs=hsdk.specs main.c -o main.elf\n</code></pre> <p>Build without support of UART, but if you are going to use interrupts (it allows to catch memory errors):</p> <pre><code>cp &lt;path-to-toolchain&gt;/arc-*/lib/hsdk.x memory.x\narc-elf32-gcc -mcpu=hs38_linux -specs=nosys.specs -Wl,-marcv2elfx \\\n-Wl,--defsym=ivtbase_addr=0x90000000 main.c -o main.elf\n</code></pre> <p>A simple build if you are not going to use UART and interrupts:</p> <pre><code>arc-elf32-gcc -mcpu=hs38_linux -specs=nosys.specs main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/hsdk/#running-an-application","title":"Running an Application","text":"<p>Follow Using OpenOCD guide and start OpenOCD with 49101 port and <code>snps_hsdk.cfg</code> (for HSDK) of <code>snps_hsdk_4xd.cfg</code> (for HSDK 4xD) configuration file. Here is a possible output for HSDK 4xD:</p> <pre><code>Open On-Chip Debugger 0.12.0+dev-gffa52f0e0 (2023-08-02-10:41)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.org/doc/doxygen/bugs.html\nInfo : target has l2 cache enabled is enabled\nInfo : target has l2 cache enabled is enabled\nInfo : target has l2 cache enabled is enabled\nInfo : target has l2 cache enabled is enabled\n32768\nInfo : Listening on port 6666 for tcl connections\nInfo : Listening on port 4444 for telnet connections\nInfo : ftdi: if you experience problems at higher adapter clocks, try the command \"ftdi tdo_sample_edge falling\"\nInfo : clock speed 10000 kHz\nInfo : JTAG tap: arc-em.cpu4 tap/device found: 0x100c54b1 (mfg: 0x258 (ARC International), part: 0x00c5, ver: 0x1)\nInfo : JTAG tap: arc-em.cpu3 tap/device found: 0x100854b1 (mfg: 0x258 (ARC International), part: 0x0085, ver: 0x1)\nInfo : JTAG tap: arc-em.cpu2 tap/device found: 0x100454b1 (mfg: 0x258 (ARC International), part: 0x0045, ver: 0x1)\nInfo : JTAG tap: arc-em.cpu1 tap/device found: 0x100054b1 (mfg: 0x258 (ARC International), part: 0x0005, ver: 0x1)\nInfo : starting gdb server for arc-em.cpu4 on 49101\nInfo : Listening on port 49101 for gdb connections\nInfo : starting gdb server for arc-em.cpu3 on 49102\nInfo : Listening on port 49102 for gdb connections\nInfo : starting gdb server for arc-em.cpu2 on 49103\nInfo : Listening on port 49103 for gdb connections\nInfo : starting gdb server for arc-em.cpu1 on 49104\nInfo : Listening on port 49104 for gdb connections\n</code></pre> <p>Then connect to the server using GDB (49104 port is used below in GDB session, because cores are numbered in reverse order and 49104 port corresponds to the first core):</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\n(gdb) target remote :49104\n\n# Increase timeout, because OpenOCD sometimes can be slow\n(gdb) set remotetimeout 15\n\n# Load application into target\n(gdb) load\n\n# Go to start of main function\n(gdb) tbreak main\n(gdb) continue\n\n# Resume with usual GDB commands\n(gdb) step\n(gdb) next\n\n# Go to end of the application\n(gdb) tbreak exit\n(gdb) continue\n\n# For example, check exit code of application\n(gdb) info reg r0\n</code></pre>"},{"location":"baremetal/hardware/hsdk/#connecting-using-uart","title":"Connecting Using UART","text":"<p>If you are going to use input/output, then you need to configure these parameters of a serial terminal to interact with the serial port:</p> <ul> <li>baud-rate 115200</li> <li>8 data bits</li> <li>1 stop Bit</li> <li>No HW/SW flow control</li> </ul> <p>For <code>minicom</code> use this command:</p> <pre><code>minicom -8 -b 115200 -D /dev/ttyUSB0 -s\n</code></pre> <p>Then choose <code>Serial port setup</code>, press <code>F</code> to disable <code>Hardware Flow Control</code>, press <code>Enter</code> key and then choose <code>Exit</code> to close the configuration menu.</p> <p>After resetting HSDK you will see this output of the bootloader:</p> <pre><code>********************************\n**       Synopsys, Inc.       **\n**   ARC HS Development Kit   **\n********************************\n** IC revision: Rev 2.0\n** Bootloader verbosity: Normal\n** Starting HS Core 1\n** HS Core running @ 500 MHz\nfptr = 8** HS Core fetching application from SPI flash\n** HS Core starting application\n&lt;debug_uart&gt; \n\nU-Boot 2020.01 (Apr 26 2020 - 22:30:20 +0300)\n\nCPU:   ARC HS v4.0 at 500 MHz\nModel: snps,hsdk-4xd\nBoard: Synopsys ARC HS4x/HS4xD Development Kit\nDRAM:  1 GiB\nRelocation Offset is: 3ef8a000\nMMC:   mmc0@f000a000: 0\nLoading Environment from FAT... MMC: no card present\nIn:    serial0@f0005000\nOut:   serial0@f0005000\nErr:   serial0@f0005000\nClock values are saved to environment\nNet:   \nWarning: ethernet@f0008000 (eth0) using random MAC address - c2:26:b0:99:98:4a\neth0: ethernet@f0008000\nhsdk-4xd# \n</code></pre>"},{"location":"baremetal/hardware/memory/","title":"Memory Maps and Linker Scripts","text":""},{"location":"baremetal/hardware/memory/#linker-scripts-and-linker-emulation","title":"Linker Scripts and Linker Emulation","text":"<p>Linker script is a special file which specifies where to put different sections of ELF file and defines particular symbols which may be referenced by an application. Linker emulation is basically way to select one of the predetermined linker scripts of the GNU linker. A linker script for a default linker emulation for ARCv2 may be observed this way:</p> <pre><code>$ arc-elf32-ld --verbose\nGNU ld (ARCompact/ARCv2 ISA elf32 toolchain - build 1360) 2.40.50.20230314\n  Supported emulations:\n   arcelf\n   arclinux\n   arclinux_nps\n   arcv2elf\n   arcv2elfx\nusing internal linker script:\n==================================================\n/* Default linker script, for normal executables */\nOUTPUT_FORMAT(\"elf32-littlearc\", \"elf32-bigarc\",\n              \"elf32-littlearc\")\nOUTPUT_ARCH(arc)\nENTRY(__start)\n\n...\n\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x100)); . = SEGMENT_START(\"text-segment\", 0x100);\n  .interp         : { *(.interp) }\n  .hash           : { *(.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rel.init       : { *(.rel.init) }\n  .rela.init      : { *(.rela.init) }\n\n...\n</code></pre> <p>Linux user-space applications are loaded by the dynamic linker in their own virtual memory address space, where they do not collide with other applications. On the other side, baremetal applications are loaded into target's memory by debugger, bootloader or they are already in the ROM mapped to a specific location.</p> <p>If linker uses an invalid memory map for a particular platform, then some parts of the application will be loaded to the memory incorrectly. For example, it may be accidentally written to peripherals' region and cause an error.</p> <p>That default linker emulation places all loadable ELF sections in a row after each other starting at address <code>0x0</code>. This is usually enough for an application prototyping, however real systems often have much more complex memory maps with CCM regions, peripherals' region, etc.</p> <p>Default linker emulation also puts interrupt vector table (<code>.ivt</code> section) between code and data sections and doesn't align <code>.ivt</code> properly (<code>.ivt</code> must be 1KiB-aligned for ARC processors). Here is an example:</p> <pre><code>$ arc-elf32-gcc -mcpu=em4_dmips main.c -o main.elf\n$ arc-elf32-objdump -h main.elf\n\nmain.elf:     file format elf32-littlearc\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .init         00000022  00000100  00000100  00000100  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .text         00003c28  00000124  00000124  00000124  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  2 .fini         00000016  00003d4c  00003d4c  00003d4c  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  3 .rodata       00000014  00003d64  00003d64  00003d64  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .ivt          00000054  00003d78  00003d78  00003d78  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  5 .data         00000530  00005dcc  00005dcc  00003dcc  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n</code></pre> <p>Therefore the default linker emulation is not applicable for applications which handle interrupts. It can be used safely only with applications which don't handle interrupts and only on simulations which simulate whole address space, like following templates: <code>em6_dmips</code>, <code>em6_gp</code>, <code>em6_mini</code>, <code>em7d_nrg</code>, <code>em7d_voice_audio</code>, <code>em11d_nrg</code>, <code>em11d_voice_audio</code>, <code>hs36_base</code>, <code>hs36</code>, <code>hs38_base</code>, <code>hs38</code>, <code>hs38_full</code>, <code>hs38_slc_full</code>.</p>"},{"location":"baremetal/hardware/memory/#using-arcv2elfx-linker-emulation","title":"Using <code>arcv2elfx</code> linker emulation","text":"<p>If you use <code>arcv2elfx</code> linker emulation, then linker searches for <code>memory.x</code> file with definition of a custom memory map. It is searched in the current working directory and in directories listed via <code>-L</code> option.</p>"},{"location":"baremetal/hardware/memory/#em-starter-kit","title":"EM Starter Kit","text":"<p>Here is an example of <code>memory.x</code> for EM11D core in EM Starter Kit v2.3:</p> <pre><code>MEMORY\n{\n    ICCM : ORIGIN = 0x00000000, LENGTH = 64K\n    DRAM : ORIGIN = 0x10000000, LENGTH = 128M\n    DCCM : ORIGIN = 0x80000000, LENGTH = 64K\n}\n\nREGION_ALIAS(\"startup\", ICCM)\nREGION_ALIAS(\"text\", ICCM)\nREGION_ALIAS(\"data\", DRAM)\nREGION_ALIAS(\"sdata\", DRAM)\n\nPROVIDE (__stack_top = (0x17FFFFFF &amp; -4) );\nPROVIDE (__end_heap = (0x17FFFFFF) );\n</code></pre> <p><code>MEMORY</code> section specifies platform's memory regions: base addresses and lengths. You can use arbitrary names for these regions. <code>REGION_ALIAS</code> commands translate platform's regions to standard region names expected by the linker emulation. There are 4 such standard regions:</p> <ul> <li><code>startup</code> - interrupt vector table and initialization code. By default it's mapped to <code>0x0</code> address and if you map <code>startup</code> to a different one, then you also need to pass this address to the linker using <code>--defsym=ivtbase_addr=&lt;...&gt;</code> option or to GCC itself using <code>-Wl,--defsym=ivtbase_addr=&lt;...&gt;</code> option.</li> <li><code>text</code> - other code sections.</li> <li><code>data</code> - data sections.</li> <li><code>sdata</code> - small data sections.</li> </ul> <p>Also, the example provides these symbols (both of them may be omitted and default values will be used):</p> <ul> <li><code>__stack_top</code> points to the top of the stack. It must be 4-byte aligned In the example it points to the end   of DRAM regions, because stack grows downward.</li> <li><code>__end_heap</code> points to the end of the heap. Heap starts at the end of data sections   and grows upward to <code>__end_heap</code>.</li> </ul> <p>You can compile your application against that <code>memory.x</code> file by passing <code>-marcv2elfx</code> to the linker or <code>-Wl,-marcv2elfx</code> to GCC itself:</p> <pre><code>$ ls\nmain.c memory.x\n$ arc-elf32-gcc -mcpu=em4_dmips -Wl,-marcv2elfx main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/memory/#hs-development-kit","title":"HS Development Kit","text":"<p>Here is an example of <code>memory.x</code> for HS Development Kit:</p> <pre><code>MEMORY\n{\n    DRAM : ORIGIN = 0x90000000, LENGTH = 0x50000000\n}\n\nREGION_ALIAS(\"startup\", DRAM)\nREGION_ALIAS(\"text\", DRAM)\nREGION_ALIAS(\"data\", DRAM)\nREGION_ALIAS(\"sdata\", DRAM)\n</code></pre> <p><code>startup</code> is mapped to <code>0x90000000</code>. It means that you have to pass <code>-Wl,--defsym=ivtbase_addr=&lt;...&gt;</code> option too. You can compile your application against that <code>memory.x</code> this way:</p> <pre><code>$ ls\nmain.c memory.x\n$ arc-elf32-gcc -mcpu=archs -Wl,-marcv2elfx -Wl,--defsym=ivtbase_addr=0x90000000 main.c -o main.elf\n</code></pre>"},{"location":"baremetal/hardware/memory/#memory-maps-for-hardware-platforms","title":"Memory Maps for Hardware Platforms","text":"<p>You can find valid memory mappings for particular hardware platforms in documentation. Here is a list of resources with memory maps for Synopsys' development platforms:</p> <ul> <li>ARC Development Systems Forum Wiki contains documentation for all Synopsys' development platforms. User guides contain descriptions of memory mappings.</li> <li>Newlib repository for ARC contains predefined   memory maps for some of development platforms  in <code>libgloss/arc</code> directory.</li> <li>toolchain repository also contains predefined   memory maps for some of development platforms in <code>extras/dev_systems</code> directory.</li> </ul>"},{"location":"baremetal/simulators/nsim/","title":"Building Applications and Debugging on nSIM","text":""},{"location":"baremetal/simulators/nsim/#building-and-debugging-applications","title":"Building and Debugging Applications","text":"<p>nSIM supports running and debugging applications for all ARC families. Debugging is not supported for ARCv3 families yet.</p> <p>There is no a definite match between TCF templates for nSIM and <code>-mcpu</code> values for GNU toolchain. If you want to build a program using GNU toolchain and run it on nSIM simulator , then you have two ways of finding right nSIM options:</p> <ol> <li>Find proper nSIM options in a compatibility table.</li> <li>Use default TCF templates and additional nSIM options.</li> </ol> <p>There is a table with an a rough matching between <code>-mcpu</code> values and TCF templates with additional options:</p> Compiler <code>-mcpu</code> TCF Additional nSIM options <code>arc-elf32-gcc</code> <code>hs</code> <code>hs36_base</code> <code>arc-elf32-gcc</code> <code>hs34</code> <code>hs36</code> <code>arc-elf32-gcc</code> <code>hs38</code> <code>hs38_full</code> <code>arc-elf32-gcc</code> <code>hs38_linux</code> <code>hs38_full</code> <code>-on nsim_isa_fpud_option -on nsim_isa_fpud_div_option -on nsim_isa_fpu_mac_option -on nsim_isa_fpu_hp_option</code> <code>arc-elf32-gcc</code> <code>archs</code> <code>hs38_full</code> <code>-p\u00a0nsim_isa_mpy_option=2</code> <code>arc-elf32-gcc</code> <code>em</code> <code>em6_mini</code> <code>-p\u00a0nsim_isa_shift_option=3 -p\u00a0nsim_isa_rgf_num_regs=32</code> <code>arc-elf32-gcc</code> <code>em4</code> <code>em6_mini</code> <code>-p\u00a0nsim_isa_shift_option=3 -p\u00a0nsim_isa_rgf_num_regs=32</code> <code>arc-elf32-gcc</code> <code>em4_dmips</code> <code>em6_dmips</code> <code>arc-elf32-gcc</code> <code>em4_fpus</code> <code>em6_dmips</code> <code>-on\u00a0nsim_isa_fpus_option</code> <code>arc-elf32-gcc</code> <code>em4_fpuda</code> <code>em6_dmips</code> <code>-on\u00a0nsim_isa_fpus_option -on\u00a0nsim_isa_fpuda_option</code> <code>arc-elf32-gcc</code> <code>arcem</code> <code>em6_dmips</code> <code>-off\u00a0nsim_isa_bitscan_option -off\u00a0nsim_isa_div_rem_option</code> <code>arc-elf32-gcc</code> <code>arc700</code> <code>arc770d</code> <code>arc-elf32-gcc</code> <code>arc600</code> <code>arc625d</code> <code>arc64-elf-gcc</code> <code>hs5x</code> <code>hs58_full</code> <code>-on\u00a0nsim_isa_ll64_option</code> <code>arc64-elf-gcc</code> <code>hs58</code> <code>hs58_full</code> <code>-on\u00a0nsim_isa_ll64_option</code> <code>arc64-elf-gcc</code> <code>hs6x</code> <code>hs68_full</code> <code>arc64-elf-gcc</code> <code>hs68</code> <code>hs68_full</code> <p>You need to use <code>arceb-</code> prefix for tools instead for <code>arc-</code> for big endian targets. Also you need to pass <code>-on nsim_isa_big_endian</code> to nSIM for big endian targets. Note that the toolchain for ARCv3 targets does not support big endian targets yet.</p> <p>Suppose that <code>main.c</code> contains an application to be debugged on nSIM:</p> <pre><code>int main()\n{\nreturn 0;\n}\n</code></pre> <p>Then build it (we use <code>-specs=nosys.specs</code> if input/output operations are not needed) for ARC HS3x using <code>-mcpu=hs38</code>:</p> <pre><code>$ arc-elf32-gcc -mcpu=hs38 -specs=nosys.specs -g main.c -o main.elf\n</code></pre> <p>Start nSIM with a GDB server with 12345 port:</p> <pre><code>$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -gdb -port 12345\n</code></pre> <p>Run GDB in another terminal and debug the application:</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\nReading symbols from main.elf...\n(gdb) target remote :12345\nRemote debugging using :12345\n0x80000000 in ?? ()\n(gdb) load\nLoading section .init, size 0x22 lma 0x100\nLoading section .text, size 0x1548 lma 0x124\nLoading section .fini, size 0x16 lma 0x166c\nLoading section .ivt, size 0x54 lma 0x1682\nLoading section .data, size 0x534 lma 0x36d8\nLoading section .ctors, size 0x8 lma 0x3c0c\nLoading section .dtors, size 0x8 lma 0x3c14\nLoading section .sdata, size 0x10 lma 0x3c1c\nStart address 0x00000124, load size 6952\nTransfer rate: 188 KB/sec, 869 bytes/write.\n(gdb) b main\nBreakpoint 1 at 0x276: file main.c, line 3.\n(gdb) c\nContinuing.\n\nBreakpoint 1, main () at main.c:3\n3           return 0;\n(gdb)\n</code></pre>"},{"location":"baremetal/simulators/nsim/#building-and-running-hello-world","title":"Building and Running \"Hello, World!\"","text":"<p>Consider a simple example code (save it as <code>main.c</code>):</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\nprintf(\"Hello, World!\\n\");\nreturn 0;\n}\n</code></pre> <p>You need to use <code>-specs=nsim.specs</code> to use input/output features and to pass <code>-on nsim_emt</code> option to nSIM to use ARC GNU input/output protocol:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=nsim.specs main.c -o main.elf\n$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on nsim_emt main.elf\nHello, World!\n</code></pre> <p>You can use MetaWare's own hostlink protocol for input/output operations by passing <code>-specs=hl.specs</code> to GCC. In this case you don't have to pass any additional options to nSIM:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=hl.specs main.c -o main.elf\n$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf main.elf\nHello, World!\n</code></pre>"},{"location":"baremetal/simulators/qemu/","title":"Building Applications and Debugging on QEMU","text":""},{"location":"baremetal/simulators/qemu/#building-and-debugging-applications","title":"Building and Debugging Applications","text":"<p>QEMU supports running and debugging applications for ARC HS3x/HS4x, HS5x and HS6x families. Here is a table of tools and options for a particular family:</p> CPU family Toolchain <code>-mcpu=</code> QEMU binary ARC-specific QEMU options ARC HS3x/HS4x <code>arc-elf32-gcc</code> <code>-mcpu=archs</code> <code>qemu-system-arc</code> <code>-M arc-sim -cpu archs</code> ARC HS5x <code>arc64-elf-gcc</code> <code>-mcpu=hs5x</code> <code>qemu-system-arc</code> <code>-M arc-sim -cpu hs5x</code> ARC HS6x <code>arc64-elf-gcc</code> <code>-mcpu=hs6x</code> <code>qemu-system-arc64</code> <code>-M arc-sim -cpu hs6x</code> <p>Suppose that <code>main.c</code> contains an application to be debugged on QEMU for ARC HS3x/4x:</p> <pre><code>int main()\n{\nreturn 0;\n}\n</code></pre> <p>Then build it (we use <code>-specs=nosys.specs</code> if input/output operations are not needed):</p> <pre><code>arc-elf32-gcc -mcpu=archs -specs=nosys.specs -g main.c -o main.elf\n</code></pre> <p>Start a GDB server in port 1234 (this is the default port, so we could use the alias <code>-s</code> instead of <code>-gdb tcp::1234</code>):</p> <pre><code>qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic -no-reboot \\\n-gdb tcp::1234 -S -kernel main.elf\n</code></pre> <p>Debug the application:</p> <pre><code>$ arc-elf32-gdb -quiet main.elf\nReading symbols from main.elf...\n(gdb) target remote :1234\nRemote debugging using :1234\n0x00000124 in __start ()\n(gdb) load\nLoading section .init, size 0x22 lma 0x100\nLoading section .text, size 0x1554 lma 0x124\nLoading section .fini, size 0x16 lma 0x1678\nLoading section .ivt, size 0x54 lma 0x168e\nLoading section .data, size 0x534 lma 0x36e8\nLoading section .ctors, size 0x8 lma 0x3c1c\nLoading section .dtors, size 0x8 lma 0x3c24\nLoading section .sdata, size 0x10 lma 0x3c2c\nStart address 0x00000124, load size 6964\nTransfer rate: 1700 KB/sec, 696 bytes/write.\n(gdb) b main\nBreakpoint 1 at 0x276: file main.c, line 3.\n(gdb) c\nContinuing.\n\nBreakpoint 1, main () at main.c:3\n3               return 0;\n(gdb)\n</code></pre>"},{"location":"baremetal/simulators/qemu/#using-a-socket-instead-of-port","title":"Using a Socket Instead of Port","text":"<p>If known ports are busy then you can connect to the GDB server using a socket. Expose GDB server through socket instead of port</p> <pre><code>qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic -no-reboot \\\n-chardev socket,path=/tmp/gdb-socket,server=on,wait=off,id=gdb0 \\\n-gdb chardev:gdb0 -S -kernel main.elf\n</code></pre> <p>Connect to the GDB server <pre><code>$ arc-elf32-gdb -quiet main.elf\nReading symbols from main.elf...\n(gdb) target remote /tmp/gdb-socket\nRemote debugging using /tmp/gdb-socket\n0x00000124 in __start ()\n...\n</code></pre></p>"},{"location":"baremetal/simulators/qemu/#building-and-running-hello-world","title":"Building and Running \"Hello, World!\"","text":"<p>Consider a simple example code (save it as <code>main.c</code>):</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\nprintf(\"Hello, World!\\n\");\nreturn 0;\n}\n</code></pre> <p>You need to use <code>-specs=qemu.specs</code> to use input/output features and pass <code>-serial stdio</code> to link a virtual character device with host's <code>stdio</code>:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=qemu.specs main.c -o main.elf\n$ qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic \\\n                  -no-reboot -serial stdio -kernel main.elf\nHello, World!\n</code></pre> <p>By default, QEMU creates a character device for <code>arc-sim</code> board on hard coded <code>0x90000000</code> address. A program built with <code>-specs=qemu.specs</code> uses this address for all input/output operations. However, if <code>-semihosting</code> option is passed to QEMU, then it uses the same input/output interface as nSIM with <code>-on nsim_emt</code> option. It allows to use the same binary for running both on QEMU and nSIM:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=nsim.specs main.c -o main.elf\n$ qemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic \\\n                  -no-reboot -serial stdio -semihosting -kernel main.elf\nHello, World!\n</code></pre>"},{"location":"baremetal/simulators/qemu/#building-and-running-hello-world-using-metaware-development-toolkit","title":"Building and Running \"Hello, World!\" Using MetaWare Development Toolkit","text":"<p>MetaWare\u2019s standard runtime library does not support input/output interfaces of QEMU for ARC. But it is possible to implement your own basic <code>hostlink</code> library for MetaWare to meet QEMU's requirements. You have to implement at least one function to add support of simple output:</p> <pre><code>int _write (int handle, const char *buf, unsigned int count)\n{\nunsigned int i = 0;\nwhile (i &lt; count)\n{\n*(char *) 0x90000000 = buf[i++];\n}\nreturn count;\n}\n</code></pre> <p>It's a slightly modified <code>_write</code> from <code>libqemu.a</code> for Newlib. Save it as <code>write.c</code> file and compile it along with <code>main.c</code>:</p> <pre><code># For ARC HS3x/HS4x\nccac -av2hs -Hhostlib= main.c write.c -o main.elf\n\n# For ARC HS5x\nccac -av3hs -Hhostlib= main.c write.c -o main.elf\n\n# For ARC HS6x\nccac -arc64 -Hhostlib= main.c write.c -o main.elf\n</code></pre> <p>Run it using QEMU:</p> <pre><code># For ARC HS3x/HS4x\nqemu-system-arc -M arc-sim -cpu archs -monitor none -display none -nographic \\\n-no-reboot -serial stdio -kernel main.elf\n\n# For ARC HS5x\nqemu-system-arc -M arc-sim -cpu hs5x -monitor none -display none -nographic \\\n-no-reboot -serial stdio -kernel main.elf\n\n# For ARC HS6x\nqemu-system-arc64 -M arc-sim -cpu hs6x -monitor none -display none -nographic \\\n-no-reboot -serial stdio -kernel main.elf\n</code></pre>"},{"location":"eclipse/","title":"Eclipse IDE","text":"<p>The ARC GNU Eclipse IDE consists of the Eclipse IDE combined with an Eclipse CDT Managed Build Extension plug-in for the ARC GNU Toolchain and GDB embedded debugger plug-in for ARC, based on the Zylin Embedded CDT plug-in.  The ARC GNU IDE supports the development of managed C/C++ applications for ARC processors using the ARC GNU toolchain for bare metal applications (elf32).</p> <p>The ARC GNU IDE provides support for the following functionality:</p> <ul> <li>Support for the ARC EM, ARC HS, ARC 600 and ARC 700 Processors</li> <li>Support for little and big endian configurations</li> <li>Ability to create C/C++ projects using the ARC elf32 cross-compilation   toolchain</li> <li>Configuration of toolchain parameters per project</li> <li> <p>Configuration of individual options (such as preprocessor, optimization,   warnings, libraries, and debugging levels) for each toolchain component:</p> <ul> <li>GCC Compiler</li> <li>GDB Debugger</li> <li>GAS assembler</li> <li>Size binutils utility, etc.</li> </ul> </li> <li> <p>Support for Synopsys EM Starter Kit and AXS10x.</p> </li> <li>Configuration of debug and run configurations for supported FPGA Development   Systems and debug probes (Digilent HS1/HS2 or Ashling Opella-XD).</li> <li>GDB-based debugging using Debug perspective providing detailed debug   information (including breakpoints, variables, registers, and disassembly)</li> </ul> <p>ARC GNU plugins for Eclipse have following requirements to the system:</p> <ul> <li>OS: Windows 10, Ubuntu Linux 16.04 LTS and CentOS 7 development host systems</li> <li>Eclipse 2018-12 (part of Windows installer)</li> <li>CDT version 9.6.0 (part of Windows installer)</li> <li>Java VM version &gt;= 1.8 is required (part of Windows installer)</li> </ul>"},{"location":"eclipse/getting-started/emsk/","title":"Getting Started with EM Starter Kit","text":"<p>Info</p> <p>Consider reading these guides firstly:</p> <ul> <li>Configuring EM Starter Kit</li> <li>Installing WinUSB driver on Windows</li> </ul>"},{"location":"eclipse/getting-started/emsk/#creating-the-project","title":"Creating the Project","text":"<p>Select File \u2192 New \u2192 Project.. and choose C Project. A list of ARC projects will appear. Choose any ARC EM Starter Kit \"Hello World\" project from the ARC EM Starter Kit Projects group. Suppose, EM11D project is chosen.</p> <p></p> <p>After creating the project, a simple \"Hello, World!\" program will be created:</p> <pre><code>#include &lt;stdio.h&gt;\nint main(int argc, char *argv[])\n{\nprintf(\"Hello world!\\n\\r\");\nreturn 0;\n}\n</code></pre>"},{"location":"eclipse/getting-started/emsk/#building-the-project","title":"Building the Project","text":"<p>Do right click on a project in Project Explorer ans choose Build Project. The project will be built with this output:</p> <pre><code>make all \n'Building file: ../src/emsk_em11d_hello.c'\n'Invoking: ARC GNU C Compiler'\nC:\\arc_gnu\\bin\\arc-elf32-gcc.exe -mcpu=em4_fpuda -O0 -g3 -Wall -c -fmessage-length=0 -gdwarf-2 -Wa,-adhlns=\"src/emsk_em11d_hello.o.lst\" -MMD -MP -MF\"src/emsk_em11d_hello.d\" -MT\"src/emsk_em11d_hello.o\" -o \"src/emsk_em11d_hello.o\" \"../src/emsk_em11d_hello.c\"\n'Finished building: ../src/emsk_em11d_hello.c'\n' '\n'Building target: emsk_em11d_hello.elf'\n'Invoking: ARC GNU C Linker'\nC:\\arc_gnu\\bin\\arc-elf32-gcc.exe -mcpu=em4_fpuda --specs=emsk_em11d.specs -Wl,-Map,emsk_em11d_hello.map -o \"emsk_em11d_hello.elf\"  ./src/emsk_em11d_hello.o \n'Finished building target: emsk_em11d_hello.elf'\n' '\n</code></pre>"},{"location":"eclipse/getting-started/emsk/#creating-a-debug-configuration","title":"Creating a Debug Configuration","text":"<p>Do right click on projects's name in Project Explorer and choose Debug As \u2192 Debug Configurations.... Then do right click on ARC C/C++ application and choose New Configuration. Here is a main window of the debug configuration:</p> <p></p> <p>Ensure that a correct project and binary are selected. Navigate to Main tab and Gdbserver Settings inner tab:</p> <p></p> <p>Choose JTAG via OpenOCD as ARC GDB Server and EM Starter Kit v2.2 as a development system (use a corresponding one for your case). Then click on Apply.</p>"},{"location":"eclipse/getting-started/emsk/#configuring-a-serial-terminal","title":"Configuring a Serial Terminal","text":"<p>Navigate to Terminal inner tab of Main tab and select a COM port for the board. Eclipse automatically detects all available COM ports. In my case it's <code>COM7</code>.</p> <p></p> <p>On Windows you can find the exact number in Device Manager (it corresponds to USB Serial Port device):</p> <p></p> <p>On Linux a serial device for EM Starter Kit is usually <code>/dev/ttyUSB1</code>.</p>"},{"location":"eclipse/getting-started/emsk/#debugging-the-project","title":"Debugging the Project","text":"<p>Open the debug configuration in Debug Configurations windows and click on Debug button. The Debug perspective will be opened:</p> <p></p> <p>Use Step Over button to step over <code>printf</code> function and select Terminal in the bottom of the window. \"Hello world!\" string will be printed:</p> <p></p>"},{"location":"eclipse/getting-started/hsdk/","title":"Getting Started with HS Development Kit","text":"<p>Info</p> <p>Consider reading these guides firstly:</p> <ul> <li>Configuring HS Development Kit</li> <li>Configuring HS Development Kit 4xD</li> <li>Installing WinUSB driver on Windows</li> </ul>"},{"location":"eclipse/getting-started/hsdk/#creating-the-project","title":"Creating the Project","text":"<p>Select File \u2192 New \u2192 Project.. and choose C Project. A list of ARC projects will appear. Choose any ARC HS Development Kit Empty Project from the ARC EM Starter Kit Projects group:</p> <p></p> <p>An empty project will be created. Add a new C source file with name <code>main.c</code> in <code>src</code> directory in Project Explorer:</p> <pre><code>int main(int argc, char *argv[])\n{\nreturn 0;\n}\n</code></pre>"},{"location":"eclipse/getting-started/hsdk/#building-the-project","title":"Building the Project","text":"<p>Do right click on a project in Project Explorer ans choose Build Project. The project will be built with this output:</p> <pre><code>make all \n'Building file: ../src/main.c'\n'Invoking: ARC GNU C Compiler'\nC:\\arc_gnu\\bin\\arc-elf32-gcc.exe -mcpu=hs38_linux -matomic -mll64 -mdiv-rem -mswap -mnorm -mmpy-option=9 -mbarrel-shifter -mfpu=fpud_all --param l1-cache-size=65536 --param l1-cache-line-size=64 -include  C:\\Users\\ykolerov\\ARC_GNU_IDE_Workspace\\hsdk_hello\\Debug\\core_config.h -O0 -g3 -Wall -c -fmessage-length=0 -gdwarf-2 -Wa,-adhlns=\"src/main.o.lst\" -MMD -MP -MF\"src/main.d\" -MT\"src/main.o\" -o \"src/main.o\" \"../src/main.c\"\n'Finished building: ../src/main.c'\n' '\n'Building target: hsdk_hello.elf'\n'Invoking: ARC GNU C Linker'\nC:\\arc_gnu\\bin\\arc-elf32-gcc.exe -mcpu=hs38_linux -matomic -mll64 -mdiv-rem -mswap -mnorm -mmpy-option=9 -mbarrel-shifter -mfpu=fpud_all --param l1-cache-size=65536 --param l1-cache-line-size=64 -Wl,-marcv2elfx -L  C:\\Users\\ykolerov\\ARC_GNU_IDE_Workspace\\hsdk_hello\\Debug --specs=nosys.specs -Wl,--defsym=ivtbase_addr=0x0 -Wl,-Map,hsdk_hello.map -o \"hsdk_hello.elf\"  ./src/main.o \n'Finished building target: hsdk_hello.elf'\n' '\n</code></pre>"},{"location":"eclipse/getting-started/hsdk/#creating-a-debug-configuration","title":"Creating a Debug Configuration","text":"<p>Do right click on projects's name in Project Explorer and choose Debug As \u2192 Debug Configurations.... Then do right click on ARC C/C++ application and choose New Configuration. Here is a main window of the debug configuration:</p> <p></p> <p>Ensure that a correct project and binary are selected. Navigate to Main tab and Gdbserver Settings inner tab:</p> <p></p> <p>Choose JTAG via OpenOCD as ARC GDB Server and HS Development Kit as a development system (use a corresponding one for your case). Also, choose HS38 #1 target core. Then click on Apply.</p>"},{"location":"eclipse/getting-started/hsdk/#configuring-a-serial-terminal","title":"Configuring a Serial Terminal","text":"<p>Input/output functions for HS Development Kit are not supported by the toolchain yet. Navigate to Terminal inner tab of Main tab and unselect Launch Terminal checkbox.</p>"},{"location":"eclipse/getting-started/hsdk/#debugging-the-project","title":"Debugging the Project","text":"<p>Open the debug configuration in Debug Configurations windows and click on Debug button. The Debug perspective will be opened:</p> <p></p>"},{"location":"eclipse/getting-started/nsim/","title":"Getting Started with nSIM","text":""},{"location":"eclipse/getting-started/nsim/#prerequisites","title":"Prerequisites","text":"<p>You should have nSIM installed on your computer. You also might need to set environment variable <code>LM_LICENSE_FILE=&lt;your_license&gt;</code> in case if you have full nSIM version. Otherwise you will get licensing failure.</p>"},{"location":"eclipse/getting-started/nsim/#creating-the-project","title":"Creating the Project","text":"<p>Select File \u2192 New \u2192 Project.. and choose C Project. A list of ARC projects will appear. Choose Hello World C Project from the ARC Baremetal Application group. Also, choose GNU Toolchain for ARC HS toolchain.</p> <p></p> <p>After creating the project, a simple \"Hello, World!\" program will be created:</p> <pre><code>#include &lt;stdio.h&gt;\nint main(int argc, char *argv[])\n{\nprintf(\"Hello world!\\n\\r\");\nreturn 0;\n}\n</code></pre>"},{"location":"eclipse/getting-started/nsim/#building-the-project","title":"Building the Project","text":"<p>Do right click on a project in Project Explorer ans choose Build Project. The project will be built with this output:</p> <pre><code>make all \n'Building file: ../src/nsim_hello_hs.c'\n'Invoking: ARC GNU C Compiler'\nC:\\arc_gnu\\bin\\arc-elf32-gcc.exe -mcpu=hs -O0 -g3 -Wall -c -fmessage-length=0 -gdwarf-2 -Wa,-adhlns=\"src/nsim_hello_hs.o.lst\" -MMD -MP -MF\"src/nsim_hello_hs.d\" -MT\"src/nsim_hello_hs.o\" -o \"src/nsim_hello_hs.o\" \"../src/nsim_hello_hs.c\"\n'Finished building: ../src/nsim_hello_hs.c'\n' '\n'Building target: nsim_hello_hs.elf'\n'Invoking: ARC GNU C Linker'\nC:\\arc_gnu\\bin\\arc-elf32-gcc.exe -mcpu=hs --specs=nsim.specs -Wl,-Map,nsim_hello_hs.map -o \"nsim_hello_hs.elf\"  ./src/nsim_hello_hs.o \n'Finished building target: nsim_hello_hs.elf'\n' '\n'Invoking: ARC GNU Print Size'\nC:\\arc_gnu\\bin\\arc-elf32-size.exe  --format=berkeley nsim_hello_hs.elf\n   text    data     bss     dec     hex filename\n  41088    1724     792   43604    aa54 nsim_hello_hs.elf\n'Finished building: nsim_hello_hs.siz'\n' '\n</code></pre>"},{"location":"eclipse/getting-started/nsim/#creating-a-debug-configuration","title":"Creating a Debug Configuration","text":"<p>Do right click on projects's name in Project Explorer and choose Debug As \u2192 Debug Configurations.... Then do right click on ARC C/C++ application and choose New Configuration. Here is a main window of the debug configuration:</p> <p></p> <p>Ensure that a correct project and binary are selected. Navigate to Main tab and Gdbserver Settings inner tab:</p> <p></p> <p>Choose nSIM as ARC GDB Server. Unselect Use nSIM properties file? and select hs48_full.tcf TCF file from nSIM installation.</p> <p>Navigate to Terminal inner tab of Main tab and unselect Launch Terminal checkbox.</p>"},{"location":"eclipse/getting-started/nsim/#debugging-the-project","title":"Debugging the Project","text":"<p>Open the debug configuration in Debug Configurations windows and click on Debug button. The Debug perspective will be opened:</p> <p></p> <p>Use Step Over button to step over <code>printf</code> function. You can observe output in Console tab:</p> <p></p>"},{"location":"eclipse/installation/linux/","title":"Installing Eclipse IDE on Linux","text":""},{"location":"eclipse/installation/linux/#installing-eclipse-ide","title":"Installing Eclipse IDE","text":"<p>Eclipse IDE for ARC GNU toolchain may be downloaded as <code>.tar.gz</code> archive from the releases page. It contains toolchains, OpenOCD and Eclipse itself.</p>"},{"location":"eclipse/installation/linux/#adjusting-rights-for-varlock","title":"Adjusting Rights for <code>/var/lock</code>","text":"<p>If you plan to connect to UART port on target board with RxTx plugin controlled by IDE you need to change permissions of directory <code>/var/lock</code> in your system. Usually by default only users with root access are allowed to write into this directory, however RxTx tries to write file into this directory, so unless you are ready to run IDE with sudo, you need to allow write access to <code>/var/lock</code> directory for everyone. Note that if <code>/var/lock</code> is a symbolic link to another directory then you need to change permissions for this directory as well.</p> <p>Here is an example of adjusting rights for <code>/var/lock</code>:</p> <pre><code>$ ls -l /var/lock\nlrwxrwxrwx 1 root root 9 Jun 10 18:24 /var/lock -&gt; /run/lock\n$ ls -ld /run/lock\ndrwxrwxrwt 3 root root 100 Aug  1 15:12 /run/lock\n$ sudo chmod go+w /run/lock \n$ ls -ld /run/lock\ndrwxrwxrwt 3 root root 100 Aug  1 15:12 /run/lock\n</code></pre> <p>If it is not possible or not desirable to change permissions for this directory, then serial port connection must be disabled in Eclipse debugger configuration window.</p>"},{"location":"eclipse/installation/linux/#adding-a-user-to-dialout-group","title":"Adding a User to <code>dialout</code> Group","text":"<p>Add a user to <code>dialout</code> group to allow the user to connect to the UART device (<code>/dev/ttyUSBx</code>):</p> <pre><code>$ sudo usermod -a -G dialout `whoami`\n</code></pre>"},{"location":"eclipse/installation/linux/#configuring-openocd","title":"Configuring OpenOCD","text":"<p>Follow Getting OpenOCD guide to configure OpenOCD.</p>"},{"location":"eclipse/installation/manual/","title":"Manual Installation","text":""},{"location":"eclipse/installation/manual/#installing-eclipse","title":"Installing Eclipse","text":"<p>Download Eclipse IDE for C/C++ Developers 2020.03 from the official download page. Extract it to <code>eclipse</code> directory.</p>"},{"location":"eclipse/installation/manual/#install-java-se-11-runtime","title":"Install Java SE 11 Runtime","text":"<p>Download Java SE 11 runtime from the official Java download page. Suppose, that the archive contains <code>jdk-11.0.19</code> directory, then extract it to <code>eclipse</code> directory and rename to <code>jre</code>.</p>"},{"location":"eclipse/installation/manual/#downloading-the-plugin","title":"Downloading the Plugin","text":"<p>User can get the latest plugin from the release page. For example, filename of the archive with the plugin for 2023.03 release is <code>arc_gnu_2023.03_ide_plugins.zip</code>.</p> <p>Here is an example of plugin's directory contents:</p> <pre><code>$ tree\n.\n\u251c\u2500\u2500 artifacts.jar\n\u251c\u2500\u2500 content.jar\n\u251c\u2500\u2500 features\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 com.arc.cdt.feature_2019.9.0.202306091135.jar\n\u2514\u2500\u2500 plugins\n    \u251c\u2500\u2500 com.arc.embeddedcdt_2019.9.0.202306091135.jar\n    \u2514\u2500\u2500 com.synopsys.arc.gnu.elf_2019.9.0.202306091135.jar\n\n3 directories, 5 files\n</code></pre>"},{"location":"eclipse/installation/manual/#installing-the-plugin","title":"Installing the Plugin","text":""},{"location":"eclipse/installation/manual/#installing-tm-terminal","title":"Installing \"TM Terminal\"","text":"<p>Install TM Terminal plugin through Help \u2192 Install New Software... menu. Choose --All Available Sites-- in Work with field. Wait until a list of available plugins is updated and select General Purpose Tools \u2192 TM Terminal plugin. Press Next button and proceed with the installation process.</p>"},{"location":"eclipse/installation/manual/#installing-arc-gnu-plugin","title":"Installing ARC GNU Plugin","text":"<p>Open Help \u2192 Install New Software... \u2192 Add \u2192 Archive menu and select the downloaded plugin's archive (e.g., <code>arc_gnu_2023.03_ide_plugins.zip</code>). Then choose ARC GNU Tools Support, press Next button and proceed with the installation process:</p> <p></p> <p>Press Install anyway when Security Warning is shown:</p> <p></p> <p>You can find information about the installed plugins in Help \u2192 About Eclipse IDE \u2192 Installation Details window.</p>"},{"location":"eclipse/installation/manual/#updating-the-existing-plugin","title":"Updating the Existing Plugin","text":"<p>To update the existing plugin follow Installing Eclipse guide but for the newer plugin version.</p>"},{"location":"eclipse/installation/preferences/","title":"Plugin Preferences","text":"<p>ARC plugins in IDE support preferences that can alter their behavior. These preferences are unlikely to be useful for end-user, so they are not exposed via GUI, but they can be modified via preferences files located in Eclipse workspace folder in <code>.metadata/.plugins/org.eclipse.core.runtime/.settings</code> folder.</p> <p>Debugger plugin preferences are located in file <code>com.arc.embeddedcdt.prefs</code>:</p> <code>gdbserver_startup_delay</code> <p>Delay in milliseconds that this plugin wait for after starting <code>gdbserver</code> and before starting the GDB, thus allowing server to start listening on TCP port. Default value is 500.</p> <code>gdbserver_use_adaptive_delay</code> <p>Whether to try to use adaptive server startup delay or use only default fixed delay time. Default value is true.</p> <code>gdbserver_startup_timeout</code> <p>Amount of time in milliseconds given to <code>gdbserver</code> to start in adaptive startup procedure. Default value is 30000.</p> <code>gdbserver_startup_delay_step</code> <p>Amount of time to sleep in milliseconds after adaptive gdbserver startup delay procedure failed to connect to the server. In practice this can be very small, because <code>Socket.connect()</code> itself waits for 1 second. However I\u2019ve measured this value on my machine, so I\u2019m not sure it is equally valid everywhere, so I leave this is a possible parameter to modify if needed. Default value is 1.</p> <code>nsim_pass_reconnect_option</code> <p>Whether to start nSIM with option <code>-reconnect</code>. This is required for adaptive delay to work with nSIM. Default value is true.</p>"},{"location":"eclipse/installation/windows/","title":"Installing Eclipse IDE on Windows","text":""},{"location":"eclipse/installation/windows/#using-the-installer-for-windows","title":"Using the Installer for Windows","text":"<p>Windows users are advised to use our Windows installer for Eclipse for GNU Toolchain for IDE, that can be downloaded from this releases page. Installer already contains all of the necessary components. ARC GNU IDE should be installed in the path no longer than 50 characters and cannot contain white spaces.</p> <p>After downloading the installer, accept a license agreement and follow other steps. By default, Eclipse IDE is installed in <code>C:\\arc_gnu</code> directory. Eclipse IDE executable is <code>C:\\arc_gnu\\eclipse\\eclipse.exe</code>.</p>"},{"location":"eclipse/installation/windows/#installing-a-big-endian-toolchain","title":"Installing a Big Endian Toolchain","text":"<p>By default, Eclipse IDE installer does not choose a big endian toolchain for installing. Select this toolchain manually on \"Choose Components\" stage:</p> <p></p>"},{"location":"eclipse/other/building/","title":"Building the Eclipse Plugin","text":""},{"location":"eclipse/other/building/#preparing-an-environment","title":"Preparing an Environment","text":"<p>Info</p> <p>All builds and mirrors for Eclipse IDE itself may be found on release's page.</p> <p>We will assume that our build directory is <code>/build/eclipse</code>. All necessary tools, directories and prerequisite will be place there. Thus, go to this directory first:</p> <pre><code>$ mkdir /build/eclipse\n$ cd /build/eclipse\n</code></pre> <p>Also create a directory for storing downloaded Maven packages:</p> <pre><code>$ mkdir /build/eclipse/repository\n</code></pre> <p>Download and extract Maven:</p> <pre><code>$ wget https://dlcdn.apache.org/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz\n$ tar -xf apache-maven-3.5.4-bin.tar.gz\n</code></pre> <p>Download and extract JDK 11 to <code>/build/eclipse/jdk-11.0.17</code>.</p> <p>Download and extract Eclipse 2020.03 with CDT for Linux:</p> <pre><code>$ wget https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2020-03/R/eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64.tar.gz\n$ tar -xf eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64.tar.gz\n</code></pre> <p>Download and extract Eclipse 2020.03 with CDT for Windows:</p> <pre><code>wget https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2020-03/R/eclipse-cpp-2020-03-R-incubation-win32-x86_64.zip\ntar -xf eclipse-cpp-2020-03-R-incubation-win32-x86_64.zip\n</code></pre> <p>Clone a plugin's repository:</p> <pre><code>$ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/arc_gnu_eclipse\n</code></pre>"},{"location":"eclipse/other/building/#building-the-plugin","title":"Building the Plugin","text":"<p>Use this commands:</p> <pre><code>$ export JAVA_HOME=/build/eclipse/jdk-11.0.17\n$ export PATH=$JAVA_HOME/bin:$PATH\n$ /build/eclipse/apache-maven-3.5.4/bin/mvn \\\n-Dmaven.repo.local=/build/eclipse/repository clean install\n</code></pre> <p>After that an archive with the plugin will be saved here:</p> <pre><code>arc_gnu_eclipse/repository/target/repository-2019.9.0-SNAPSHOT.zip\n</code></pre>"},{"location":"eclipse/other/building/#installing-the-plugin","title":"Installing the Plugin","text":"<p>You can install the plugin to Eclipse for Linux this way:</p> <pre><code>$ unzip arc_gnu_eclipse/repository/target/repository-2019.9.0-SNAPSHOT.zip \\\n-d eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/dropins\n$ rm -f eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/dropins/artifacts.jar \\\neclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/dropins/content.jar\n$ echo \"-Dosgi.instance.area.default=@user.home/ARC_GNU_IDE_Workspace\" &gt;&gt; eclipse-cpp-2020-03-R-incubation-linux-gtk-x86_64/eclipse.ini\n</code></pre> <p>You can install the plugin to Eclipse for Windows this way:</p> <pre><code>$ unzip arc_gnu_eclipse/repository/target/repository-2019.9.0-SNAPSHOT.zip \\\n-d eclipse-cpp-2020-03-R-incubation-win32-x86_64/dropins\n$ rm -f eclipse-cpp-2020-03-R-incubation-win32-x86_64/dropins/artifacts.jar \\\neclipse-cpp-2020-03-R-incubation-win32-x86_64/dropins/content.jar\n$ echo \"-Dosgi.instance.area.default=@user.home/ARC_GNU_IDE_Workspace\" &gt;&gt; eclipse-cpp-2020-03-R-incubation-win32-x86_64/eclipse.ini\n</code></pre>"},{"location":"general/compatibility/","title":"Compatibility with MetaWare, nSIM and ARChitect","text":""},{"location":"general/compatibility/#choosing-a-processor-family","title":"Choosing a Processor Family","text":"Processor Family CCAC/MDB nSIM GCC binary GCC option ARC HS6x <code>-arc64</code> <code>nsim_isa_family=arc64</code> <code>arc64-elf-gcc</code> <code>-mcpu=</code> values for ARC HS6x ARC HS5x <code>-av3hs</code> <code>nsim_isa_family=av3hs</code> <code>arc64-elf-gcc</code> <code>-mcpu=</code> values for ARC HS5x ARC HS3x/4x <code>-av2hs</code> <code>nsim_isa_family=av2hs</code> <code>arc-elf32-gcc</code> <code>-mcpu=</code> values for ARC HS3x/4x ARC EM <code>-av2em</code> <code>nsim_isa_family=av2em</code> <code>arc-elf32-gcc</code> <code>-mcpu=</code> values for ARC EM ARC700 <code>-a7</code> <code>nsim_isa_family=a700</code> <code>arc-elf32-gcc</code> <code>-mcpu=</code> values for ARC700 ARC600 <code>-a6</code> <code>nsim_isa_family={a600,a601}</code> <code>arc-elf32-gcc</code> <code>-mcpu=</code> values for ARC600"},{"location":"general/compatibility/#configuration-options","title":"Configuration Options","text":"Description ARChitect CCAC/MDB nSIM GCC Shift options <code>-shift_option=3 -bitfield_option</code> <code>-Xsa -Xbs</code> <code>nsim_isa_shift_option=3</code> <code>-mbarrel-shifter</code> Bitscan options <code>-bitscan_option</code> <code>-Xnorm</code> <code>nsim_isa_bitscan_option=1</code> <code>-mnorm</code> Swap options <code>-swap_option</code> <code>-Xswap</code> <code>nsim_isa_swap_option=1</code> <code>-mswap</code> 16 register file <code>-rgf_num_regs=16</code> N/A <code>nsim_isa_rgf_num_regs=16</code> <code>-rf16</code> Code density options <code>-code_density_option</code> <code>-Xcd</code> <code>nsim_isa_code_density_option=2</code> <code>-mcode-density</code> DIV/REM options <code>-div_rem_option={1,2}</code> <code>-Xdiv_rem</code> <code>nsim_isa_div_rem_option={1,2}</code> <code>-mdiv-rem</code> Atomic options <code>-atomic_option</code> <code>-Xatomic</code> <code>nsim_isa_atomic_option=1</code> <code>-matomic</code> 64-bit load and store <code>-ll64_option</code> <code>-Xll64</code> <code>nsim_isa_ll64_option=64</code> <code>-mll64</code> Unaligned access N/A <code>-Xunaligned</code> <code>nsim_isa_unaligned_option=1</code> <code>-munaligned-access</code> ARC 600 32x16 multiplication <code>-Xmul32x16</code> <code>nsim_isa_mul32x16=1</code> <code>-mmul32x16</code> ARC 600 32x32 multiplication <code>nsim_isa_mult32d=1</code> <code>-mmul64</code>"},{"location":"general/processors/","title":"Synopsys ARC Processors","text":"<p>Synopsys ARC processors are represented by three generations of Instruction Set Architectures (ISA). Each ISA consists of one or more processor families with different microarchitectures. All cores may be configured to support little or big endianness. All families except ARC EM and ARC 600 families may be configured to support running complex operation systems like Linux. Some of them are listed here:</p> <ol> <li> <p>ARCv1 ISA:</p> <ul> <li>ARC 600 Processor Family of 32-bit cores</li> <li>ARC 700 Processor Family of 32-bit cores</li> </ul> </li> <li> <p>ARCv2 ISA:</p> <ul> <li>ARC EM Processor Family of 32-bit cores</li> <li>ARC HS Processor Family of 32-bit cores (HS3x, HS4x, HS4xD)</li> </ul> </li> <li> <p>ARCv3 ISA:</p> <ul> <li>ARC HS Processor Family of 32-bit cores (HS5x, HS5xD)</li> <li>ARC HS Processor Family of 64-bit cores (HS6x)</li> </ul> </li> </ol> <p>You can find programmer's reference manuals and datasheets for each core on corresponding web pages.</p>"},{"location":"general/target-options/","title":"Target Specific Options","text":""},{"location":"general/target-options/#overview","title":"Overview","text":"<p>In addition GCC options common to all targets, ARC GNU toolchains supports a set of <code>-m&lt;value&gt;</code> target specific options. Each of them configures a particular feature. For example, <code>-mno-code-density</code> option disables generating code density instructions.</p> <p><code>-mcpu=&lt;core&gt;</code> selects a particular ISA and CPU family and enables/disables a set of other <code>-m</code> options. Each <code>-mcpu</code> value leads to linking with a prebuilt library which corresponds to this particular <code>-mcpu=&lt;value&gt;</code> and is built using this <code>-mcpu=&lt;value&gt;</code>.</p> <p>For example, options combination <code>-mcpu=em4 -mno-code-density</code> generates code that doesn't use code density instructions, however it is linked with standard library that has been built with just <code>-mcpu=em4</code>, which uses code density instructions. Therefore a final application still may use code density instructions.</p> <p>All available target specific options may be found in an official GCC manual.</p>"},{"location":"general/target-options/#arcv1-and-arcv2-toolchains","title":"ARCv1 and ARCv2 Toolchains","text":""},{"location":"general/target-options/#target-options","title":"Target Options","text":"<p>Here is a table of target options for ARCv1 and ARCv2 CPU families with default values for CPU families (On, Off or N/A).</p> Options ARC HS ARC EM ARC 700 ARC 600 <code>-mbarrel-shifter</code> On Off On Off <code>-mnorm</code> On Off On Off <code>-mswap</code> On Off On Off <code>-rf16</code> Off Off Off Off <code>-mfpu=&lt;...&gt;</code> Off Off \u2014 \u2014 <code>-mmpy-option=&lt;...&gt;</code> Off Off \u2014 \u2014 <code>-mcode-density</code> On Off \u2014 \u2014 <code>-mdiv-rem</code> Off Off \u2014 \u2014 <code>-matomic</code> On \u2014 Off \u2014 <code>-mll64</code> Off \u2014 \u2014 \u2014 <code>-mspfp</code> \u2014 Off Off Off <code>-mdpfp</code> \u2014 Off Off Off <code>-msimd</code> \u2014 Off Off \u2014 <code>-mmargonaut</code> \u2014 \u2014 Off Off <code>-mea</code> \u2014 \u2014 Off \u2014 <code>-mmul64</code> \u2014 \u2014 \u2014 Off <code>-mmul32x16</code> \u2014 \u2014 \u2014 Off <code>-munaligned-access</code> <p>You can find a short description for all target options using <code>--target-help</code> option. For example:</p> <pre><code>$ arc-elf32-gcc --target-help\n...\n  -mbranch-index              Enable use of BI/BIH instructions when available.\n  -mcase-vector-pcrel         Use pc-relative switch case tables - this enables case table shortening.\n  -mcmem                      Enable use of NPS400 xld/xst extension.\n  -mcode-density              Enable code density instructions for ARCv2.\n  -mcode-density-frame        Enable ENTER_S and LEAVE_S opcodes for ARCv2.\n  -mcompact-casesi            Enable compact casesi pattern.  Uses of this option are diagnosed.\n  -mcpu=CPU                   Compile code for ARC variant CPU.\n  -mcrc                       Enable variable polynomial CRC extension.  Uses of this option are diagnosed.\n  -mdiv-rem                   Enable DIV-REM instructions for ARCv2.\n  -mdpfp                      FPX: Generate Double Precision FPX (compact) instructions.\n  -mdpfp-compact              FPX: Generate Double Precision FPX (compact) instructions.\n...\n</code></pre> <p>You can find what target options are enabled or disabled by a particular <code>-mcpu=&lt;...&gt;</code> using <code>-Q</code> options. For example:</p> <pre><code>$ arc-elf32-gcc -Q --target-help -mcpu=archs\n...\n  -mbranch-index                        [disabled]\n  -mcase-vector-pcrel                   [disabled]\n  -mcmem                                [disabled]\n  -mcode-density                        [enabled]\n  -mcode-density-frame                  [disabled]\n  -mcompact-casesi                      [disabled]\n  -mcpu=CPU                             archs\n  -mcrc                                 [disabled]\n  -mdiv-rem                             [enabled]\n  -mdpfp                                [disabled]\n  -mdpfp-compact                        [disabled]\n...\n</code></pre> <p>Also, there are several configuration files in GCC's source tree that describe target options for all targets. All of them may be found in <code>gcc/config/arc</code> directory:</p> <ul> <li><code>arc-options.def</code>, <code>arc-opts.h</code>, <code>arc.opt</code> -  definitions and descriptions for all target options.</li> <li><code>arc-arches.def</code> - definitions of CPU families with all available and default target options.</li> <li><code>arc-cpus.def</code> - definitions of particular <code>-mcpu=&lt;core&gt;</code> targets.</li> </ul>"},{"location":"general/target-options/#multiplication-options-for-arc-em-hs3x-and-hs4x-families","title":"Multiplication Options for ARC EM, HS3x and HS4x Families","text":"<p>Here is a table which matches <code>-mmpy-option=</code> values to corresponding features for ARC EM and ARC HS as they defined in ARChitect.</p> <code>-mmpy-option=</code> Aliases ARChitect option for ARC HS ARChitect option for ARC EM 0 <code>none</code> <code>-mpy_option=none</code> <code>-mpy_option=none</code> 1 <code>w</code> \u2014 \u2014 2 <code>wlh1</code>, <code>mpy</code> <code>-mpy_option=mpy</code> <code>-mpy_option=wlh1</code> 3 <code>wlh2</code> \u2014 <code>-mpy_option=wlh2</code> 4 <code>wlh3</code> \u2014 <code>-mpy_option=wlh3</code> 5 <code>wlh4</code> \u2014 <code>-mpy_option=wlh4</code> 6 <code>wlh5</code> \u2014 <code>-mpy_option=wlh5</code> 7 <code>plus_dmpy</code> <code>-mpy_option=plus_dmpy</code> \u2014 8 <code>plus_macd</code> <code>-mpy_option=plus_macd</code> \u2014 9 <code>plus_qmacw</code> <code>-mpy_option=plus_qmacw</code> \u2014"},{"location":"general/target-options/#floating-point-options-for-arc-em-hs3x-and-hs4x-families","title":"Floating Point Options for ARC EM, HS3x and HS4x Families","text":"<p>Here is a table which matches <code>-mfpu=</code> values to corresponding features for ARC EM and ARC HS as they defined in ARChitect.</p> <code>-mfpu=</code> Families <code>-has_fpu</code> <code>-fpu_dp_option</code> <code>-fpu_div_option</code> <code>-fpu_fma_option</code> <code>-fpu_dp_assist</code> <code>fpus</code> EM, HS On \u2014 \u2014 \u2014 \u2014 <code>fpus_div</code> EM, HS On \u2014 On \u2014 \u2014 <code>fpus_fma</code> EM, HS On \u2014 \u2014 On \u2014 <code>fpus_all</code> EM, HS On \u2014 On On \u2014 <code>fpud</code> HS On On \u2014 \u2014 \u2014 <code>fpud_div</code> HS On On On \u2014 \u2014 <code>fpud_fma</code> HS On On \u2014 On \u2014 <code>fpud_all</code> HS On On On On \u2014 <code>fpuda</code> EM On \u2014 \u2014 \u2014 On <code>fpuda_div</code> EM On \u2014 On \u2014 On <code>fpuda_fma</code> EM On \u2014 \u2014 On On <code>fpuda_all</code> EM On \u2014 On On On"},{"location":"general/target-options/#values-of-mcpu-for-arc-hs3x-and-hs4x-families","title":"Values of <code>-mcpu</code> for ARC HS3x and HS4x Families","text":"<code>-mcpu=</code> <code>-mdiv-rem</code> <code>-matomic</code> <code>-mll64</code> <code>-mmpy-option=</code> <code>-mfpu=</code> <code>hs</code> Y <code>hs34</code> Y <code>mpy</code> <code>archs</code> Y Y Y <code>mpy</code> <code>hs38</code> Y Y Y <code>plus_qmacw</code> <code>hs4x</code> Y Y Y <code>plus_qmacw</code> <code>hs4xd</code> Y Y Y <code>plus_qmacw</code> <code>hs38_linux</code> Y Y Y <code>plus_qmacw</code> <code>fpud_all</code> <p>The above <code>-mcpu</code> values correspond to specific ARC EM Processor templates presented in the ARChitect tool.</p> <ul> <li><code>-mcpu=hs</code> corresponds to a basic ARC HS with only atomic instructions enabled. It corresponds to the following ARC HS templates in ARChitect: <code>hs34_base</code>, <code>hs36_base</code> and <code>hs38_base</code>.</li> <li><code>-mcpu=hs34</code> is like <code>hs</code> but with with additional support for standard hardware multiplier. It corresponds to the following ARC HS templates in ARChitect: <code>hs34</code>, <code>hs36</code> and <code>hs38</code>.</li> <li><code>-mcpu=archs</code> is a generic configuration, which corresponds to the default configuration in older GNU toolchain versions.</li> <li><code>-mcpu=hs38</code> is a full-featured ARC HS. It corresponds to the following ARC HS template in ARChitect: <code>hs38_full</code>.</li> <li><code>-mcpu=hs4x</code> and <code>-mcpu=hs4xd</code> have the same option set as <code>-mcpu=hs38</code>, but compiler will optimize instruction scheduling for specified processors.</li> <li><code>-mcpu=hs38_linux</code> is a full-featured ARC HS with additional support of double-precision FPU.</li> </ul>"},{"location":"general/target-options/#values-of-mcpu-for-arc-em-family","title":"Values of <code>-mcpu</code> for ARC EM Family","text":"<code>-mcpu</code> <code>-mcode-density</code> <code>-mnorm</code> <code>-mswap</code> <code>-mbarrel-shifter</code> <code>-mdiv-rem</code> <code>-mmpy-option=</code> <code>-mfpu=</code> <code>-mrf16</code> <code>-mspfp</code> <code>-mdpfp</code> <code>em</code> <code>em_mini</code> Y <code>em4</code> Y <code>arcem</code> Y Y <code>wlh1</code> <code>em4_dmips</code> Y Y Y Y Y <code>wlh1</code> <code>em4_fpus</code> Y Y Y Y Y <code>wlh1</code> <code>fpus</code> <code>em4_fpuda</code> Y Y Y Y Y <code>wlh1</code> <code>fpuda</code> <code>quarkse_em</code> Y Y Y Y Y <code>wlh2</code> <code>quark</code> Y Y <p>The above <code>-mcpu</code> values correspond to specific ARC EM Processor templates presented in the ARChitect tool. It should be noted however that some ARC features are not currently supported in the GNU toolchain, for example DSP instruction support.</p> <ul> <li><code>-mcpu=em</code> doesn't correspond to any specific template, it simply defines the base ARC EM configuration without any optional instructions.</li> <li><code>-mcpu=em_mini</code> is same as <code>em</code>, but uses reduced register file with only 16 core registers.</li> <li><code>-mcpu=em4</code> is a base ARC EM core configuration with <code>-mcode-density</code> option. It corresponds to the following ARC EM templates in ARChitect: <code>em4_mini</code>, <code>em4_sensor</code>, <code>em4_ecc</code>, <code>em6_mini</code>, <code>em5d_mini</code>, <code>em5d_mini_v3</code>, <code>em5d_nrg</code>, <code>em7d_nrg</code>, <code>em9d_mini</code>. Note that those mini templates have a reduced core register file, but <code>-mcpu=em4</code> doesn't enable this feature.</li> <li><code>-mcpu=arcem</code> doesn't correspond to any specific template, it is a legacy flag preserved for compatibility with older GNU toolchain versions, where <code>-mcpu</code> used to select only a CPU family, while optional features were enabled or disabled by individual <code>-m&lt;something&gt;</code> options.</li> <li><code>-mcpu=em4_dmips</code> is a full-featured ARC EM configuration for integer operations. It corresponds to the following ARC EM templates in ARChitect: <code>em4_dmips</code>, <code>em4_rtos</code>, <code>em6_dmips</code>, <code>em4_dmips_v3</code>, <code>em4_parity</code>, <code>em6_dmips_v3</code>, <code>em6_gp</code>, <code>em5d_voice_audio</code>, <code>em5d_nrg_v3</code>, <code>em7d_nrg_v3</code>, <code>em7d_voice_audio</code>, <code>em9d_nrg</code>, <code>em9d_voice_audio</code>, <code>em11d_nrg</code> and <code>em11d_voice_audio</code>.</li> <li><code>-mcpu=em4_fpus</code> is like <code>em4_dmips</code> but with additional support for single-precision floating point unit. It corresponds to the following ARC EM templates in ARChitect: <code>em4_dmips_fpusp</code>, <code>em4_dmips_fpusp_v3</code>, <code>em5d_nrg_fpusp</code> and <code>em9d_nrg_fpusp</code>.</li> <li><code>-mcpu=em4_fpuda</code> is like <code>em4_fpus</code> but with additional support for double-precision assist instructions. It corresponds to the following ARC EM templates in ARChitect: <code>em4_dmips_fpuspdp</code> and <code>em4_dmips_fpuspdp_v3</code>.</li> <li><code>-mcpu=quarkse_em</code> is a configuration for ARC processor in Intel Quark SE chip. It enables additional floating point instructions which cannot be enable using a particular target option.</li> </ul>"},{"location":"general/target-options/#values-of-mcpu-for-arc-600-and-700-families","title":"Values of <code>-mcpu</code> for ARC 600 and 700 Families","text":"<code>-mcpu=</code> <code>-mnorm</code> <code>-mswap</code> <code>-mbarrel-shifter</code> Multiplier <code>arc700</code> Y Y Y <code>-mmpy</code> <code>arc600</code> Y <code>arc600_norm</code> Y Y <code>arc600_mul64</code> Y Y <code>-mmul64</code> <code>arc600_mul32x16</code> Y Y <code>-mmul32x16</code> <code>arc601</code> <code>arc601_norm</code> Y <code>arc601_mul64</code> Y <code>-mmul64</code> <code>arc601_mul32x16</code> Y <code>-mmul32x16</code>"},{"location":"general/target-options/#controlling-the-memory-model","title":"Controlling the Memory Model","text":"<code>-mcmodel</code> Memory size for Data/Code <code>small</code> 1MB region <code>medium</code> 4GB region (used by <code>-fpic</code>) <code>large</code> Full memory (used by <code>-fPIC</code>)"},{"location":"general/target-options/#other-tweaking-options","title":"Other Tweaking Options","text":"Option Description <code>-mfpmov</code> Reduces the pressure on GPRs by using FPRs for inline memory operations. <code>-mbrcc</code> Generate BRcc instructions early on. <code>-mbbit</code> Likewise but for BBITx instructions."},{"location":"general/target-options/#arcv3-toolchain","title":"ARCv3 Toolchain","text":""},{"location":"general/target-options/#values-of-mcpu-for-arc-hs5x-and-arc-hs6x-families","title":"Values of <code>-mcpu</code> for ARC HS5x and ARC HS6x Families","text":"<code>-mcpu=</code> <code>-msimd</code> <code>-m128</code> <code>-mll64</code> <code>hs5x</code> Y N/A <code>hs58</code> Y N/A Y <code>hs6x</code> Y N/A <code>hs68</code> Y Y N/A"},{"location":"general/toolchains/","title":"Toolchains for ARC Processors","text":""},{"location":"general/toolchains/#toolchains-for-baremetal-targets","title":"Toolchains for Baremetal Targets","text":"<p>GNU toolchains for ARC processors consist of GCC, Binutils and GDB. Newlib standard library is used for building baremetal applications. This table depicts which GCC driver should be used depending on ISA:</p> ISA Driver/Triplet ARCv1 <code>arc-elf32-gcc</code> ARCv2 <code>arc-elf32-gcc</code> ARCv3 <code>arc64-elf-gcc</code> <p>Note that binaries for both ARCv1 and ARCv2 may be built using a single <code>arc-elf32-gcc</code> driver. It means that there is a single toolchain for two ISAs.</p>"},{"location":"general/toolchains/#toolchains-for-linux-targets","title":"Toolchains for Linux Targets","text":"<p>There is a set of GNU toolchains for ARC processors which allow to build and debug applications for Linux. The Linux kernel itself for ARC processors may be built using both baremetal and Linux toolchains.</p> <p>Linux toolchains are presented for all ARC processor families except ARC EM and ARC 600. Two Linux standard libraries are currently supported: glibc and uClibc-ng. This table depicts which GCC driver should be used depending on CPU family:</p> Family Standard library Driver/Triplet ARC 700 glibc <code>arc-linux-gnu-gcc</code> ARC 700 uClibc-ng <code>arc-linux-uclibc-gcc</code> ARC HS3x/4x/4xD glibc <code>arc-linux-gnu-gcc</code> ARC HS3x/4x/4xD uClibc-ng <code>arc-linux-uclibc-gcc</code> ARC HS5x uClibc-ng <code>arc32-linux-uclibc-gcc</code> ARC HS6x glibc <code>arc64-linux-gnu-gcc</code> <p>Note, that in case of Linux toolchains, <code>arc-linux-*</code> drivers for ARC 700 and ARC HS are different toolchains! For example, if you want to build applications for ARC 700 Linux targets, then you need to use a particular toolchain for ARC 700 and the same is applicable for ARC HS, though they have the same names.</p>"},{"location":"general/toolchains/#how-to-get-the-toolchain","title":"How to Get The Toolchain","text":"<p>There are several ways of getting the toolchain:</p> <ol> <li>Download the latest release of the prebuilt toolchain on the release page    of main toolchain's repository. Also, Eclipse IDE    is available for downloading which is shipped with some of toolchains and OpenOCD.</li> <li>You can build toolchains using Crosstool-NG build system. Follow instructions presented in    <code>README.md</code> of main toolchain's repository    on GitHub.</li> <li>You can build some of toolchains using scripts from arc-gnu-toolchain    repository. These scripts are based on the RISC-V scripts.</li> </ol>"},{"location":"linux/axs/build/","title":"Building and Running ARC Linux for AXS103 Software Development Platform","text":""},{"location":"linux/axs/build/#preparing-the-board","title":"Preparing the Board","text":"<p>The AXS103 development system consists of an ARC SDP mainboard and a new AXC003 card with an FPGA containing the ARC HS38x2 (dual core). Please refer to board's documentation for detailed information about how to setup the board for initial operation.</p>"},{"location":"linux/axs/build/#connecting-to-a-serial-port-terminal","title":"Connecting to a Serial Port Terminal","text":"<ol> <li>Connect USB-keyboard to the USB-port of the board</li> <li>Connect USB-cable from your host PC to the DataPort (used for serial    communication and for built-in Digilent JTAG)</li> </ol> <p>Debug console will be instantiated on so-called \"data-port\". As a result, we may interact with running Linux distribution by means of serial console.</p> <p>To use serial console we must setup serial-port terminal on host PC/laptop. In case of Windows we may use HyperTerminal or Putty, in case of Linux host we may use <code>minicom</code>, <code>gtkterm</code> or <code>cutecom</code>. Terminal client must be set to baud-rate 115200, 8 bits.</p>"},{"location":"linux/axs/build/#building-the-linux-image","title":"Building the Linux Image","text":"<p>Get Buildroot from the upstream repository:</p> <pre><code>wget http://buildroot.uclibc.org/downloads/buildroot-2017.02.tar.gz\ntar -xvf buildroot-2017.02.tar.gz\ncd buildroot-2017.02\n</code></pre> <p>Download the following patches for this version of Buildroot that are not yet accepted upstream.</p> <ul> <li>0001-toolchain-Disable-PIE-for-ARC.patch</li> <li>0002-axs103-v1.1-Prepare-for-release.patch</li> </ul> <p>Apply those patches on top of extracted source tree of Buildroot:</p> <pre><code>patch -p1 &lt; 0001-toolchain-Disable-PIE-for-ARC.patch\npatch -p1 &lt; 0002-axs103-v1.1-Prepare-for-release.patch\n</code></pre> <p>Now configure Buildroot to use default configuration for AXS103 and execute building procedure:</p> <pre><code>make snps_axs103_defconfig\nmake\n</code></pre> <p>Building takes some time but usually less than an hour on modern machines. Note that build will produce following files in <code>output/images/</code> folder:</p> <ul> <li><code>rootfs.cpio</code>, <code>rootfs.tar</code> - these 2 files contain minimalistic root filesystem,   for example <code>rootfs.cpio</code> could be re-used when manually building Linux kernel for ARC boards.</li> <li><code>u-boot.bin</code> - this is a binary image of U-Boot bootloader, it is meant to be   programmed in AXS' SPI flash and then autostart on power-on.</li> <li><code>uImage</code> - this is Linux kernel prepared for loading by U-Boot bootloader.   When <code>u-boot.bin</code> is programmed in AXS' SPI flash and autostarts on power-on   it will attempt to find uImage on the first partition of the SD-card. But if   one wants to load Linux kernel directly via JTAG then <code>vmlinux</code> should be   built, for that run <code>make menuconfig</code>, go to <code>Kernel -&gt; Kernel binary format</code>   and  select <code>vmlinux</code> (BR2_LINUX_KERNEL_VMLINUX).</li> </ul>"},{"location":"linux/axs/build/#running-the-linux-image-using-metaware-debugger-via-jtag","title":"Running the Linux Image Using MetaWare Debugger via JTAG","text":"<p>After Buildroot has successfully created the image we need to load this Linux image onto the target and run it. And that's exactly the case when we want to have <code>vmlinux</code> created by Buildroot instead of <code>uImage</code>, so follow instructions above and enable <code>BR2_LINUX_KERNEL_VMLINUX</code>.</p> <p>Make sure JTAG-probe is attached to the board. In case of Ashling Opella-XD the following command-line should be used for MetaWare Debugger:</p> <pre><code>mdb -pset=1 -psetname=core0 -DLL=opxdarc.so -prop=jtag_frequency=12MHz -prop=jtag_optimise=1 -memxfersize=0x8000 output/images/vmlinux\nmdb -pset=2 -psetname=core1 -DLL=opxdarc.so -prop=jtag_frequency=12MHz -prop=jtag_optimise=1 -prop=download=2 output/images/vmlinux\nmdb -multifiles=core0,core1 -run -cl\n</code></pre> <p>In case of Digilent HS1/HS2 the following command-line should be used:</p> <pre><code>mdb -pset=1 -psetname=core0 -digilent -prop=dig_speed=10000000 output/images/vmlinux\nmdb -pset=2 -psetname=core1 -digilent -prop=download=2 output/images/vmlinux\nmdb -multifiles=core0,core1 -run -cl\n</code></pre> <p>It's possible to use OpenOCD and Digilent HS1/HS2 probe for loading and debugging the Linux kernel on HSDK. You can find detailed instructions in Using OpenOCD guide.</p> <p>At this point the following log messages should appear in the console:</p> <pre><code>Linux version 4.10.8 (abrodkin@ru20arcgnu1) (gcc version 6.2.1 20160824 (Buildroot 2017.02-00002-g1ad32dd67-dirty) ) #2 SMP PREEMPT Wed Apr 5 21:24:07 MSK 2017\nMemory @ 80000000 [512M] \nOF: fdt:Machine model: snps,axs103-smp\nearlycon: uart8250 at MMIO32 0xe0022000 (options '115200n8')\nbootconsole [uart8250] enabled\nFreq is 100MHz\nAXS: AXC003 CPU Card FPGA Date: 7-3-2017\nAXS: MainBoard v3 FPGA Date: 7-3-2017\narchs-intc      : 2 priority levels (default 1)\n\nIDENTITY        : ARCVER [0x53] ARCNUM [0x0] CHIPID [ 0x0]\nprocessor [0]   : ARC HS38 R3.0 (ARCv2 ISA) \nTimers          : Timer0 Timer1 GFRC [SMP 64-bit] \nISA Extn        : atomic ll64 unalign (not used)\n                : mpy[opt 9] div_rem norm barrel-shift swap minmax swape\nBPU             : full match, cache:512, Predict Table:8192\nMMU [v4]        : 8k PAGE, 2M Super Page (not used) JTLB 512 (128x4), uDTLB 8, uITLB 4, PAE40 (not used) \nI-Cache         : 64K, 4way/set, 64B Line, VIPT aliasing\nD-Cache         : 64K, 2way/set, 64B Line, PIPT\nSLC             : 512K, 64B Line\nPeripherals     : 0xe0000000, IO-Coherency \nVector Table    : 0x80000000\nFPU             : SP DP \nDEBUG           : ActionPoint smaRT RTT \nOS ABI [v4]     : 64-bit data any register aligned\nExtn [SMP]      : ARConnect (v2): 2 cores with IPI IDU DEBUG GFRC\nCONFIG_ARC_FPU_SAVE_RESTORE needed for working apps\nReserved memory: created DMA memory pool at 0xbe000000, size 32 MiB\nOF: reserved mem: initialized node frame_buffer@be000000, compatible id shared-dma-pool\npercpu: Embedded 6 pages/cpu @9fd64000 s16384 r8192 d24576 u49152\nBuilt 1 zonelists in Zone order, mobility grouping on.  Total pages: 65248\nKernel command line: earlycon=uart8250,mmio32,0xe0022000,115200n8 console=tty0 console=ttyS3,115200n8 print-fatal-signals=1 consoleblank=0 video=1280x720@60\nPID hash table entries: 2048 (order: 0, 8192 bytes)\nDentry cache hash table entries: 65536 (order: 5, 262144 bytes)\nInode-cache hash table entries: 32768 (order: 4, 131072 bytes)\nMemory: 504528K/524288K available (4558K kernel code, 150K rwdata, 888K rodata, 10112K init, 273K bss, 19760K reserved, 0K cma-reserved)\nPreemptible hierarchical RCU implementation.\n        Build-time adjustment of leaf fanout to 32.\nNR_IRQS:128\nMCIP: IDU referenced from Devicetree 2 irqs\nclocksource: ARConnect GFRC: mask: 0xffffffffffffffff max_cycles: 0x171024e7e0, max_idle_ns: 440795205315 ns\nConsole: colour dummy device 80x25\nconsole [tty0] enabled\nCalibrating delay loop... 99.22 BogoMIPS (lpj=496128)\npid_max: default: 32768 minimum: 301\nMount-cache hash table entries: 2048 (order: 0, 8192 bytes)\nMountpoint-cache hash table entries: 2048 (order: 0, 8192 bytes)\nsmp: Bringing up secondary CPUs ...\nIdle Task [1] 9f053880\nTrying to bring up CPU1 ...\narchs-intc      : 2 priority levels (default 1)\n\nIDENTITY        : ARCVER [0x53] ARCNUM [0x1] CHIPID [ 0x0]\nprocessor [1]   : ARC HS38 R3.0 (ARCv2 ISA) \nTimers          : Timer0 Timer1 \nISA Extn        : atomic ll64 unalign (not used)\n                : mpy[opt 9] div_rem norm barrel-shift swap minmax swape\nBPU             : full match, cache:512, Predict Table:8192\nMMU [v4]        : 8k PAGE, 2M Super Page (not used) JTLB 512 (128x4), uDTLB 8, uITLB 4, PAE40 (not used) \nI-Cache         : 64K, 4way/set, 64B Line, VIPT aliasing\nD-Cache         : 64K, 2way/set, 64B Line, PIPT\nSLC             : 512K, 64B Line\nPeripherals     : 0xe0000000, IO-Coherency \nVector Table    : 0x80000000\nFPU             : SP DP \nDEBUG           : ActionPoint smaRT RTT \nOS ABI [v4]     : 64-bit data any register aligned\nExtn [SMP]      : ARConnect (v2): 2 cores with IPI IDU DEBUG GFRC\nCONFIG_ARC_FPU_SAVE_RESTORE needed for working apps\n## CPU1 LIVE ##: Executing Code...\nIdle Task [2] 9f0533c0\nTrying to bring up CPU2 ...\nTimeout: CPU2 FAILED to comeup !!!\nIdle Task [3] 9f052f00\nTrying to bring up CPU3 ...\nrandom: fast init done\nTimeout: CPU3 FAILED to comeup !!!\nsmp: Brought up 1 node, 2 CPUs\ndevtmpfs: initialized\nclocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns\nfutex hash table entries: 1024 (order: 3, 65536 bytes)\nNET: Registered protocol family 16\nirq: no irq domain found for /cpu_card/dw-apb-gpio@0x2000/gpio-controller@0 !\nSCSI subsystem initialized\nusbcore: registered new interface driver usbfs\nusbcore: registered new interface driver hub\nusbcore: registered new device driver usb\ni2c_designware e001e000.i2c: Unknown Synopsys component type: 0x00000030\npps_core: LinuxPPS API ver. 1 registered\npps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;\nPTP clock support registered\nclocksource: Switched to clocksource ARConnect GFRC\nNET: Registered protocol family 2\nTCP established hash table entries: 4096 (order: 1, 16384 bytes)\nTCP bind hash table entries: 4096 (order: 2, 32768 bytes)\nTCP: Hash tables configured (established 4096 bind 4096)\nUDP hash table entries: 256 (order: 0, 8192 bytes)\nUDP-Lite hash table entries: 256 (order: 0, 8192 bytes)\nNET: Registered protocol family 1\nRPC: Registered named UNIX socket transport module.\nRPC: Registered udp transport module.\nRPC: Registered tcp transport module.\nRPC: Registered tcp NFSv4.1 backchannel transport module.\nARC perf        : 8 counters (48 bits), 121 conditions, [overflow IRQ support]\nworkingset: timestamp_bits=30 max_order=16 bucket_order=0\nntfs: driver 2.1.32 [Flags: R/O].\nBlock layer SCSI generic (bsg) driver version 0.4 loaded (major 251)\nio scheduler noop registered\nio scheduler deadline registered\nio scheduler cfq registered (default)\nSerial: 8250/16550 driver, 4 ports, IRQ sharing disabled\nf0005000.dw-apb-uart: ttyS0 at MMIO 0xf0005000 (irq = 6, base_baud = 2083312) is a 16550A\ne0020000.uart: ttyS1 at MMIO 0xe0020000 (irq = 17, base_baud = 2083333) is a 16550A\ne0021000.uart: ttyS2 at MMIO 0xe0021000 (irq = 18, base_baud = 2083333) is a 16550A\ne0022000.uart: ttyS3 at MMIO 0xe0022000 (irq = 22, base_baud = 2083333) is a 16550A\nconsole [ttyS3] enabled\nconsole [ttyS3] enabled\nbootconsole [uart8250] disabled\nbootconsole [uart8250] disabled\nloop: module loaded\nlibphy: Fixed MDIO Bus: probed\nstmmaceth e0018000.ethernet: no reset control found\nstmmac - user ID: 0x10, Synopsys ID: 0x37\nstmmaceth e0018000.ethernet: Ring mode enabled\nstmmaceth e0018000.ethernet: DMA HW capability register supported\nstmmaceth e0018000.ethernet: Normal descriptors\nstmmaceth e0018000.ethernet: RX Checksum Offload Engine supported\nstmmaceth e0018000.ethernet: COE Type 2\nstmmaceth e0018000.ethernet: TX Checksum insertion supported\nstmmaceth e0018000.ethernet: Enable RX Mitigation via HW Watchdog Timer\nlibphy: stmmac: probed\nstmmaceth e0018000.ethernet (unnamed net_device) (uninitialized): PHY ID 20005c7a at 1 IRQ POLL (stmmac-0:01) active\nehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver\nehci-platform: EHCI generic platform driver\nehci-platform e0040000.ehci: EHCI Host Controller\nehci-platform e0040000.ehci: new USB bus registered, assigned bus number 1\nehci-platform e0040000.ehci: irq 8, io mem 0xe0040000\nehci-platform e0040000.ehci: USB 2.0 started, EHCI 1.00\nhub 1-0:1.0: USB hub found\nhub 1-0:1.0: 1 port detected\nohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver\nohci-platform: OHCI generic platform driver\nohci-platform e0060000.ohci: Generic Platform OHCI controller\nohci-platform e0060000.ohci: new USB bus registered, assigned bus number 2\nohci-platform e0060000.ohci: irq 8, io mem 0xe0060000\nhub 2-0:1.0: USB hub found\nhub 2-0:1.0: 1 port detected\nusbcore: registered new interface driver usb-storage\nmousedev: PS/2 mouse device common for all mice\nusbcore: registered new interface driver synaptics_usb\ni2c /dev entries driver\nsdhci: Secure Digital Host Controller Interface driver\nsdhci: Copyright(c) Pierre Ossman\nSynopsys Designware Multimedia Card Interface Driver\ndw_mmc e0015000.mmc: IDMAC supports 32-bit address mode.\ndw_mmc e0015000.mmc: Using internal DMA controller.\ndw_mmc e0015000.mmc: Version ID is 290a\ndw_mmc e0015000.mmc: DW MMC controller at irq 7,32 bit host data width,16 deep fifo\nmmc_host mmc0: Bus speed (slot 0) = 50000000Hz (slot req 400000Hz, actual 396825HZ div = 63)\ndw_mmc e0015000.mmc: 1 slots initialized\nsdhci-pltfm: SDHCI platform and OF driver helper\nusbcore: registered new interface driver usbhid\nusbhid: USB HID core driver\nNET: Registered protocol family 17\nNET: Registered protocol family 15\nttyS3 - failed to request DMA\nFreeing unused kernel memory: 10112K\nThis architecture does not have kernel memory protection.\nusb 1-1: new high-speed USB device number 2 using ehci-platform\nStarting logging: OK\nInitializing random number generator... done.\nStarting network: stmmaceth e0018000.ethernet eth0: device MAC address ba:24:55:7e:f8:4f\nstmmaceth e0018000.ethernet eth0: fail to init PTP.\nudhcpc: started, v1.26.2\nudhcpc: sending discover\nstmmaceth e0018000.ethernet eth0: Link is Up - 100Mbps/Full - flow control off\nudhcpc: sending discover\nudhcpc: sending select for 10.42.0.225\nudhcpc: lease of 10.42.0.225 obtained, lease time 3600\ndeleting routers\nadding dns 10.42.0.1\nOK\nssh-keygen: generating new host keys: RSA DSA \nECDSA ED25519 \nStarting sshd: OK\nrandom: crng init done\n\nWelcome to the ARC Software Development Platform\naxs103 login: root\n</code></pre> <p>Enter login <code>root</code> and press Enter.</p> <p>Note if you see following in bootlog: <pre><code>udhcpc (v1.23.2) started\nSending discover...\nSending discover...\nSending discover...\nNo lease, failing\n</code></pre></p> <p>And also later:</p> <pre><code>stmmaceth e0018000.ethernet eth0: Link is Up - 100Mbps/Full - flow control rx/tx\n</code></pre> <p>That means Ethernet PHY became alive a bit too late. And that means it's required to execute DHCP discovery once again from console:</p> <pre><code>udhcpc\n</code></pre> <p>Now you may run whatever programs were built from your Buildroot selections. For the default only busybox is built and installed.</p> <pre><code># ls /dev\nbus                 tty1                tty43\nconsole             tty10               tty44\ncpu_dma_latency     tty11               tty45\nfull                tty12               tty46\ngpiochip0           tty13               tty47\ngpiochip1           tty14               tty48\ngpiochip2           tty15               tty49\ngpiochip3           tty16               tty5\ngpiochip4           tty17               tty50\ngpiochip5           tty18               tty51\ngpiochip6           tty19               tty52\ni2c-0               tty2                tty53\ni2c-1               tty20               tty54\ninput               tty21               tty55\nkmsg                tty22               tty56\nlog                 tty23               tty57\nloop-control        tty24               tty58\nloop0               tty25               tty59\nloop1               tty26               tty6\nloop2               tty27               tty60\nloop3               tty28               tty61\nloop4               tty29               tty62\nloop5               tty3                tty63\nloop6               tty30               tty7\nloop7               tty31               tty8\nmem                 tty32               tty9\nmemory_bandwidth    tty33               ttyS0\nnetwork_latency     tty34               ttyS1\nnetwork_throughput  tty35               ttyS2\nnull                tty36               ttyS3\npsaux               tty37               urandom\nptmx                tty38               vcs\npts                 tty39               vcs1\nrandom              tty4                vcsa\nshm                 tty40               vcsa1\ntty                 tty41               zero\ntty0                tty42\n</code></pre>"},{"location":"linux/axs/build/#running-the-linux-image-using-u-boot","title":"Running the Linux Image Using U-Boot","text":"<p>It's possible to use U-Boot bootloader for loading and starting Linux image on AXS103 board. U-Boot itself could be whether pre-programmed in on-board SPI flash and start automatically on power-on or user may load it via JTAG similarly to how kernel image was loaded above.</p>"},{"location":"linux/axs/build/#preparing-the-linux-image-for-loading-using-u-boot","title":"Preparing the Linux Image for Loading Using U-Boot","text":"<p>Linux kernel built with Buildroot as described above will not be suitable for use with U-Boot as it requires post-processing resulting ELF-file to add U-Boot specific header in the beginning of the image.</p> <p>Fortunately Buildroot may handle it easily. Just start Buildroot's configuration utility with <code>make menuconfig</code>, go to<code>Kernel -&gt; Kernel binary format</code> and select <code>uImage</code>. Save your new configuration, exit configuration utility and issue <code>make</code> command once again. You'll get <code>uImage</code> file in <code>output/images/vmlinux</code> folder. Now put that file in the root of FAT32-formatted SD-card or in shared folder on TFTP server.</p>"},{"location":"linux/axs/build/#building-u-boot-for-axs103-board","title":"Building U-Boot for AXS103 board","text":"<p>Anyway U-Boot for AXS103 board could be built from upstream sources starting from <code>v2015.10</code> that way:</p> <pre><code>wget ftp://ftp.denx.de/pub/u-boot/u-boot-2017.01.tar.bz2\ntar -xf u-boot-2017.01.tar.bz2\ncd u-boot-2017.01\n</code></pre> <p>Download the following patches that are missing from the current U-Boot release:</p> <pre><code>curl http://git.denx.de/?p=u-boot.git;a=patch;h=0b0db98be7e22f5b862b62f63db7ff6ab02a3a7f &gt; 0001-axs103-Clean-up-smp_kick_all_cpus.patch\ncurl http://git.denx.de/?p=u-boot.git;a=patch;h=2a5062ca9ecc22b88af2babf812b05dd97ecde46 &gt; 0002-axs103-Support-slave-core-kick-start-on-axs103-v1.1-.patch\n</code></pre> <p>Apply those patches on top of unpacked U-Boot source tree:</p> <pre><code>patch -p1 &lt; 0001-axs103-Clean-up-smp_kick_all_cpus.patch\npatch -p1 &lt; 0002-axs103-Support-slave-core-kick-start-on-axs103-v1.1-.patch\n</code></pre> <p>Configure U-Boot before building:</p> <pre><code>make axs103_defconfig\n</code></pre> <p>Now depending on use-case 2 different commands should be used.</p> <ul> <li>For programming in on-board SPI flash: <code>make u-boot.bin</code>.</li> <li>For loading U-Boot with debugger via JTAG: <code>make mdbtrick</code>.</li> </ul>"},{"location":"linux/axs/build/#flashing-uboot","title":"Flashing U\u2010Boot","text":"<p>ARC AXS10x Software Development Platforms (SDP) have built-in SPI-flash storage which may be used to host auto-started applications such as bootloaders, etc. Detailed instructions are available in this article: Flashing U\u2010Boot in ARC AXS10x Software Development Platforms (SDP)</p>"},{"location":"linux/axs/build/#loading-u-boot-with-debugger-via-jtag","title":"Loading U-Boot with debugger via JTAG","text":"<pre><code>### Ashling Opella-XD\nmdb -DLL=opxdarc.so -prop=jtag_frequency=12MHz -prop=jtag_optimise=1 -nooptions -OK -memxfersize=0x8000 u-boot\n\n### Digilent\nmdb -digilent -prop=dig_speed=10000000 u-boot\n</code></pre>"},{"location":"linux/axs/build/#preparing-u-boot-for-automatic-load-of-linux-kernel","title":"Preparing U-Boot for automatic load of Linux kernel","text":"<p>Once U-Boot is loaded on the AXS103 board it could be used for loading Linux kernel image from different media manually and automatically.</p> <p>On execution of U-Boot you'll see this in serial console:</p> <pre><code>U-Boot 2017.01 (Apr 05 2017 - 15:52:58 +0300)\n\nI2C:   ready\nDRAM:  512 MiB\nNAND:  512 MiB\nMMC:   Synopsys Mobile storage: 0\nIn:    serial0@e0022000\nOut:   serial0@e0022000\nErr:   serial0@e0022000\nNet:   \nWarning: ethernet@e0018000 (eth0) using random MAC address - ba:24:55:7e:f8:4f\neth0: ethernet@e0018000\nHit any key to stop autoboot:  0\nAXS#\n</code></pre> <p>Press any key to stop count-down and make sure U-Boot doesn't go to execute automatic boot sequence. U-Boot is controlled with its specific set of commands. List of available commands could be obtained with <code>?</code> or <code>help</code> command like that:</p> <pre><code>AXS# ?\n?       - alias for 'help'\nbase    - print or set address offset\nbdinfo  - print Board Info structure\nboot    - boot default, i.e., run 'bootcmd'\nbootd   - boot default, i.e., run 'bootcmd'\nbootelf - Boot from an ELF image in memory\nbootm   - boot application image from memory\nbootp   - boot image via network using BOOTP/TFTP protocol\nbootvx  - Boot vxWorks from an ELF image\ncmp     - memory compare\nconinfo - print console devices and information\ncp      - memory copy\ncrc32   - checksum calculation\ndhcp    - boot image via network using DHCP/TFTP protocol\ndm      - Driver model low level access\necho    - echo args to console\neditenv - edit environment variable\neeprom  - EEPROM sub-system\nenv     - environment handling commands\nfatinfo - print information about filesystem\nfatload - load binary file from a dos filesystem\nfatls   - list files in a directory (default /)\nfatsize - determine a file's size\nfdt     - flattened device tree utility commands\ngo      - start application at address 'addr'\nhelp    - print command description/usage\niminfo  - print header information for application image\nimxtract- extract a part of a multi-image\nitest   - return true/false on integer compare\nloadb   - load binary file over serial line (kermit mode)\nloads   - load S-Record file over serial line\nloadx   - load binary file over serial line (xmodem mode)\nloady   - load binary file over serial line (ymodem mode)\nloop    - infinite loop on address range\nmd      - memory display\nmm      - memory modify (auto-incrementing address)\nmmc     - MMC sub system\nmmcinfo - display MMC info\nmw      - memory write (fill)\nnand    - NAND sub-system\nnboot   - boot from NAND device\nnfs     - boot image via network using NFS protocol\nnm      - memory modify (constant address)\nping    - send ICMP ECHO_REQUEST to network host\nprintenv- print environment variables\nreset   - Perform RESET of the CPU\nrun     - run commands in an environment variable\nsaveenv - save environment variables to persistent storage\nsetenv  - set environment variables\nsleep   - delay execution for some time\nsource  - run script from memory\ntftpboot- boot image via network using TFTP protocol\nusb     - USB sub-system\nusbboot - boot from USB device\nversion - print monitor, compiler and linker version\n</code></pre> <p>It's also possible to create scripts - sequences of commands to be executed one by one. And a script with special name <code>bootcmd</code> is automatically executed after boot delay gets expired.</p> <p>And so we may tune that script for our purposes.</p> <ul> <li>To load Linux image from SD-card: <code>setenv bootcmd fatload mmc 0\\; bootm</code></li> <li>To load Linux image from TFTP server: <code>setenv bootcmd dhcp\\; bootm</code></li> </ul> <p>Note that for loading image from TFTP server it's required:</p> <ol> <li>To assign a valid MAC-address to AXS103 board with the following command: <code>setenv ethaddr 66:55:44:33:22:11</code></li> <li>Specify IP-address of TFTP server with command: <code>setenv serverip 10.11.12.13</code></li> </ol> <p>When all preparations are done it's good to save modifications of U-Boot environment with <code>saveenv</code> command.</p> <p>And with <code>boot</code> command or with restart of U-Boot (whether with reset button if U-Boot is pre-programmed in SPI flash or with reload of U-Boot elf with MDB) you'll be able to load and start Linux kernel.</p>"},{"location":"linux/axs/build/#video-output-via-hdmi","title":"Video Output via HDMI","text":"<p>It is possible to attach a modern TV or computer monitor to ARC SDP board via HDMI cable. Even though on ARC SDP board there's only HDMI connector it's possible to use DVI monitor as well through DVI-HDVI converter.</p> <p>By default in Linux kernels starting from 4.10 device driver for ARC PGU is built as a kernel module and so is not loaded automatically on start. Moreover if initramfs and/or Linux kernel is built outside of Buildroot there's a chance to not have corresponding modules there which makes it impossible to get video output working.</p> <p>The simplest solution here is just to use Buildroot's defconfig for AXS103, i.e. configure Buildroot with <code>make snps_archs38_axs103_defconfig</code>. Buildroot takes care of copying kernel modules onto roofs so on target user may just say:</p> <pre><code>modprobe arcpgu.ko\nmodprobe adv7511.ko\n</code></pre> <p>At this point debug console will appear on the screen.</p>"},{"location":"linux/axs/build/#play-video-with-mplayer-on-hdmi-monitor","title":"Play Video with mplayer on HDMI Monitor","text":"<p>Note that mplayer application is not built by Buildroot by default for AXS103 so it is required to select corresponding package (<code>BR2_PACKAGE_MPLAYER</code>) in Buildroot configuration utility and rebuild everything with <code>make</code> command. Make sure that rebuilt file-system ends up on your target, i.e. use updated <code>vmlinux</code> or <code>uImage</code>  file if rootfs is built-in Linux kernel image or deploy file-system image on your storage (like SD-card or USB flash-drive).</p> <p>Copy Big Buck Bunny video on USB flash-drive or on SD-card from here http://download.blender.org/peach/bigbuckbunny_movies/BigBuckBunny_320x180.mp4</p> <p>Insert you storage media into ARC SDP, mount your storage and start playback with:</p> <pre><code>mplayer -vo fbdev2 BigBuckBunny_320x180.mp4\n</code></pre> <p>Note playback will be really-really slow on axs103 due to absent hardware acceleration of mp4 decoding and CPU frequency of only 100 MHz.</p>"},{"location":"linux/axs/uboot/","title":"Flashing U\u2010Boot in ARC AXS10x Software Development Platforms (SDP)","text":"<p>ARC AXS10x Software Development Platforms (SDP) have built-in SPI-flash storage which may be used to host auto-started applications such as bootloaders, etc.</p> <p>U-Boot is a good fit for such application. Very early boot SDP's pre-bootloader application is able to find images in that SPI-flash, load them in specified memory location and then execute it.</p> <p>It's also possible to have separate images to be loaded and executed for different CPU cores. This allows us to have U-Boot images for both ARC 770D and ARC HS38 at once each starting when appropriate CPU tile is mounted on the base-board.</p> <p>Below are command for preparing [if needed - for ARCv2 CPUs] and flashing U-Boot in SPI flash.</p> <ul> <li> <p>For ARC 770D</p> <ul> <li>Build U-Boot binary image: <code>make axs101_defconfig &amp;&amp; make u-boot.bin</code></li> <li>Flash image: <code>axs_comm -c 0434 -a 00000000 -p 81000000 -f u-boot.bin</code></li> </ul> </li> <li> <p>For ARC HS38</p> <ul> <li>Build U-Boot binary image: <code>make axs103_defconfig &amp;&amp; make u-boot.bin</code></li> <li>Add jump location just before the image: <code>printf \"\\x00\\x00\\x00\\x81\" | cat - u-boot.bin &gt; u-boot-offset.bin</code></li> <li>Flash image</li> </ul> </li> </ul> <p>For ARC HS38 version 2.0 <code>arc_id</code> is <code>0x51</code>, for version 2.1 <code>arc_id</code> is <code>0x52</code>, for version 3.0 <code>arc_id</code> is <code>0x53</code>. You can use the same u-boot image for both versions but you need to pass different values to <code>axs_comm</code> <code>-c</code> option:</p> <ul> <li>ARC HS38 2.0: <code>axs_comm -c 0051 -a 00080000 -p 80FFFFFC -f u-boot-offset.bin</code></li> <li>ARC HS38 2.1: <code>axs_comm -c 0052 -a 00100000 -p 80FFFFFC -f u-boot-offset.bin</code></li> <li>ARC HS38 3.0: <code>axs_comm -c 0053 -a 00180000 -p 80FFFFFC -f u-boot-offset.bin</code></li> </ul> <p>Note for ARC HS38 3rd pin in dip-switch <code>SW2501</code> must be in <code>off</code> position (which is closer to CPU tile). Otherwise image from SPI-flash won't be read.</p>"},{"location":"linux/building/buildroot/","title":"Building Linux kernel with Filesystem Using Buildroot","text":""},{"location":"linux/building/buildroot/#getting-buildroot","title":"Getting Buildroot","text":"<p>Stable Buildroot releases are published every three months. Tarballs are available for each stable release (http://buildroot.org/downloads/). However, you can clone an upstream Git repository:</p> <pre><code>git clone https://git.busybox.net/buildroot\ncd buildroot\n</code></pre> <p>Upstream Buildroot does not support ARCv3 families. If you are going to build Linux for ARCv3 then consider using a separate Synopsys repository with patches for support of ARC HS5x and ARC HS6x:</p> <pre><code>git clone https://github.com/foss-for-synopsys-dwc-arc-processors/buildroot\ncd buildroot\n</code></pre>"},{"location":"linux/building/buildroot/#using-predefined-configurations","title":"Using Predefined Configurations","text":"<p>Buildroot uses configuration files (<code>defconfig</code>s) for configuring a root filesystem, a toolchain, a Linux kernel, etc. Buildroot comes with a number of existing predefined configurations which may be found in <code>config</code> directory. Use <code>make list-defconfigs</code> command to list all available configurations:</p> <pre><code>$ make list-defconfigs | grep snps\n  snps_arc32_defconfig                - Build for snps_arc32\n  snps_arc64_defconfig                - Build for snps_arc64\n  snps_arc700_axs101_defconfig        - Build for snps_arc700_axs101\n  snps_archs38_axs103_defconfig       - Build for snps_archs38_axs103\n  snps_archs38_haps_defconfig         - Build for snps_archs38_haps\n  snps_archs38_hsdk_defconfig         - Build for snps_archs38_hsdk\n</code></pre> <p>Here is a short description of each configuration:</p> <ul> <li><code>snps_arc32_defconfig</code> - A configuration for ARC HS5x on HAPS, nSIM or QEMU (available only in a separate repository).</li> <li><code>snps_arc64_defconfig</code> - A configuration for ARC HS6x on HAPS, nSIM or QEMU (available only in a separate repository).</li> <li><code>snps_arc700_axs101_defconfig</code> - A configuration for ARC 700 on AXS101 development board.</li> <li><code>snps_archs38_axs103_defconfig</code> - A configuration for ARC HS38 on AXS103 development board.</li> <li><code>snps_archs38_haps_defconfig</code> - A configuration for ARC HS3x/4x in ZeBU, HAPS, nSIM or QEMU.</li> <li><code>snps_archs38_hsdk_defconfig</code> - A configuration for ARC HS3x/4x on HSDK and HSDK 4xD development boards. This configuration builds images for running Linux using U-Boot.</li> </ul>"},{"location":"linux/building/buildroot/#configuring-root-filesystem","title":"Configuring Root Filesystem","text":"<p>You can select a predefined configuration this way:</p> <pre><code>make snps_archs38_haps_defconfig\n</code></pre> <p>You can manually tune filesystem's configuration this way:</p> <pre><code>make menuconfig\n</code></pre> <p>The final configuration file is saved in <code>.config</code> file.</p>"},{"location":"linux/building/buildroot/#configuring-linux-kernel","title":"Configuring Linux Kernel","text":"<p>Also, you can configure kernel's options this way:</p> <pre><code>make linux-menuconfig\n</code></pre>"},{"location":"linux/building/buildroot/#building-linux","title":"Building Linux","text":"<p>Buildroot with default configurations, which are mentioned above, builds Linux images in this sequence:</p> <ol> <li>Download sources for a toolchain and build it.</li> <li>Download sources for packages, build them using the toolchain and put them in a filesystem image (<code>rootfs</code>).</li> <li>Download sources for a Linux kernel and build it using the toolchain.</li> <li>Link the Linux kernel against <code>rootfs</code> (<code>vmlinux</code>) or save it separately from <code>rootfs</code> (<code>bzImage</code> or <code>uImage</code>). Whether <code>rootfs</code> is linked against  Linux kernel or not depends on a particular configuration. For example, <code>snps_archs38_hsdk_defconfig</code> configuration doesn't link <code>rootfs</code> against Linux kernel.</li> </ol> <p>You can build images using <code>make</code>:</p> <pre><code>make\n</code></pre> <p>By default, Buildroot builds everything in <code>output</code> directory. Images are placed in <code>output/images</code> directory. For <code>snps_archs38_haps_defconfig</code> configuration you will find a couple of filesystem images (<code>rootfs.cpio</code> and <code>rootfs.tar</code>) and <code>vmlinux</code> - a kernel with the filesystem included:</p> <pre><code>$ ls output/images\nrootfs.cpio  rootfs.tar  vmlinux\n</code></pre> <p>For example, for <code>snps_archs38_hsdk_defconfig</code> configuration you will find much more images (consider reading a guide about building Linux for HSDK for more details):</p> <pre><code>$ ls -1 output/images\nboot.vfat\nrootfs.ext2\nrootfs.ext4\nsdcard.img\nu-boot\nu-boot.bin\nuImage\nuboot-env.bin\n</code></pre>"},{"location":"linux/building/configure/","title":"Configuring Buildroot and Linux Kernel","text":""},{"location":"linux/building/configure/#preface","title":"Preface","text":"<p>This guide contains a bunch of recipes which may be useful while building Linux kernel for Synopsys ARC processors. Consider reading the Buildroot user manual for details.</p>"},{"location":"linux/building/configure/#building-in-a-separate-directory","title":"Building in a Separate Directory","text":"<p>It's a good practice to build Linux images out of the main source tree:</p> <pre><code>git clone https://git.busybox.net/buildroot\nmkdir buildroot/build\ncd buildroot/build\nmake -C .. O=$(pwd) snps_archs38_haps_defconfig\n</code></pre> <p>Option <code>-C ..</code> points to Buildroot source tree and <code>O=$(pwd)</code> passes an output directory's path to <code>make</code>. Note that if you use relative paths in Buildroot configuration options, then they are relative to Buildroot's source tree, but not to build directory.</p>"},{"location":"linux/building/configure/#selection-a-big-endian-configuration","title":"Selection a Big Endian Configuration","text":"<p>Select this option in a configuration menu:</p> <pre><code>Target options -&gt; Target Architecture -&gt; (X) ARC (big endian)\n</code></pre>"},{"location":"linux/building/configure/#selecting-a-linux-kernel-version","title":"Selecting a Linux Kernel Version","text":"<p>By default, Buildroot selects the latest available version of the upstream Linux kernel. However, if you want to use a development branch with the latest patches and support of ARCv3 processor families, then consider using <code>arc64</code> branch of the development repository:</p> <pre><code>Kernel -&gt; Kernel version -&gt; Custom Git repository\n       -&gt; URL of custom repository -&gt; https://github.com/foss-for-synopsys-dwc-arc-processors/linux\n       -&gt; Custom repository version -&gt; arc64\n</code></pre>"},{"location":"linux/building/configure/#selecting-a-linux-kernel-configuration-file","title":"Selecting a Linux Kernel Configuration File","text":"<p>You can select a Linux kernel configuration file in Buildroot configuration menu. For example:</p> <pre><code>Kernel -&gt; Defconfig name -&gt; haps_hs\n</code></pre> <p>You can find a complete list of all Linux kernel configuration files in <code>arch/arc/configs</code> directory of Linux kernel source tree:</p> <pre><code>$ ls -1 &lt;path-to-kernel-source-tree&gt;/arch/arc/configs\naxs101_defconfig\naxs103_defconfig\naxs103_smp_defconfig\nhaps_hs_defconfig\nhaps_hs_smp_defconfig\nhsdk_defconfig\nnsim_700_defconfig\nnsimosci_defconfig\nnsimosci_hs_defconfig\nnsimosci_hs_smp_defconfig\ntb10x_defconfig\nvdk_hs38_defconfig\nvdk_hs38_smp_defconfig\n</code></pre>"},{"location":"linux/building/configure/#selecting-a-prebuilt-toolchain","title":"Selecting a Prebuilt Toolchain","text":"<p>Info</p> <p>Each release of a toolchain may demand a specific set of options which must be selected/deselected manually. It happens, because when a custom toolchain is selected, Buildroot cannot detect toolchain's features automatically. Follow Buildroot's error messages for details.</p> <p>By default, Buildroot builds a Linux toolchain for ARC from scratch and may use relatively old sources for tools like GCC, Binutils, etc. If you want to use the latest available toolchain for ARC processors, then consider using prebuilt components from official releases page.</p> <p>In addition to the default values, select/deselect these options for the toolchain for ARC HS3x/4x with glibc library (2023.03 release):</p> <pre><code>Toolchain -&gt; Toolchain type -&gt; (X) External toolchain\n          -&gt; (X) Custom toolchain\n          -&gt; Toolchain origin -&gt; (X) Toolchain to be downloaded and installed\n          -&gt; Toolchain URL -&gt; https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain/releases/download/arc-2023.03-release/arc_gnu_2023.03_prebuilt_glibc_le_archs_linux_install.tar.gz\n          -&gt; External toolchain gcc version -&gt; (X) 12.x\n          -&gt; External toolchain kernel headers series -&gt; (X) 5.16.x\n          -&gt; External toolchain C library -&gt; (X) glibc\n          -&gt; [ ] Toolchain has RPC support?\n          -&gt; [X] Toolchain has C++ support?\n          -&gt; [X] Toolchain has Fortran support?\n</code></pre> <p>Additional options for the toolchain for ARC HS3x/4x with uClibc library (2023.03 release):</p> <pre><code>Toolchain -&gt; Toolchain type -&gt; (X) External toolchain\n          -&gt; (X) Custom toolchain\n          -&gt; Toolchain origin -&gt; (X) Toolchain to be downloaded and installed\n          -&gt; Toolchain URL -&gt; https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain/releases/download/arc-2023.03-release/arc_gnu_2023.03_prebuilt_uclibc_le_archs_linux_install.tar.gz\n          -&gt; External toolchain gcc version -&gt; (X) 12.x\n          -&gt; External toolchain kernel headers series -&gt; (X) 5.16.x\n          -&gt; External toolchain C library -&gt; (X) uClibc/uClibc-ng\n          -&gt; [X] Toolchain has locale support?\n          -&gt; [ ] Toolchain has RPC support?\n          -&gt; [X] Toolchain has C++ support?\n          -&gt; [X] Toolchain has Fortran support?\n</code></pre>"},{"location":"linux/building/configure/#selecting-a-preinstalled-toolchain","title":"Selecting a Preinstalled Toolchain","text":"<p>A procedure is the same as for selecting a prebuilt toolchain except these ones:</p> <pre><code>Toolchain -&gt; Toolchain origin -&gt; (X) Pre-installed toolchain\n          -&gt; Toolchain path -&gt; /tools/toolchains/arc-linux-gnu\n</code></pre>"},{"location":"linux/building/configure/#creating-a-custom-configuration-file","title":"Creating a Custom Configuration File","text":"<p>You can use <code>make savedefconfig</code> to save a current configuration to a configuration file. It reduces all configuration options to a minimum set of options.</p> <pre><code>make savedefconfig DEFCONFIG=my_defconfig\n</code></pre> <p>Configuration file <code>my_defconfig</code> is saved in Buildroot's source tree. Here is an example of a configuration file which selects a preinstalled toolchain:</p> <pre><code>BR2_arcle=y\nBR2_archs38=y\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_PATH=\"/tools/toolchains/arc-2023.03/arc-linux-gnu\"\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_5_16=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM_GLIBC=y\n# BR2_TOOLCHAIN_EXTERNAL_INET_RPC is not set\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_TOOLCHAIN_EXTERNAL_FORTRAN=y\nBR2_TARGET_GENERIC_HOSTNAME=\"zebu_hs\"\nBR2_TARGET_GENERIC_ISSUE=\"Welcome to the HAPS Development Platform\"\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_VERSION=y\nBR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE=\"5.16\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"haps_hs_smp\"\nBR2_LINUX_KERNEL_VMLINUX=y\nBR2_TARGET_ROOTFS_INITRAMFS=y\n</code></pre>"},{"location":"linux/building/configure/#using-custom-configuration-files","title":"Using Custom Configuration Files","text":"<p>You can place a custom configuration file in <code>config</code> directory in Buildroot's source tree. It allows you to use custom configuration files as usual:</p> <pre><code>make my_defconfig\n</code></pre> <p>You can use <code>defconfig</code> command and <code>DEFCONFIG</code> environment variable to pass a path to the configuration file:</p> <pre><code># Using an absolute path\n$ make defconfig DEFCONFIG=/home/user/buildroot/my_defconfig\n\n# Using a relative path (it's always relative to Buildroot's source tree)\n$ make defconfig DEFCONFIG=my_defconfig\n</code></pre>"},{"location":"linux/building/configure/#using-overlays","title":"Using Overlays","text":"<p>If you want to place addition files and directories in <code>rootfs</code>, then you can use <code>BR2_ROOTFS_OVERLAY=&lt;path&gt;</code> parameter: it contains a path to the a directory with files and directories which will be placed in the final filesystem image.</p> <p>You can select it in a configuration menu:</p> <pre><code>System configuration -&gt; Root filesystem overlay directories -&gt; overlay\n</code></pre> <p>Also you can achieve the same result by placing all necessary files and directories in <code>output/target</code> (or just <code>target</code> if you build in a separate directory) directory and rebuilding images using <code>make</code>.</p>"},{"location":"linux/building/separate/","title":"Building Linux kernel and Filesystem Separately","text":""},{"location":"linux/building/separate/#preface","title":"Preface","text":"<p>Sometimes it's more convenient to build root file system and a Linux kernel separately. This guide covers an example when it's necessary to build those images separately for ARC HS38 target.</p> <p>Suppose, that a toolchain for ARC HS38 is preinstalled in <code>/tools/toolchains/arc-linux-gnu</code>. The version is 2023.03 and it's based on glibc standard library.</p>"},{"location":"linux/building/separate/#building-root-filesystem","title":"Building Root Filesystem","text":"<p>Clone Buildroot:</p> <pre><code># Clone the latest Buildroot\ngit clone https://git.busybox.net/buildroot\n# ... or use a custom repository for support of ARCv3 targets\ngit clone https://github.com/foss-for-synopsys-dwc-arc-processors/buildroot\ncd buildroot\n</code></pre> <p>Use <code>snps_archs38_haps_defconfig</code> configuration file for this example and enter a configuration menu:</p> <pre><code>make snps_archs38_haps_defconfig\nmake menuconfig\n</code></pre> <p>Deselect an option for the Linux kernel and select an appropriate filesystem for your needs:</p> <pre><code>Kernel -&gt; [ ] Linux kernel\nFilesystem images -&gt; [*] cpio the root filesystem # For use as an initial RAM filesystem\n                  -&gt; ext2/3/4 root filesystem     # For mounting from a storage\n</code></pre> <p>Choose a preinstalled toolchain:</p> <pre><code>Toolchain -&gt; Toolchain type -&gt; (X) External toolchain\n          -&gt; (X) Custom toolchain\n          -&gt; Toolchain origin -&gt; (X) Pre-installed toolchain\n          -&gt; Toolchain path -&gt; /tools/toolchains/arc-linux-gnu\n          -&gt; External toolchain gcc version -&gt; (X) 12.x\n          -&gt; External toolchain kernel headers series -&gt; (X) 5.16.x\n          -&gt; External toolchain C library -&gt; (X) glibc\n          -&gt; [ ] Toolchain has RPC support?\n          -&gt; [X] Toolchain has C++ support?\n          -&gt; [X] Toolchain has Fortran support?\n</code></pre> <p>Build the filesystem image:</p> <pre><code>make\n</code></pre>"},{"location":"linux/building/separate/#building-the-linux-kernel-without-initial-root-filesystem","title":"Building the Linux Kernel Without Initial Root Filesystem","text":"<p>Clone a Linux kernel repository and choose a version you want:</p> <pre><code>git clone https://github.com/torvalds/linux\ncd linux\ngit checkout v6.4\n</code></pre> <p>Configure the kernel:</p> <pre><code>make ARCH=arc haps_hs_defconfig\n</code></pre> <p>Put the toolchain to <code>PATH</code> environment variable and build the kernel:</p> <pre><code>export PATH=/tools/toolchains/arc-linux-gnu:$PATH\nmake ARCH=arc CROSS_COMPILE=arc-linux-\n</code></pre> <p>The Linux kernel is saved as <code>vmlinux</code> file.</p>"},{"location":"linux/building/separate/#building-the-linux-kernel-with-initial-root-filesystem","title":"Building the Linux Kernel With Initial Root Filesystem","text":"<p>To link the Linux kernel with previously built root filesystem image (with <code>.cpio</code> extension), it's necessary to set <code>CONFIG_INITRAMFS_SOURCE</code> options for the kernel. Configure the kernel and enter a configuration menu:</p> <pre><code>make ARCH=arc haps_hs_defconfig\nmake ARCH=arc menuconfig\n</code></pre> <p>Fill <code>CONFIG_INITRAMFS_SOURCE</code> parameter with a path to <code>rootfs.cpio</code>, which was built previously:</p> <pre><code>General setup -&gt; Initial RAM filesystem and RAM disk support\n                 -&gt; Initramfs source file(s) -&gt; &lt;Buildroot-source-tree&gt;/output/images/rootfs.cpio\n</code></pre> <p>Put the toolchain to <code>PATH</code> environment variable and build the kernel:</p> <pre><code>export PATH=/tools/toolchains/arc-linux-gnu:$PATH\nmake ARCH=arc CROSS_COMPILE=arc-linux-\n</code></pre> <p>The Linux kernel with root file system is saved as <code>vmlinux</code> file.</p>"},{"location":"linux/ebpf/build/","title":"Building Linux Image for Working with eBPF in QEMU","text":""},{"location":"linux/ebpf/build/#overview","title":"Overview","text":"<p>This is a comprehensive guide about creating an environment for building, running and debugging eBPF programs for ARC processors using GNU toolchain and QEMU. Though we consider ARC HS 3x/4x on QEMU as a reference platform, the same guide is applicable for boards like HS Development Kit.</p> <p>This guide consists of these steps:</p> <ol> <li>Preparing your Linux host for building <code>rootfs</code> (Buildroot), Linux    kernel, third-party tools and libraries.</li> <li>Building and installing third-party tools and libraries: <code>elfutils</code>,    <code>pahole</code> and <code>bpftool</code>. We are going to build them manually to    ensure that the latest versions are used.</li> <li>Preparing the building environment: cloning all necessary    repositories, configuring SSH keys, etc.</li> <li>Building <code>rootfs</code> (Buildroot) image and the Linux kernel.</li> <li>Building and running eBPF programs.</li> </ol>"},{"location":"linux/ebpf/build/#preparing-linux-host","title":"Preparing Linux Host","text":"<p>We assume that toolchain directory for ARC HS 3x/4x is placed in <code>/tools/arc-linux-gnu</code> (the directory which contains <code>bin</code>). Ensure that <code>/tools/arc-linux-gnu/bin</code> is in <code>PATH</code> environment variable. We are going to use <code>/tools</code> directory for installing tools and libraries. You can use any other path, just do not forget to consider it while reading this guide.</p> <p>The latest release may be downloaded here (\"Linux/glibc ARC HS\" variant):</p> <ul> <li>https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain/releases</li> </ul> <p>Standard development tools must be installed on your host: <code>make</code>, <code>cmake</code>, <code>git</code>, <code>rsync</code>, <code>gcc</code>, <code>binutils</code>, <code>clang</code> (for building eBPF programs).</p>"},{"location":"linux/ebpf/build/#notes-for-centos-7","title":"Notes for CentOS 7","text":"<p>It is necessary to install the latest available development tools for CentOS 7 to make it possible to build everything without problems. Use <code>centos-release-scl</code> repository to install the latest tools and Git. Then, have them enabled.</p> <pre><code>sudo yum install centos-release-scl\nsudo yum install devtoolset-9 rh-git227\nscl enable devtoolset-9 rh-git227 bash\n</code></pre>"},{"location":"linux/ebpf/build/#preparing-tools-and-libraries","title":"Preparing Tools and Libraries","text":"<p>We are going to build and install some tools an libraries manually:</p> <ol> <li><code>pahole</code> host tool is used during the generation of BTF information    for the Linux image. We have to use version \u22641.23 because later versions    generate BTF information for 64-bit enumerations. However, the Linux    kernel of version \u22646.0 contains tools which don't support such BTF    records and building fails on the last stage. We need to ensure that a    proper <code>pahole</code> is used.</li> <li><code>elfutils</code> host libraries of version \u22650.189 must be presented in    <code>LD_LIBRARY_PATH</code> because <code>pahole</code> relies on them for working with    binaries. Support of ARCv2 was added in <code>elfutils</code> 0.189, thus we need    to ensure that <code>pahole</code> is linked with recent-enough <code>elfutils</code>    libraries.</li> <li><code>bpftool</code> of version \u22657 must be used for building eBPF program which    use features like <code>bpf_loop</code>, calls to another functions, etc. Older    versions do not support new type of relocations for such features. If    you are experiencing problems with host's <code>bpftool</code> (e.g., Ubuntu 22.04    is shipped with an outdated <code>bpftool</code> which may fail while building the    kernel) then it would be better to build and install it manually.</li> </ol>"},{"location":"linux/ebpf/build/#building-and-installing-elfutils","title":"Building and Installing <code>elfutils</code>","text":"<pre><code># Install dependencies for CentOS 7\nsudo yum install libmicrohttpd libmicrohttpd-devel libsq3 libsq3-devel \\\nlibarchive libarchive-devel gettext-devel zstd libcurl-devel\n\n# Install dependencies for the latest Fedora\nsudo dnf install libmicrohttpd libmicrohttpd-devel libsq3 libsq3-devel \\\nlibarchive libarchive-devel gettext-devel\n\n# Install dependencies for Ubuntu 18.04\nsudo apt install libmicrohttpd-dev libsqlite3-dev libarchive-dev\n\n# Clone, configure and build elfutils (use your own prefix instead of /tools/elfutils)\ngit clone -b elfutils-0.189 https://sourceware.org/git/elfutils.git\ncd elfutils\nautoreconf -fi\nmkdir build\ncd build\n../configure --prefix=/tools/elfutils --enable-maintainer-mode\nmake\nmake install\n\n# Configure your environment\nexport PATH=/tools/elfutils/bin:$PATH\nexport LD_LIBRARY_PATH=/tools/elfutils/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\n</code></pre>"},{"location":"linux/ebpf/build/#building-and-installing-pahole","title":"Building and Installing <code>pahole</code>","text":"<pre><code># Clone, configure and build pahole (use your own prefix instead of /tools/pahole)\ngit clone -b v1.23 https://git.kernel.org/pub/scm/devel/pahole/pahole.git\nmkdir pahole/build\ncd pahole/build\ncmake -G \"Unix Makefiles\"                              \\\n-D__LIB=lib                                      \\\n-DDWARF_INCLUDE_DIR=/tools/elfutils/include      \\\n-DLIBDW_INCLUDE_DIR=/tools/elfutils/include      \\\n-DDWARF_LIBRARY=/tools/elfutils/lib/libdw.so.1   \\\n-DELF_LIBRARY=/tools/elfutils/lib/libelf.so.1    \\\n-DCMAKE_INSTALL_PREFIX=/tools/pahole             \\\n..\nmake install\n\n# Configure your environment\nexport PATH=/tools/pahole/bin:$PATH\nexport LD_LIBRARY_PATH=/tools/pahole/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\n</code></pre>"},{"location":"linux/ebpf/build/#building-and-installing-bpftool","title":"Building and Installing <code>bpftool</code>","text":"<pre><code># Clone and build bpftool (use your own prefix instead of /tools/bpftool)\ngit clone --recurse-submodules https://github.com/libbpf/bpftool.git\ncd bpftool/src\nmake prefix=/tools/bpftool EXTRA_CFLAGS=\"-I/tools/elfutils/include\" \\\nEXTRA_LDFLAGS=\"-L/tools/elfutils/lib\"    \\\ninstall-bin\n\n# Configure your environment\nexport PATH=/tools/bpftool/sbin/:$PATH\n</code></pre>"},{"location":"linux/ebpf/build/#preparing-building-environment","title":"Preparing Building Environment","text":""},{"location":"linux/ebpf/build/#cloning-arc-ebpf-testbench","title":"Cloning ARC eBPF Testbench","text":"<p>Clone ARC eBPF testbench. This repository contains configuration files for Buildroot and Linux kernel which simplify setup of the environment for working with eBPF. We are going to use it as a working directory.</p> <pre><code>git clone --recurse-submodules https://github.com/foss-for-synopsys-dwc-arc-processors/arc-bpf-testbench\ncd arc-bpf-testbench\n</code></pre>"},{"location":"linux/ebpf/build/#preparing-buildroot","title":"Preparing Buildroot","text":"<p>Clone Buildroot, create a build directory and copy all necessary configuration files and an overlay to the build directory from <code>arc-bpf-testbench/extras</code>:</p> <pre><code>git clone https://git.buildroot.net/buildroot\nmkdir buildroot/build\ncp -r extras/buildroot/* buildroot/build\n</code></pre> <p>List of copied files and directories:</p> <ol> <li><code>busybox.fragment</code> - A configuration file for BusyBox.</li> <li><code>device_table.txt</code> - A configuration file fo setting proper    permissions for files in the overlay.</li> <li><code>qemu_hs4x_ebpf_defconfig</code> - A configuration file for Buildroot.</li> <li><code>overlay</code> - All necessary additional files for target's file system    (configuration files, testing SSH keys, etc.).</li> </ol> <p>It's assumed here that the root directory for the toolchain is <code>/tools/arc-linux-gnu</code>. Thus you need to change <code>BR2_TOOLCHAIN_EXTERNAL_PATH</code> in <code>qemu_hs4x_ebpf_defconfig</code> configuration file for Buildroot to the corresponding path.</p>"},{"location":"linux/ebpf/build/#preparing-linux-sources","title":"Preparing Linux Sources","text":"<p>Clone repository of the Linux kernel with the latest patches for support of eBPF with JIT and copy a corresponding configuration file:</p> <pre><code>git clone -b bpf-early-access https://github.com/foss-for-synopsys-dwc-arc-processors/linux\nmkdir linux/build\ncp extras/linux/qemu_hs4x_ebpf_defconfig linux/arch/arc/configs\n</code></pre>"},{"location":"linux/ebpf/build/#installing-ssh-keys-for-users-authentication","title":"Installing SSH Keys for User's Authentication","text":"<p>We are going to use SSH for interacting with the ARC Linux system. It would be helpful to have keys for public key authorization without using a password.</p> <p>You can copy the pregenerated keys from <code>extras/host/.ssh/keys</code> to the corresponding host's directory <code>~/.ssh/keys</code>. Public key for this pair of keys is already installed in the <code>buildroot/build/overlay/root/.ssh</code> directory. Don't forget to apply proper rights for those keys in <code>.ssh</code> for your host (600).</p> <p>Configure your SSH hosts in <code>~/.ssh/config</code> (you also can find this file in <code>extras/host/.ssh/config</code>):</p> <pre><code>Host arc\n    HostName            127.0.0.1\n    Port                2022\n    User                root\n    IdentityFile        ~/.ssh/keys/arc\n\nHost arc-tap\n    HostName            10.42.0.100\n    Port                22\n    User                root\n    IdentityFile        ~/.ssh/keys/arc\n</code></pre> <p>Also, you can generate your own keys (use your own home path):</p> <pre><code>$ mkdir -p ~/.ssh/keys\n$ ssh-keygen -t rsa -C \"arc@ebpf\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/user/.ssh/id_rsa): /home/user/.ssh/keys/arc\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/user/.ssh/keys/arc\nYour public key has been saved in /home/user/.ssh/keys/arc.pub\n</code></pre> <p>Add your public key to the overlay directory:</p> <pre><code>mkdir -p buildroot/build/overlay/root/.ssh\ncp -f ~/.ssh/keys/arc.pub buildroot/build/overlay/root/.ssh/authorized_keys\n</code></pre>"},{"location":"linux/ebpf/build/#install-ssh-keys-for-hosts-authentication-host-keys","title":"Install SSH Keys for Host's Authentication (Host Keys)","text":"<p>By default, Linux with SSH daemon installed generates random host keys if they don't exist. For testing and debugging purposes using QEMU it may lead to these difficulties:</p> <ol> <li>Generating a set of host keys in QEMU may take a lot of time.</li> <li>Each time you run QEMU with <code>vmlinux</code> image new keys a generated.    Thus, you have to clear cached host key for the QEMU instance to    avoid complaining about the changed target's host key.</li> </ol> <p>Overlay already contains pregenerated host keys. However, you can generate your own keys:</p> <pre><code>ssh-keygen -A -f buildroot/build/overlay\n</code></pre>"},{"location":"linux/ebpf/build/#building-images","title":"Building Images","text":""},{"location":"linux/ebpf/build/#building-rootfscpio","title":"Building <code>rootfs.cpio</code>","text":"<p>Warning</p> <p>Buildroot requires Git of version 2+. Some old systems (e.g., CentOS 7) have an outdated Git which is not supported by Buildroot's build system. If you face this problem then you have to find a way to install newer version of Git (e.g., using third-party repositories).</p> <p>Info</p> <p>SSHFS package requires <code>docutils</code> module for Python. Install it using your package manager or using <code>pip</code> (<code>pip install docutils</code>) or delete the <code>BR2_PACKAGE_SSHFS=y</code> line if you aren't going to use SSHFS.</p> <p>Info</p> <p>Buildroot may complain about invalid headers' version for the toolchain: <code>Incorrect selection of kernel headers: expected 5.16.x, got 5.18.x</code> E.g., <code>2022.09</code> release is shipped with headers for Linux kernel 5.16.x. If it's not your case then manually change headers' versions for the toolchain using <code>make menuconfig</code>.</p> <pre><code>cd buildroot/build\nmake -C .. O=$(pwd) defconfig BR2_DEFCONFIG=build/qemu_hs4x_ebpf_defconfig\nmake -j $(nproc)\n</code></pre>"},{"location":"linux/ebpf/build/#building-vmlinux","title":"Building <code>vmlinux</code>","text":"<p>Set necessary environment variables and build the kernel:</p> <pre><code>cd ../../linux/build\nexport ARCH=arc\nexport CROSS_COMPILE=arc-linux-gnu-\nexport C_INCLUDE_PATH=\"/tools/elfutils/include\"\nexport LIBRARY_PATH=\"/tools/elfutils/lib\"\nmake -C .. O=$(pwd) qemu_hs4x_ebpf_defconfig\nmake -j $(nproc)\n</code></pre>"},{"location":"linux/ebpf/build/#workarounds-for-well-known-pitfalls","title":"Workarounds for Well Known Pitfalls","text":""},{"location":"linux/ebpf/build/#errors-while-building-kernels-ebpf-files","title":"Errors While Building Kernel's eBPF Files","text":"<p>Change <code>kernel/bpf/Makefile</code> to prevent some build errors:</p> <pre><code>diff --git a/kernel/bpf/Makefile b/kernel/bpf/Makefile\nindex ae90af5b0425..4699a022079a 100644\n--- a/kernel/bpf/Makefile\n+++ b/kernel/bpf/Makefile\n@@ -4,7 +4,7 @@ ifneq ($(CONFIG_BPF_JIT_ALWAYS_ON),y)\n# ___bpf_prog_run() needs GCSE disabled on x86; see 3193c0836f203 for details\ncflags-nogcse-$(CONFIG_X86)$(CONFIG_CC_IS_GCC) := -fno-gcse\nendif\n-CFLAGS_core.o += $(call cc-disable-warning, override-init) $(cflags-nogcse-yy) -Og -g3\n+CFLAGS_core.o += $(call cc-disable-warning, override-init) $(cflags-nogcse-yy) -Og -g3 -finline-functions-called-once\n</code></pre>"},{"location":"linux/ebpf/build/#workaround-for-complex-float-error","title":"Workaround for <code>complex float</code> error","text":"<p>Toolchains for ARC generate <code>complex float</code> DIE entries in <code>libgcc</code>. At the moment such entries are not supported by <code>pahole</code>. So, it's necessary to disable generating BTF for floats. It's already done in <code>bpf-early-access</code> branch but if you want to build the Linux kernel from another branch or repository with BTF information you can apply this patch:</p> <pre><code>diff --git a/scripts/pahole-flags.sh b/scripts/pahole-flags.sh\nindex 0d99ef17e4a5..23af14c6ef94 100755\n--- a/scripts/pahole-flags.sh\n+++ b/scripts/pahole-flags.sh\n@@ -14,7 +14,7 @@ if [ \"${pahole_ver}\" -ge \"118\" ] &amp;&amp; [ \"${pahole_ver}\" -le \"121\" ]; then\n       extra_paholeopt=\"${extra_paholeopt} --skip_encoding_btf_vars\"\nfi\nif [ \"${pahole_ver}\" -ge \"121\" ]; then\n-       extra_paholeopt=\"${extra_paholeopt} --btf_gen_floats\"\n+       extra_paholeopt=\"${extra_paholeopt}\"\nfi\nif [ \"${pahole_ver}\" -ge \"122\" ]; then\n        extra_paholeopt=\"${extra_paholeopt} -j\"\n</code></pre>"},{"location":"linux/ebpf/build/#running-linux-image-using-qemu","title":"Running Linux Image Using QEMU","text":"<p>All actions mentioned below are performed from the working directory (root of <code>arc-bpf-testbench</code>).</p>"},{"location":"linux/ebpf/build/#running-linux-using-user-level-network-interface","title":"Running Linux Using User Level Network Interface","text":"<pre><code>make qemu-start\n</code></pre>"},{"location":"linux/ebpf/build/#running-linux-using-tuntap-network-interface","title":"Running Linux Using TUN/TAP Network Interface","text":"<p>TUN/TAP network interface allows interacting of the target with your host in both directions. For example, you can mount host's NFS directories inside of the target. Configure TUN/TAP interface on host's side:</p> <pre><code># Manually\nsudo ip tuntap add tap1 mode tap\nsudo ip addr add 10.42.0.1/24 dev tap1\nsudo ip link set tap1 up\n\n# ... or using testbench\nsudo make tap\n</code></pre> <p>Then run <code>vmlinux</code>:</p> <pre><code>make USE_TAP=1 qemu-start\n</code></pre> <p>Configure a network interface on target's side:</p> <pre><code>ifconfig eth0 10.42.0.100\n</code></pre>"},{"location":"linux/ebpf/build/#configuring-linux","title":"Configuring Linux","text":"<p>Mount <code>debugfs</code> and turn JIT on:</p> <pre><code># On host's side\nssh arc \"mount -t debugfs debugfs /sys/kernel/debug\"\nssh arc \"sysctl net.core.bpf_jit_enable=1\"\n# ... or on target's side\nmount -t debugfs debugfs /sys/kernel/debug\nsysctl net.core.bpf_jit_enable=1\n# ... or using testbench for user level network interface\nmake qemu-setup\n\n# ... or using testbench for tun/tap network interface\nmake USE_TAP=1 qemu-setup\n</code></pre>"},{"location":"linux/ebpf/build/#running-kernels-basic-ebpf-tests","title":"Running Kernel's Basic eBPF Tests","text":"<p>Send a module for testing to the target:</p> <pre><code># For user level network interface\nrsync linux/build/lib/test_bpf.ko arc:/root\n\n# For TUN/TAP network interface\nrsync linux/build/lib/test_bpf.ko arc-tap:/root\n</code></pre> <p>Run the module on the target:</p> <pre><code># Run all tests\ninsmod test_bpf.ko\n\n# Run a specific\ninsmod test_bpf.ko test_id=42\n# Run a range of tests\ninsmod test_bpf.ko test_range=42,142\n</code></pre>"},{"location":"linux/ebpf/build/#building-and-running-ebpf-programs","title":"Building and Running eBPF Programs","text":"<p>Warning</p> <p>Old operating systems like CentOS 7 and Ubuntu 18.04 contain old versions of <code>clang</code> which may not be sufficient for building modern eBPF programs. If building eBPF programs fails then try to build the latest <code>clang</code> with eBPF target following a corresponding guide and put it into <code>PATH</code>.</p> <p>Testbench contains a bunch of examples of eBPF programs. You can build and load them using these commands from the root directory of the testbench:</p> <pre><code># Build dependencies\nmake\n\n# Load programs for user level network interface\nmake qemu-load\n\n# or for TUN/TAP network interface\nmake USE_TAP=1 qemu-load\n</code></pre> <p>Run a program:</p> <pre><code># Manually on target's side\n./minimal\n\n# ... or using testbench on host's side\nmake run-minimal\n</code></pre> <p>Explore <code>README.md</code> for ARC eBPF Testbench or run <code>make help</code> for information about available commands.</p>"},{"location":"linux/ebpf/build/#using-nfs-for-building-ebpf-programs-right-on-the-target","title":"Using NFS for Building eBPF Programs Right on the Target","text":""},{"location":"linux/ebpf/build/#configuring-nfs-in-centos-7-or-fedora","title":"Configuring NFS in CentOS 7 or Fedora","text":"<p>Install NFS to the host:</p> <pre><code># For CentOS 7\nsudo yum install nfs-utils\n\n# For Fedora\nsudo dnf install nfs-utils\n</code></pre> <p>Enable services and add rules for firewall:</p> <pre><code>sudo systemctl enable --now rpcbind nfs-server\nsudo firewall-cmd --add-service=nfs --permanent\nsudo firewall-cmd --reload\n\n# Optional (only if you are going to use SSHFS instead of NFS)\nsudo systemctl enable sshd\nsudo systemctl start sshd\n</code></pre>"},{"location":"linux/ebpf/build/#configuring-nfs-in-ubuntu-1804","title":"Configuring NFS in Ubuntu 18.04","text":"<p>Install NFS to the host and enable it:</p> <pre><code>sudo apt install nfs-kernel-server\nsudo systemctl enable --now nfs-server\n</code></pre>"},{"location":"linux/ebpf/build/#configuring-etcexports","title":"Configuring <code>/etc/exports</code>","text":"<p>Add this line to <code>/etc/exports</code> (you can find <code>anonuid</code> and <code>anongid</code> for your user using <code>id -u</code> and <code>id -g</code> respectively):</p> <pre><code>/nfs *(rw,all_squash,anonuid=1000,anongid=1000,no_subtree_check,insecure)\n</code></pre> <p>Update the table of exported NFS file systems:</p> <pre><code>sudo exportfs -rv\n</code></pre>"},{"location":"linux/ebpf/build/#mounting-nfs-directory-inside-the-guest","title":"Mounting NFS Directory Inside the Guest","text":"<p>Create a directory for mounting NFS directory on target's side:</p> <pre><code>mkdir /nfs\n</code></pre> <p>If you use user level network interface for running QEMU then just run these commands inside the guest:</p> <pre><code># Using NFS\nmount -t nfs 10.0.2.2:/nfs /nfs -o nolock\n\n# Using SSHFS\nsshfs -o idmap=user,allow_other user@10.0.2.2:/nfs /nfs\n</code></pre> <p>If you prefer using TUN/TAP network interface, then run QEMU like <code>make USE_TAP=1 qemu-start</code> and configure guest's network interface as mentioned earlier. Then run this line on target's side:</p> <pre><code># Using NFS\nmount -t nfs 10.42.0.1:/nfs /nfs -o nolock\n\n# Using SSHFS\nsshfs -o idmap=user,allow_other user@10.42.0.1:/nfs /nfs\n</code></pre>"},{"location":"linux/ebpf/build/#preparing-tools","title":"Preparing Tools","text":"<p>Build Clang for ARC and place a directory with <code>clang</code> to <code>/nfs</code> (the full path to Clang root directory must be <code>/nfs/clang</code>).</p> <p>Download, unpack and place a native glibc ARC HS toolchain into <code>/nfs/arc-linux-gnu</code>.</p> <p>Copy <code>/tools/arc-linux-gnu/sysroot</code> to <code>/nfs/sysroot</code>. Also build applications using testbench (run <code>make</code> from the root directory of the testbench) and copy headers to the sysroot:</p> <pre><code>cp -r output/arc/deps/include/* /nfs/sysroot/usr/include/\n</code></pre> <p>Copy applications from the testbench:</p> <pre><code>cp -r apps /nfs\n</code></pre>"},{"location":"linux/ebpf/build/#building-a-ebpf-application","title":"Building a eBPF Application","text":"<p>Use these commands inside the ARC guest (QEMU):</p> <pre><code># Configure your PATH\nexport PATH=\"/nfs/clang/bin:$PATH\"\nexport PATH=\"/nfs/arc-linux-gnu/bin:$PATH\"\n# Build \"minimal\"\ncd /nfs/apps\nclang -g                         \\\n-O2                        \\\n-target bpf                \\\n-D__TARGET_ARCH_arc        \\\n-I/nfs/sysroot/usr/include \\\n-c minimal.bpf.c           \\\n-o minimal.bpf.o\n\nbpftool gen skeleton minimal.bpf.o &gt; minimal.skel.h\n\ngcc -I/nfs/sysroot/usr/include \\\n-L/usr/lib minimal.c       \\\n-lbpf                      \\\n-lelf                      \\\n-lz                        \\\n-o minimal\n\n# Prepare the Linux kernel\nmount -t debugfs debugfs /sys/kernel/debug\nsysctl net.core.bpf_jit_enable=1\n# Run the application\n./minimal\n</code></pre>"},{"location":"linux/ebpf/clang/","title":"Building Clang with eBPF Target for ARC HS Hosts","text":""},{"location":"linux/ebpf/clang/#preface","title":"Preface","text":"<p>If you want to build eBPF programs right on the target, then you need to properly build Clang for ARC. There is no need for all possible targets, so we are going to build Clang with support of eBPF target only.</p>"},{"location":"linux/ebpf/clang/#notes-for-centos-7","title":"Notes for CentOS 7","text":"<p>It's necessary to install the latest available development tools for CentOS 7 to make it possible to build <code>clang</code>. Use <code>centos-release-scl</code> repository to install the latest tools and enable them:</p> <pre><code>sudo yum install centos-release-scl\nsudo yum install devtoolset-9\nscl enable devtoolset-9 bash\n</code></pre> <p>Also <code>llvm</code> build system requires new CMake. Install <code>cmake3</code> packages and use it instead of <code>cmake</code>:</p> <pre><code>sudo yum install cmake3\n</code></pre>"},{"location":"linux/ebpf/clang/#notes-for-ubuntu-1804","title":"Notes for Ubuntu 18.04","text":"<p><code>llvm</code> build system requires new CMake. To install it on Ubuntu 18.04 you can use <code>cmake</code> package provided by CMake's team:</p> <ul> <li>https://apt.kitware.com</li> </ul>"},{"location":"linux/ebpf/clang/#building-clang-toolchain-for-host","title":"Building Clang Toolchain for Host","text":"<p>Prepare sources:</p> <pre><code>git clone https://github.com/llvm/llvm-project.git\nmkdir llvm-project/build\ncd llvm-project/build\n</code></pre> <p>Prepare build system using CMake:</p> <pre><code>cmake -DCMAKE_INSTALL_PREFIX=/tools/clang-bpf \\\n-DLLVM_ENABLE_PROJECTS=clang            \\\n-DLLVM_TARGETS_TO_BUILD=BPF             \\\n-DLLVM_INCLUDE_BENCHMARKS=OFF           \\\n-DLLVM_ENABLE_PIC=ON                    \\\n-DLLVM_ENABLE_WARNINGS=OFF              \\\n-DLLVM_ENABLE_ZLIB=OFF                  \\\n-DLLVM_INCLUDE_EXAMPLES=OFF             \\\n-DLLVM_INCLUDE_TESTS=OFF                \\\n-DCMAKE_BUILD_TYPE=Release              \\\n-G \"Unix Makefiles\"                     \\\n../llvm\n</code></pre> <p>Build and install to <code>/tools/clang-bpf</code>:</p> <pre><code>make -j $(nproc)\nmake install\n</code></pre>"},{"location":"linux/ebpf/clang/#building-native-clang-toolchain-for-arc","title":"Building Native Clang Toolchain for ARC","text":"<p>Prepare sources:</p> <pre><code>git clone https://github.com/llvm/llvm-project.git\nmkdir llvm-project/build\ncd llvm-project/build\n</code></pre> <p>Clang's build system (CMake) uses a toolchain file for configuring cross-compiler. Suppose that the toolchain for ARC HS 4x is placed in <code>/tools/arc-linux-gnu</code> (the directory which contains <code>bin</code>). Save this configuration to <code>~/arc.cmake</code>:</p> <pre><code>SET(CMAKE_SYSTEM_NAME Linux)\nSET(CMAKE_HOST_SYSTEM_PROCESSOR arc)\nSET(CMAKE_HOST_SYSTEM_PROCESSOR Linux)\nSET(CMAKE_HOST_SYSTEM_PROCESSOR gnu)\nSET(CMAKE_SYSTEM_VERSION 1)\nSET(CMAKE_C_COMPILER /tools/arc-linux-gnu/bin/arc-linux-gnu-gcc)\nSET(CMAKE_CXX_COMPILER /tools/arc-linux-gnu/bin/arc-linux-gnu-g++)\nSET(CMAKE_FIND_ROOT_PATH /tools/arc-linux-gnu/sysroot)\n# Search for programs in the build host directories\nSET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n# ... for libraries and headers in the target directories\nSET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nSET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nSET(HAVE_POSIX_REGEX 0)\nSET(HAVE_STEADY_CLOCK 0)\n</code></pre> <p>Prepare build system using CMake:</p> <pre><code>cmake -DCMAKE_TOOLCHAIN_FILE=~/arc.cmake          \\\n-DCMAKE_INSTALL_PREFIX=/tools/clang-bpf-arc \\\n-DLLVM_ENABLE_PROJECTS=clang                \\\n-DLLVM_TARGETS_TO_BUILD=BPF                 \\\n-DCMAKE_BUILD_TYPE=MinSizeRel               \\\n-DLLVM_INCLUDE_BENCHMARKS=OFF               \\\n-DLLVM_ENABLE_PIC=ON                        \\\n-DBUILD_SHARED_LIBS=ON                      \\\n-DLLVM_ENABLE_WARNINGS=OFF                  \\\n-DLLVM_ENABLE_ZLIB=OFF                      \\\n-DLLVM_INCLUDE_EXAMPLES=OFF                 \\\n-DLLVM_INCLUDE_TESTS=OFF                    \\\n-DCMAKE_EXE_LINKER_FLAGS=\"-latomic\"         \\\n-DCMAKE_MODULE_LINKER_FLAGS=\"-latomic\"      \\\n-DCMAKE_SHARED_LINKER_FLAGS=\"-latomic\"      \\\n-G \"Unix Makefiles\"                         \\\n../llvm\n</code></pre> <p>Explanation for some options:</p> <ul> <li><code>-DCMAKE_BUILD_TYPE=MinSizeRel</code> - Turn on optimizations for size.</li> <li><code>-DLLVM_INCLUDE_BENCHMARKS=OFF</code> - Turn off benchmarks to avoid fails while building.</li> <li><code>-DBUILD_SHARED_LIBS=ON</code> - Don't build Clang as one large blob (more than 100 MB) because   linker cannot resolve relocations for such large binaries.</li> <li><code>-DCMAKE_***_LINKER_FLAGS=\"-latomic\"</code> - Somehow <code>-latomic</code> is not passed to the linker while   building. Thus we need to pass it manually.</li> </ul> <p>Build and install to <code>/tools/clang-bpf-arc</code>:</p> <pre><code>make -j $(nproc)\nmake install\n</code></pre> <p>Then you can copy this directory to your target (e.g., to the overlay for Buildroot).</p>"},{"location":"linux/ebpf/clang/#resources","title":"Resources","text":"<ul> <li>https://clang.llvm.org/get_started.html</li> <li>https://llvm.org/docs/CMake.html#frequently-used-cmake-variables</li> <li>https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/CrossCompiling</li> <li>https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html</li> </ul>"},{"location":"linux/ebpf/cross/","title":"Cross-compiling eBPF Programs","text":"<p>Info</p> <p>You can use the testbench that automates all the above steps for building eBPF programs for ARC.</p>"},{"location":"linux/ebpf/cross/#preface","title":"Preface","text":"<p>There are several ways of building eBPF applications for Linux. The main and most straightforward way consists of these steps:</p> <ol> <li>Build the eBPF part using Clang (it's a regular Object in ELF format).</li> <li>Generate a special C file named \"skeleton\" which contains an entire blob    for the eBPF part and the functions for loading it using <code>libbpf</code>.</li> <li>Write a C program which uses these functions for opening the eBPF    application, loading it into the kernel and attaching it to events.</li> <li>Build your C program using GCC toolchain and run on your target.</li> </ol>"},{"location":"linux/ebpf/cross/#building-ebpf-programs-natively-eg-x86-host-and-target","title":"Building eBPF Programs Natively (e.g. x86 host and target)","text":"<p>Consider the <code>minimal</code> program from <code>libbpf-bootstrap</code> repository. It consists of 2 file: <code>minimal.c</code> and <code>minimal.bpf.c</code>. Ensure that <code>libbpf</code> and the corresponding development files are installed (e.g., for Fedora you need to install <code>libbpf</code> and <code>libbpf-devel</code> packages). Also, a recent version of <code>bpftool</code> utility must be installed. Then you can build the program using these commands (replace <code>-D__TARGET_ARCH_x86</code> by an appropriate one for your platform):</p> <pre><code>clang -g                  \\\n-O2                 \\\n-Wall               \\\n-target bpf         \\\n-D__TARGET_ARCH_x86 \\\n-c minimal.bpf.c    \\\n-o minimal.bpf.o\n\nbpftool gen skeleton minimal.bpf.o &gt; minimal.skel.h\n\ngcc minimal.c -lbpf       \\\n-lelf       \\\n-lz         \\\n-o minimal\n</code></pre> <p>Then you can run this program with <code>root</code> privileges:</p> <pre><code># The 2 commands below are a one-time setup. Run them with root privileges.\nmount -t debugfs debugfs /sys/kernel/debug\nsysctl net.core.bpf_jit_enable=1           # Keep 0, if you don't want JIT.\n\n$ sudo ./minimal \n[sudo] password for user: \nlibbpf: loading object 'minimal_bpf' from buffer\nlibbpf: elf: section(3) tp/syscalls/sys_enter_write, size 104, link 0, flags 6, type=1\nlibbpf: sec 'tp/syscalls/sys_enter_write': found program 'handle_tp' at insn offset 0 (0 bytes), code size 13 insns (104 bytes)\nlibbpf: elf: section(4) .reltp/syscalls/sys_enter_write, size 32, link 22, flags 40, type=9\nlibbpf: elf: section(5) license, size 13, link 0, flags 3, type=1\nlibbpf: license of minimal_bpf is Dual BSD/GPL\nlibbpf: elf: section(6) .bss, size 4, link 0, flags 3, type=8\nlibbpf: elf: section(7) .rodata, size 28, link 0, flags 2, type=1\nlibbpf: elf: section(13) .BTF, size 609, link 0, flags 0, type=1\nlibbpf: elf: section(15) .BTF.ext, size 160, link 0, flags 0, type=1\nlibbpf: elf: section(22) .symtab, size 336, link 1, flags 0, type=2\nlibbpf: looking for externs among 14 symbols...\nlibbpf: collected 0 externs total\nlibbpf: map 'minimal_.bss' (global data): at sec_idx 6, offset 0, flags 400.\nlibbpf: map 0 is \"minimal_.bss\"\nlibbpf: map 'minimal_.rodata' (global data): at sec_idx 7, offset 0, flags 480.\nlibbpf: map 1 is \"minimal_.rodata\"\nlibbpf: sec '.reltp/syscalls/sys_enter_write': collecting relocation for section(3) 'tp/syscalls/sys_enter_write'\nlibbpf: sec '.reltp/syscalls/sys_enter_write': relo #0: insn #2 against 'my_pid'\nlibbpf: prog 'handle_tp': found data map 0 (minimal_.bss, sec 6, off 0) for insn 2\nlibbpf: sec '.reltp/syscalls/sys_enter_write': relo #1: insn #6 against '.rodata'\nlibbpf: prog 'handle_tp': found data map 1 (minimal_.rodata, sec 7, off 0) for insn 6\nlibbpf: map 'minimal_.bss': created successfully, fd=4\nlibbpf: map 'minimal_.rodata': created successfully, fd=5\nSuccessfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` to see output of the BPF programs.\n</code></pre> <p>Some examples from <code>libbpf-bootstrap</code> use <code>vmlinux.h</code> - it's a header file with the definitions of all the data structures for that particular kernel. The easiest way to obtain it on the host system is by using <code>bpftool</code>, if the kernel was built with <code>CONFIG_DEBUG_INFO_BTF=y</code>:</p> <pre><code>bpftool --debug btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n</code></pre> <p>Else, you can generate <code>vmlinux.h</code> from any <code>vmlinux</code> image with BTF information:</p> <pre><code>bpftool --debug btf dump file path/to/your/vmlinux format c &gt; vmlinux.h\n</code></pre>"},{"location":"linux/ebpf/cross/#building-ebpf-programs-and-their-dependencies-for-arc","title":"Building eBPF Programs and Their Dependencies for ARC","text":"<p>Suppose that the root directory of the toolchain for ARC HS 4x is <code>/tools/arc-linux-gnu</code>. <code>/tools/arc-linux-gnu/bin</code> must be in <code>PATH</code> variable. <code>bpftool</code> must be available too.</p> <p>Create a directory for ARC's libraries and includes:</p> <pre><code>mkdir /tools/sysroot\n</code></pre> <p>Export common variables:</p> <pre><code>export CFLAGS=\"-Og -g3 -fPIC\"\nexport CXXFLAGS=\"-Og -g3 -fPIC\"\nexport CPPFLAGS=\"-I/tools/sysroot/include\"\nexport LDFLAGS=\"-L/tools/sysroot/lib\"\n</code></pre> <p>We are going to use the latest releases of libraries at the moment of writing of this manual instead of development branches.</p>"},{"location":"linux/ebpf/cross/#building-zlib","title":"Building zlib","text":"<pre><code>git clone -b v1.2.13 https://github.com/madler/zlib\ncd zlib\n./configure CHOST=\"arc-linux-gnu\" --static --prefix=\"/tools/sysroot\"\nmake install\n</code></pre>"},{"location":"linux/ebpf/cross/#building-libelf","title":"Building libelf","text":"<pre><code>git clone -b elfutils-0.189 https://sourceware.org/git/elfutils.git\ncd elfutils\nautoreconf -i -f\n\n./configure --host=arc-linux-gnu          \\\n--target=arc-linux-gnu        \\\n--disable-dependency-tracking \\\n--disable-nls                 \\\n--program-prefix=\"eu-\"        \\\n--disable-libdebuginfod       \\\n--disable-debuginfod          \\\n--without-bzlib               \\\n--without-lzma                \\\n--without-zstd                \\\n--prefix=\"/tools/sysroot\"     \\\n--enable-maintainer-mode\n\nmake -C libelf install-includeHEADERS install-libLIBRARIES\n</code></pre>"},{"location":"linux/ebpf/cross/#building-libbpf","title":"Building libbpf","text":"<pre><code>git clone -b v1.1.0 https://github.com/libbpf/libbpf\ncd libbpf/src\n\nmake BUILD_STATIC_ONLY=\"y\"          \\\nPREFIX=\"/\"                     \\\nDESTDIR=\"/tools/sysroot\"       \\\nCROSS_COMPILE=\"arc-linux-gnu-\" \\\ninstall install_uapi_headers\n</code></pre>"},{"location":"linux/ebpf/cross/#generating-vmlinuxh-from-your-vmlinux-image","title":"Generating <code>vmlinux.h</code> from your <code>vmlinux</code> image","text":"<p>Make sure that you have a recent version of bpftool (\u22657).</p> <pre><code>bpftool --debug btf dump file path/to/your/vmlinux format c &gt; /tools/sysroot/include/vmlinux.h\n</code></pre>"},{"location":"linux/ebpf/cross/#overview-of-toolssysroot","title":"Overview of <code>/tools/sysroot</code>","text":"<p>After building and installing all libraries <code>/tools/sysroot</code> should look like this:</p> <pre><code>$ tree -L 3 /tools/sysroot\n/tools/sysroot\n|-- include\n|   |-- bpf\n|   |   |-- bpf_core_read.h\n|   |   |-- bpf_endian.h\n|   |   |-- bpf.h\n|   |   |-- bpf_helper_defs.h\n|   |   |-- bpf_helpers.h\n|   |   |-- bpf_tracing.h\n|   |   |-- btf.h\n|   |   |-- libbpf_common.h\n|   |   |-- libbpf.h\n|   |   |-- libbpf_legacy.h\n|   |   |-- libbpf_version.h\n|   |   |-- skel_internal.h\n|   |   `-- usdt.bpf.h\n|   |-- gelf.h\n|   |-- libelf.h\n|   |-- linux\n|   |   |-- bpf.h\n|   |   |-- bpf_common.h\n|   |   `-- btf.h\n|   |-- nlist.h\n|   |-- zconf.h\n|   `-- zlib.h\n|-- lib\n|   |-- libbpf.a\n|   |-- libelf.a\n|   |-- libz.a\n|   `-- pkgconfig\n|       |-- libbpf.pc\n|       `-- zlib.pc\n`-- share\n    `-- man\n        `-- man3\n\n9 directories, 26 files\n</code></pre>"},{"location":"linux/ebpf/cross/#building-ebpf-program","title":"Building eBPF Program","text":"<pre><code># The paths where the native ARC tools and the cross ARC toolchain are installed\nreadonly NATIVE_SYSROOT=/tools/sysroot\nreadonly TOOLCHAIN_SYSROOT=/tools/arc-linux-gnu/sysroot\n\n# Clang uses host's Linux headers if we don't pass toolchain's includes.\n# Also, the -XClang arguments below are optional.\nclang -g                                 \\\n-O2                                \\\n-Wall                              \\\n-target bpf                        \\\n-D__TARGET_ARCH_arc                \\\n-I${NATIVE_SYSROOT}/usr/include    \\\n-I${TOOLCHAIN_SYSROOT}/usr/include \\\n-Xclang -target-feature            \\\n-Xclang +alu32                     \\\n-c minimal.bpf.c                   \\\n-o minimal.bpf.o\n\n# bpftool must be a recent version (\u22657)\nbpftool gen skeleton minimal.bpf.o &gt; minimal.skel.h\n\n# shared library build (-latomic is listed for future reference)\narc-linux-gcc minimal.c                       \\\n-I${NATIVE_SYSROOT}/usr/include \\\n-L${NATIVE_SYSROOT}/usr/lib     \\\n-lbpf                           \\\n-lelf                           \\\n-lz                             \\\n-latomic                        \\\n-o minimal\n\n# static build (-latomic is listed for future reference)\narc-linux-gcc minimal.c                          \\\n-I${SYSROOT}/usr/include           \\\n${NATIVE_SYSROOT}/usr/lib/libbpf.a \\\n${NATIVE_SYSROOT}/usr/lib/libelf.a \\\n${NATIVE_SYSROOT}/usr/lib/libz.a   \\\n-latomic                           \\\n-o minimal\n</code></pre>"},{"location":"linux/hsdk/build/","title":"Building and Running ARC Linux for HS Development Kit","text":""},{"location":"linux/hsdk/build/#preparing-the-board","title":"Preparing the Board","text":"<p>The ARC HSDK development system is based on a custom designed Synopsys ARC SoC containing the ARC HS38x4 (quad core) processor. Please refer to board's documentation for detailed information about how to setup the board for initial operation:</p> <ul> <li>ARC HS Development Kit</li> <li>ARC HS4x/HS4xD Development Kit</li> </ul> <p>In short, preparation of HSDK board consists of following steps:</p> <ol> <li>Insert a prepared micro-SD card in the micro-SD card slot of the HSDK board (read further about how to prepare a micro-SD card).</li> <li>DIP-switch <code>BIM</code> should be in <code>1:off</code>, <code>2:on</code> state while both <code>BMC</code> and <code>BCS</code> should be in <code>1:on</code>, <code>2:on</code> state.</li> <li>Connect HSDK board to host PC using micro-USB &lt;-&gt; USB cable and insert a power adapter.</li> </ol> <p>The image below shows a correct board setup:</p> <p></p>"},{"location":"linux/hsdk/build/#connecting-to-a-serial-port-terminal","title":"Connecting to a Serial Port Terminal","text":"<p>Follow Connecting Using UART guide to connect to HS Development Kit board.</p>"},{"location":"linux/hsdk/build/#preparing-buildroot-for-building-images","title":"Preparing Buildroot for Building Images","text":"<p>Clone Buildroot from the upstream repository:</p> <pre><code>git clone https://git.busybox.net/buildroot\ncd buildroot\ngit checkout 2023.05.1\n</code></pre>"},{"location":"linux/hsdk/build/#building-the-linux-kernel-and-booting-using-u-boot","title":"Building the Linux Kernel and Booting Using U-Boot","text":"<p>Configure Buildroot to use a default configuration for ARC HSDK and start building:</p> <pre><code>make snps_archs38_hsdk_defconfig\nmake -j 1\n</code></pre> <p>A multithreaded building is turned on by default and it may lead to U-Boot building fail. That is why <code>-j 1</code> option is used - it forces <code>make</code> to build everything in a single thread.</p> <p>Building takes some time but usually less than an hour on modern machines. Note that build will produce following files in <code>output/images</code> folder:</p> <ul> <li><code>sdcard.img</code> - binary image to be deployed on a micro-SD card, containing everything required to boot into user shell</li> <li><code>rootfs.cpio</code>, rootfs.tar - these 2 files contain minimalistic rootfs, for example \"rootfs.cpio\" could be re-used when manually building Linux kernel for ARC boards.</li> <li><code>u-boot.bin</code> - this is a binary image of U-Boot bootloader, it is meant to be programmed in the ARC HSDK SPI flash and then autostart on power-on.</li> <li><code>uImage</code> - this is Linux kernel prepared for loading by U-Boot bootloader. When <code>u-boot.bin</code> is programmed in HSDK' SPI flash and autostarts on power-on it will attempt to find uImage on the first partition of the SD-card.</li> </ul> <p>Then you can write <code>sdcard.img</code> to micro-SD card:</p> <ul> <li>On Linux hosts, use <code>dd</code> command as follows: <code>sudo dd if=sdcard.img of=/dev/mmcblk0 bs=1M</code>. Ensure that the SD card is not mounted,   otherwise the result is undefined.</li> <li>On Windows hosts, use Win32 Disk Imager utility.</li> </ul>"},{"location":"linux/hsdk/build/#building-the-linux-kernel-and-booting-using-a-debugger","title":"Building the Linux Kernel and Booting Using a Debugger","text":""},{"location":"linux/hsdk/build/#building-the-kernel","title":"Building the Kernel","text":"<p>If you want to use a debugger for loading and running your Linux kernel then you need to modify the default configuration first. Configure Buildroot to use a default configuration for ARC HSDK and go to the configuration menu:</p> <pre><code>make snps_archs38_hsdk_defconfig\nmake menuconfig\n</code></pre> <p>Choose this option (corresponds to <code>BR2_LINUX_KERNEL_UIMAGE=n</code> and <code>BR2_LINUX_KERNEL_VMLINUX=y</code>):</p> <pre><code>Kernel -&gt; Kernel binary format -&gt; vmlinux\n</code></pre> <p>Completely delete content for this option (<code>BR2_ROOTFS_POST_IMAGE_SCRIPT=\"\"</code>):</p> <pre><code>System configuration -&gt; Custom scripts to run after creating filesystem images\n</code></pre> <p>Then build the Linux kernel:</p> <pre><code>make\n</code></pre>"},{"location":"linux/hsdk/build/#loading-using-mdb-and-ashling-opella-xd-jtag-probe","title":"Loading Using MDB and Ashling Opella-XD JTAG probe","text":"<p>Make sure that JTAG-probe is attached to the board. Then use these commands for MetaWare Debugger:</p> <pre><code>mdb -pset=1 -psetname=core0 -DLL=opxdarc.so -prop=jtag_frequency=12MHz -prop=jtag_optimise=1 -memxfersize=0x8000 output/images/vmlinux\nmdb -pset=2 -psetname=core1 -DLL=opxdarc.so -prop=jtag_frequency=12MHz -prop=jtag_optimise=1 -prop=download=2 output/images/vmlinux\nmdb -multifiles=core0,core1 -run -cl\n</code></pre>"},{"location":"linux/hsdk/build/#loading-using-mdb-and-digilent-hs1hs2-probe","title":"Loading Using MDB and Digilent HS1/HS2 probe","text":"<p>Make sure that USB cable is attached to the board and Digilent Adept runtime and utilitied are installed. Then use these commands for MetaWare Debugger:</p> <pre><code>mdb -pset=1 -psetname=core0 -digilent output/images/vmlinux\nmdb -pset=2 -psetname=core1 -digilent -prop=download=2 output/images/vmlinux\nmdb -pset=3 -psetname=core2 -digilent -prop=download=2 output/images/vmlinux\nmdb -pset=4 -psetname=core3 -digilent -prop=download=2 output/images/vmlinux\nmdb -multifiles=core0,core1,core2,core3 -OK\n</code></pre>"},{"location":"linux/hsdk/build/#loading-using-openocd-and-digilent-hs1hs2-probe","title":"Loading Using OpenOCD and Digilent HS1/HS2 probe","text":"<p>It's possible to use OpenOCD and Digilent HS1/HS2 probe for loading and debugging the Linux kernel on HSDK. You can find detailed instructions in Using OpenOCD guide. You need to start OpenOCD with <code>snps_hsdk.cfg</code> (for HSDK) of <code>snps_hsdk_4xd.cfg</code> (for HSDK 4xD) configuration file.</p> <p>Then GDB servers for all 4 cores are started: 3333 \u2014 for the 4th core, 3336 \u2014 for the 1st core. You can debug Linux in a single core mode by connecting to the 1st core (which is on 3336 port):</p> <pre><code>$ arc-elf32-gdb output/images/vmlinux\n(gdb) target remote :3336\nRemote debugging using :3336\n0xbff8a400 in ?? ()\n(gdb) load\nLoading section .vector, size 0x2000 lma 0x90000000\nLoading section .init.ramfs, size 0x370d7c lma 0x90002000\nLoading section .init.data, size 0x59c4 lma 0x90372d80\n...\nStart address 0x9037e000, load size 12871904\nTransfer rate: 354 KB/sec, 15019 bytes/write.\n(gdb) c\n</code></pre> <p>To debug all cores it is necessary to run GDB for each core separately (cores 2-4 must be initialized first):</p> <pre><code># Load and run core #2\narc-elf32-gdb -ex \"target remote :3335\" -ex \"load\" -ex \"c\" output/images/vmlinux\n\n# Load and run core #3\narc-elf32-gdb -ex \"target remote :3334\" -ex \"load\" -ex \"c\" output/images/vmlinux\n\n# Load and run core #4\narc-elf32-gdb -ex \"target remote :3333\" -ex \"load\" -ex \"c\" output/images/vmlinux\n\n# Load and run core #1 (main one)\narc-elf32-gdb -ex \"target remote :3336\" -ex \"load\" -ex \"c\" output/images/vmlinux\n</code></pre>"},{"location":"linux/hsdk/build/#working-with-linux-after-loading-the-kernel","title":"Working with Linux After Loading the Kernel","text":"<p>Enter <code>root</code> as login and proceed with an empty password.</p> <p>Note if you see following while booting:</p> <pre><code>udhcpc (v1.23.2) started\nSending discover...\nSending discover...\nSending discover...\nNo lease, failing\n\n...\n\nstmmaceth e0018000.ethernet eth0: Link is Up - 100Mbps/Full - flow control rx/tx\n</code></pre> <p>That means Ethernet PHY became alive a bit too late. And that means that it's required to execute DHCP discovery once again from console:</p> <pre><code>udhcpc\n</code></pre>"},{"location":"linux/hsdk/uboot-build/","title":"Building U-Boot for HS Development Kit","text":"<p>Warning</p> <p>This article is under construction!</p> <p>Info</p> <ul> <li>Follow How to Get The Toolchain   guide to get the latest ARC GNU toolchain. Linux toolchain for ARC HS3x/4x (with uClibc or glibc)   is required.</li> <li>Refer to the original U-Boot README for HSDK   for details.</li> </ul>"},{"location":"linux/hsdk/uboot-build/#prerequisites","title":"Prerequisites","text":"<p>First of all U-Boot sources are fetch using next commands:</p> <pre><code>wget https://ftp.denx.de/pub/u-boot/u-boot-2023.07.tar.bz2\ntar -xf u-boot-2023.07.tar.bz2\ncd u-boot-2023.07\n</code></pre>"},{"location":"linux/hsdk/uboot-build/#building-and-writing-u-boot-to-spi-flash","title":"Building and Writing U-Boot to SPI FLash","text":"<p>Build the U-Boot image for HS Development Kit:</p> <pre><code>export CROSS_COMPILE=arc-linux-\n\n# Configure for HS Development Kit\nmake hsdk_defconfig\n\n# Configure for HS Development Kit 4xD\nmake hsdk_4xd_defconfig\n\nmake bsp-generate\n</code></pre> <p>Run the U-Boot image on the board using <code>mdb</code>:</p> <pre><code>mdb -digilent -prop=dig_speed=10000000 -cl -run u-boot\n</code></pre> <p>Once U-Boot boots into command prompt just issue the following command:</p> <pre><code>run upgrade\n</code></pre>"},{"location":"linux/hsdk/uboot-build/#building-and-loading-u-boot-using-jtag","title":"Building and Loading U-Boot using JTAG","text":"<p>Build the U-Boot image:</p> <pre><code>export CROSS_COMPILE=arc-linux-\nmake hsdk_defconfig\nmake mdbtrick\n</code></pre> <p>Ashling Opella-XD</p> <pre><code>mdb -DLL=opxdarc.so -prop=jtag_frequency=12MHz -prop=jtag_optimise=1 -nooptions -OK -memxfersize=0x8000 u-boot\n</code></pre> <p>Digilent</p> <pre><code>mdb -digilent -prop=dig_speed=10000000 u-boot\n</code></pre>"},{"location":"linux/hsdk/uboot-build/#preparing-u-boot-for-automatic-load-of-linux-kernel","title":"Preparing U-Boot for automatic load of Linux kernel","text":"<p>Once U-Boot is loaded on the HSDK board it could be used for loading Linux kernel image from different media manually and automatically.</p> <p>On execution of U-Boot you'll see this in serial console:</p> <pre><code>U-Boot 2019.4 (May 5 2019 - 18:43:19 +0300)\n\nCPU:   ARC HS38 v2.1c\nModel: snps,hsdk\nDRAM:  1 GiB\nRelocation Offset is: 3ef7f000\nMMC:   Synopsys Mobile storage: 0\nLoading Environment from FAT... OK\nIn:    serial0@f0005000\nOut:   serial0@f0005000\nErr:   serial0@f0005000\nClock values are saved to environment\nNet:   \nWarning: ethernet@f0008000 (eth0) using random MAC address - 96:f3:fa:6c:19:d9\neth0: ethernet@f0008000\nHit any key to stop autoboot:  0 \nhsdk#\n</code></pre> <p>Press any key to stop count-down and make sure U-Boot doesn't go to execute automatic boot sequence.</p> <p>U-Boot is controlled with its specific set of commands. List of available commands could be obtained with <code>?</code> or <code>help</code> command like that:</p> <pre><code>hsdk# ?\n?       - alias for 'help'\nbase    - print or set address offset\nbdinfo  - print Board Info structure\nboot    - boot default, i.e., run 'bootcmd'\nbootd   - boot default, i.e., run 'bootcmd'\nbootelf - Boot from an ELF image in memory\nbootm   - boot application image from memory\nbootp   - boot image via network using BOOTP/TFTP protocol\nbootvx  - Boot vxWorks from an ELF image\ncmp     - memory compare\nconinfo - print console devices and information\ncp      - memory copy\ncrc32   - checksum calculation\ndhcp    - boot image via network using DHCP/TFTP protocol\ndm      - Driver model low level access\necho    - echo args to console\neditenv - edit environment variable\neeprom  - EEPROM sub-system\nenv     - environment handling commands\nfatinfo - print information about filesystem\nfatload - load binary file from a dos filesystem\nfatls   - list files in a directory (default /)\nfatsize - determine a file's size\nfdt     - flattened device tree utility commands\ngo      - start application at address 'addr'\nhelp    - print command description/usage\niminfo  - print header information for application image\nimxtract- extract a part of a multi-image\nitest   - return true/false on integer compare\nloadb   - load binary file over serial line (kermit mode)\nloads   - load S-Record file over serial line\nloadx   - load binary file over serial line (xmodem mode)\nloady   - load binary file over serial line (ymodem mode)\nloop    - infinite loop on address range\nmd      - memory display\nmm      - memory modify (auto-incrementing address)\nmmc     - MMC sub system\nmmcinfo - display MMC info\nmw      - memory write (fill)\nnand    - NAND sub-system\nnboot   - boot from NAND device\nnfs     - boot image via network using NFS protocol\nnm      - memory modify (constant address)\nping    - send ICMP ECHO_REQUEST to network host\nprintenv- print environment variables\nreset   - Perform RESET of the CPU\nrun     - run commands in an environment variable\nsaveenv - save environment variables to persistent storage\nsetenv  - set environment variables\nsleep   - delay execution for some time\nsource  - run script from memory\ntftpboot- boot image via network using TFTP protocol\nusb     - USB sub-system\nusbboot - boot from USB device\nversion - print monitor, compiler and linker version\n</code></pre> <p>It's also possible to create scripts - sequences of commands to be executed one by one. And a script with special name <code>bootcmd</code> is automatically executed after boot delay gets expired.</p> <p>And so we may tune that script for our purposes.</p> <ul> <li>To load Linux image from SD-card: <code>setenv bootcmd fatload mmc 0\\; bootm</code></li> <li>To load Linux image from TFTP server: <code>setenv bootcmd dhcp\\; bootm</code></li> </ul> <p>When all preparations are done it's good to save modifications of U-Boot environment with <code>saveenv</code> command.</p> <p>And with <code>boot</code> command or with restart of U-Boot (whether with reset button if U-Boot is pre-programmed in SPI flash or with reload of U-Boot elf with MDB) you'll be able to load and start Linux kernel.</p>"},{"location":"linux/hsdk/uboot-commands/","title":"U-Boot Command Reference for HSDK","text":"<p>Warning</p> <p>This page is under construction!</p>"},{"location":"linux/simulators/metaware/","title":"Running Linux on nSIM Using MetaWare Debugger","text":""},{"location":"linux/simulators/metaware/#preface","title":"Preface","text":"<p>It's possible to run a Linux kernel on nSIM simulator using MetaWare debugger. It's just another way of running the kernel using nSIM. However, it allows to run not only UP configuration, but SMP configurations too.</p>"},{"location":"linux/simulators/metaware/#running-single-core-arc-hs38-linux-kernel","title":"Running Single-Core ARC HS38 Linux Kernel","text":"<p>Info</p> <p>The kernel must be built with <code>haps_hs_defconfig</code> Linux configuration.</p> <p>Passing all configurations manually:</p> <pre><code>mdb -nsim -av2hs -prop=cpunum=0 -mmuv4 -Xrtc -Xatomic -Xtimer0 -Xtimer1 -Xmpyd -Xqmpyh -Xdiv_rem \\\n    -toggle=deadbeef=1 -prop=nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop=mmu_pagesize=8192 \\\n    -prop=mmu_super_pagesize=2097152 -prop=mmu_stlb_entries=16 -prop=mmu_ntlb_ways=4 -prop=mmu_ntlb_sets=128 \\\n    -icache=16384,64,2,o -dcache=16384,64,4,o -prop=nsim_isa_aps_feature=1 -prop=nsim_isa_num_actionpoints=4 \\\n    -prop=nsim_isa_ll64_option=1 -prop=nsim_isa_rtc_option=1 -prop=nsim_isa_core=3 -noprofile -run -cl vmlinux\n</code></pre> <p>Using a predefined TCF template:</p> <pre><code>mdb -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf \\\n    -prop=nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 \\\n    -prop=nsim_isa_rtc_option=1 -nsim -noprofile -run -cl vmlinux\n</code></pre>"},{"location":"linux/simulators/metaware/#running-multi-core-arc-hs38-linux-kernel","title":"Running Multi-Core ARC HS38 Linux Kernel","text":"<p>Info</p> <p>The kernel must be built with <code>haps_hs_smp_defconfig</code> Linux configuration.</p> <p>Warning</p> <p><code>nsim_connect_*</code> properties are not supported in older nSIM (prior K-2015.06). Please check the nSIM documentation to replace them with deprecated <code>nsim_mcip_*</code> properties.</p> <p>Running 2 cores using a predefined TCF template:</p> <pre><code>export NSIM_MULTICORE=1\nmdb -pset=1 -psetname=core0 -prop=ident=0x00000050 -cmpd=soc \\\n    -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf \\\n    -prop=nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=0,use_connect=1 \\\n    -prop=nsim_connect=2 -prop=nsim_connect_idu=1 -prop=nsim_connect_gfrc=1 \\\n    -prop=nsim_connect_ici=1 -prop=isa_counters=1 -prop=nsim_isa_pct_counters=8 \\\n    -prop=nsim_isa_pct_interrupt=1 -prop=nsim_isa_pct_interrupt=1 \\\n    -noprofile vmlinux\nmdb -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf \\\n    -pset=2 -psetname=core1 -prop=ident=0x00000150 -cmpd=soc \\\n    -prop=nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=0,use_connect=1 \\\n    -prop=nsim_connect=2 -prop=nsim_connect_idu=1 -prop=nsim_connect_gfrc=1 \\\n    -prop=nsim_connect_ici=1 -prop=isa_counters=1 -prop=nsim_isa_pct_counters=8 \\\n    -prop=nsim_isa_pct_interrupt=1 -prop=nsim_isa_pct_interrupt=1 \\\n    -noprofile vmlinux\nmdb -multifiles=core0,core1 -cmpd=soc -run -cl\n</code></pre> <p>Running 4 cores using a predefined TCF template:</p> <pre><code>export NSIM_MULTICORE=1\nVMLINUX=\"vmlinux\"\nCOMMON=\"-tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -prop=nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=0,use_connect=1 -prop=nsim_connect=2 -prop=nsim_connect_idu=1 -prop=nsim_connect_gfrc=1 -prop=nsim_connect_ici=1 -prop=isa_counters=1 -prop=nsim_isa_pct_counters=8 -prop=nsim_isa_pct_interrupt=1 -prop=nsim_isa_pct_interrupt=1 -noprofile\"\nmdb -pset=1 -psetname=core0 -prop=ident=0x00000050 -cmpd=soc $COMMON $VMLINUX\nmdb -pset=2 -psetname=core1 -prop=ident=0x00000150 -cmpd=soc $COMMON $VMLINUX\nmdb -pset=3 -psetname=core2 -prop=ident=0x00000250 -cmpd=soc $COMMON $VMLINUX\nmdb -pset=4 -psetname=core3 -prop=ident=0x00000350 -cmpd=soc $COMMON $VMLINUX\nmdb -multifiles=core0,core1,core2,core3 -cmpd=soc -run -cl\n</code></pre>"},{"location":"linux/simulators/metaware/#running-arc770-linux-kernel","title":"Running ARC770 Linux Kernel","text":"<p>Passing all configurations manually:</p> <pre><code>mdb -a7 -nsim -Xlib -prop=nsim_mmu=3 -Xtimer0 -Xtimer1 -icache=16384,64,2,o -dcache=32768,64,4,o \\\n    -prop=cpunum=0 -prop=nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop=nsim_sc_mem_range_end=0xc0fbffff \\\n    -prop=nsim_isa_atomic_option=1 -prop=nsim_isa_num_actionpoints=8 -prop=nsim_isa_aps_feature=1 -noprofile -OK -run -cl vmlinux\n</code></pre>"},{"location":"linux/simulators/nsim/","title":"Building Linux for a Simulation and Running on nSIM","text":"<p>UART Settings for Older Linux Kernels (v5.4 and Prior)</p> <p>nSIM 2019.06 onwards supports DW UART (in addition to the legacy ARC UART). This paved the way to running Linux image built for HAPS FPGA on nSIM. So starting with kernel version v5.5-rc1, <code>nsim_hs_smp_defconfig</code> and <code>nsim_hs_defconfig</code> defconfigs were merged with corresponding haps defconfigs and everything was switched to DW UART.</p> <p>For kernels v5.4 and prior (with ARC UART based configurations and DT) and/or older nSIM, the legacy ARC UART needs to be instantiated instead of <code>-prop=nsim_mem-dev=&lt;...&gt;</code> property presented in the guides:</p> <ul> <li>For ARC770 use <code>-prop=nsim_mem-dev=uart0,base=0xc0fc1000,irq=5</code></li> <li>For ARC HS38 single-core use <code>-prop=nsim_mem-dev=uart0,base=0xc0fc1000,irq=24</code></li> <li>For ARC HS38 multi-core configuration with IDU, use <code>-prop=nsim_mem-dev=uart0,base=0xc0fc1000,irq=0,use_connect=1</code></li> </ul>"},{"location":"linux/simulators/nsim/#prerequisites","title":"Prerequisites","text":"<p>Clone a repository and create a build directory:</p> <pre><code># Clone the latest Buildroot\ngit clone https://git.busybox.net/buildroot\n\n# ... or use a custom repository for support of ARCv3 targets\nhttps://github.com/foss-for-synopsys-dwc-arc-processors/buildroot\n\n# Create a build directory\nmkdir buildroot/build\ncd buildroot/build\n</code></pre> <p>In this guide we suppose that a toolchain is preinstalled in <code>/tools/toolchains</code> (2023.03 release). Also, only a limited set of all available toolchains is considered. All releases may be downloaded from the official releases page. Here is a table of toolchains, which are used in this guide:</p> ARC processors family Standard library Toolchain's installation path Version ARC HS 6x glibc <code>/tools/toolchains/arc64-linux-gnu</code> 2023.03 ARC HS 5x uClibc-ng <code>/tools/toolchains/arc32-linux-uclibc</code> 2023.03 ARC HS 3x/4x glibc <code>/tools/toolchains/arc-linux-gnu</code> 2023.03 ARC HS 3x/4x uClibc-ng <code>/tools/toolchains/arc-linux-uclibc</code> 2023.03 ARC 700 uClibc-ng <code>/tools/toolchains/arc700-linux-uclibc</code> 2023.03"},{"location":"linux/simulators/nsim/#arc-hs-3x4x-with-glibc","title":"ARC HS 3x/4x with glibc","text":"<p>We a going to use the latest Synopsys' development branch of the Linux kernel. Also, we use <code>hasp_hs</code> configuration file for the Linux kernel - it corresponds to a single core (UP) configuration. Save a custom configuration file in <code>build/defconfig</code>:</p> <pre><code>BR2_arcle=y\nBR2_archs38=y\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_PATH=\"/tools/toolchains/arc-linux-gnu\"\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_5_16=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM_GLIBC=y\n# BR2_TOOLCHAIN_EXTERNAL_INET_RPC is not set\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_TOOLCHAIN_EXTERNAL_FORTRAN=y\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_GIT=y\nBR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"https://github.com/foss-for-synopsys-dwc-arc-processors/linux\"\nBR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"arc64\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"haps_hs\"\nBR2_LINUX_KERNEL_VMLINUX=y\nBR2_TARGET_ROOTFS_INITRAMFS=y\n</code></pre> <p>Build a Linux image:</p> <pre><code>make -C .. O=$(pwd) defconfig DEFCONFIG=build/defconfig\nmake\n</code></pre> <p>Before running the image using nSIM create a corresponding configuration file <code>hs4x.props</code> (use <code>nsim_fast=1</code> option if you have nSIM Pro license):</p> <pre><code>nsim_fast=0\nnsim_isa_family=av2hs\nnsim_isa_core=3\nchipid=0xffff\nnsim_isa_atomic_option=1\nnsim_isa_ll64_option=1\nnsim_mmu=4\nmmu_pagesize=8192\nmmu_super_pagesize=2097152\nmmu_stlb_entries=16\nmmu_ntlb_ways=4\nmmu_ntlb_sets=128\nicache=32768,64,4,0\ndcache=16384,64,2,0\nnsim_isa_shift_option=2\nnsim_isa_swap_option=1\nnsim_isa_bitscan_option=1\nnsim_isa_sat=1\nnsim_isa_div_rem_option=1\nnsim_isa_mpy_option=9\nnsim_isa_enable_timer_0=1\nnsim_isa_enable_timer_1=1\nnsim_isa_number_of_interrupts=32\nnsim_isa_number_of_external_interrupts=32\nisa_counters=1\nnsim_isa_pct_counters=8\nnsim_isa_pct_size=48\nnsim_isa_pct_interrupt=1\nnsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24\nnsim_isa_aps_feature=1\nnsim_isa_num_actionpoints=4\nnsim_isa_rtc_option=1\nnsim_isa_fpud_option=1\n</code></pre> <p>Then run the image using nSIM:</p> <pre><code>nsimdrv -propsfile hs4x.props images/vmlinux\n</code></pre> <p>Run the images without using a property file:</p> <pre><code>nsimdrv -prop nsim_isa_family=av2hs -prop nsim_isa_core=3 -prop chipid=0xffff -prop nsim_isa_atomic_option=1 \\\n        -prop nsim_isa_ll64_option=1 -prop nsim_mmu=4 -prop mmu_pagesize=8192 -prop mmu_super_pagesize=2097152 \\\n        -prop mmu_stlb_entries=16 -prop mmu_ntlb_ways=4 -prop mmu_ntlb_sets=128 -prop icache=32768,64,4,0 \\\n        -prop dcache=16384,64,2,0 -prop nsim_isa_shift_option=2 -prop nsim_isa_swap_option=1 -prop nsim_isa_bitscan_option=1 \\\n        -prop nsim_isa_sat=1 -prop nsim_isa_div_rem_option=1 -prop nsim_isa_mpy_option=9 -prop nsim_isa_enable_timer_0=1 \\\n        -prop nsim_isa_enable_timer_1=1 -prop nsim_isa_number_of_interrupts=32 -prop nsim_isa_number_of_external_interrupts=32 \\\n        -prop isa_counters=1 -prop nsim_isa_pct_counters=8 -prop nsim_isa_pct_size=48 -prop nsim_isa_pct_interrupt=1 \\\n        -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop nsim_isa_aps_feature=1 \\\n        -prop nsim_isa_num_actionpoints=4 -prop nsim_isa_rtc_option=1 -prop nsim_isa_fpud_option=1 \\\n        images/vmlinux\n</code></pre> <p>Run the image using a predefined TCF file:</p> <pre><code>nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf \\\n        -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 \\\n        images/vmlinux\n</code></pre> <p>You will see an kernel's initialization output:</p> <pre><code>Console now belongs to UART, hit CRTL-] to return to simulator.\nLinux version 5.16.0 (ykolerov@SNPS-HRlPxd6IgG) (arc-linux-gcc (ARC HS GNU/Linux glibc toolchain - build 1360) 12.2.1 20230306, GNU ld (ARC HS GNU/Linux glibc toolchain - build 1360) 2.40.50.20230314) #2 PREEMPT Tue Jul 25 18:27:27 +04 2023\nMemory @ 80000000 [1024M]\nMemory @ 100000000 [1024M] Not used\nOF: fdt: Machine model: snps,zebu_hs\nearlycon: uart8250 at MMIO32 0xf0000000 (options '115200n8')\nprintk: bootconsole [uart8250] enabled\n\nIDENTITY        : ARCVER [0x53] ARCNUM [0x0] CHIPID [0xffff]\nprocessor [0]   : HS38 R3.0 (ARCv2 ISA)\nISA Extn        : atomic ll64 unalign mpy[opt 9] div_rem   FPU: sp dp\nBPU             : partial match, cache:2048, Predict Table:16384 Return stk: 8\nMMU [v4]        : 8k/2M, swalk 2 lvl, JTLB 128x4, uDTLB 8, uITLB 4\nI-Cache         : 32K, 4way/set, 64B Line, VIPT\nD-Cache         : 16K, 2way/set, 64B Line, PIPT\nPeripherals     : 0xc0000000\nTimers          : Timer0 Timer1 RTC [UP 64-bit]\nVector Table    : 0x80000000 [64-bit]\nDEBUG           : ActionPoint 4/full\n\n...\n\nWelcome to the HAPS Development Platform\nzebu_hs login:\n</code></pre> <p>Username is <code>root</code> without a password. To halt target system issue <code>halt</code> command.</p>"},{"location":"linux/simulators/nsim/#arc-hs-3x4x-with-uclibc-ng","title":"ARC HS 3x/4x with uClibc-ng","text":"<p>We use <code>haps_hs</code> configuration file for the Linux kernel - it corresponds to a single core (UP) configuration. Here is a corresponding configuration file for Buildroot:</p> <pre><code>BR2_arcle=y\nBR2_archs38=y\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_PATH=\"/tools/toolchains/arc-linux-uclibc\"\nBR2_TOOLCHAIN_EXTERNAL_LOCALE=y\nBR2_TOOLCHAIN_EXTERNAL_HAS_SSP=y\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_5_16=y\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_GIT=y\nBR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"https://github.com/foss-for-synopsys-dwc-arc-processors/linux\"\nBR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"arc64\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"haps_hs\"\nBR2_LINUX_KERNEL_VMLINUX=y\nBR2_TARGET_ROOTFS_INITRAMFS=y\n</code></pre> <p>A process of building and running of the Linux kernel for ARC HS38 based on uClibc-ng is the same as for glibc version.</p>"},{"location":"linux/simulators/nsim/#arc-770-with-uclibc-ng","title":"ARC 770 with uClibc-ng","text":"<p>We use <code>nsim_700</code> configuration file for the Linux kernel - it corresponds to a single core (UP) configuration. Here is a corresponding configuration file for Buildroot:</p> <pre><code>BR2_arcle=y\nBR2_arc770d=y\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_PATH=\"/tools/toolchains/arc700-linux-uclibc\"\nBR2_TOOLCHAIN_EXTERNAL_LOCALE=y\nBR2_TOOLCHAIN_EXTERNAL_HAS_SSP=y\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_5_16=y\nBR2_GCC_VERSION_12_X=y\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_GIT=y\nBR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"https://github.com/foss-for-synopsys-dwc-arc-processors/linux\"\nBR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"arc64\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"nsim_700\"\nBR2_LINUX_KERNEL_VMLINUX=y\nBR2_TARGET_ROOTFS_INITRAMFS=y\n</code></pre> <p>Build a Linux image:</p> <pre><code>make -C .. O=$(pwd) defconfig DEFCONFIG=build/defconfig\nmake\n</code></pre> <p>Before running the image using nSIM create a corresponding configuration file <code>arc700.props</code> (use <code>nsim_fast=1</code> option if you have nSIM Pro license):</p> <pre><code>nsim_fast=0\nnsim_isa_family=a700\nnsim_isa_atomic_option=1\nnsim_mmu=3\nicache=32768,64,2,0\ndcache=32768,64,4,0\nnsim_isa_dpfp=none\nnsim_isa_shift_option=2\nnsim_isa_swap_option=1\nnsim_isa_bitscan_option=1\nnsim_isa_sat=1\nnsim_isa_mpy32=1\nnsim_isa_enable_timer_0=1\nnsim_isa_enable_timer_1=1\nnsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24\nisa_counters=1\nnsim_isa_pct_counters=8\nnsim_isa_pct_size=48\n</code></pre> <p>Then run the image using nSIM:</p> <pre><code>nsimdrv -propsfile arc700.props images/vmlinux\n</code></pre> <p>Run the image without a property file:</p> <pre><code>nsimdrv -prop nsim_isa_family=a700 -prop nsim_isa_atomic_option=1 -prop nsim_mmu=3 -prop icache=32768,64,2,0 \\\n        -prop dcache=32768,64,4,0 -prop nsim_isa_dpfp=none -prop nsim_isa_shift_option=2 -prop nsim_isa_swap_option=1 \\\n        -prop nsim_isa_bitscan_option=1 -prop nsim_isa_sat=1 -prop nsim_isa_mpy32=1 -prop nsim_isa_enable_timer_0=1 \\\n        -prop nsim_isa_enable_timer_1=1 -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop isa_counters=1 \\\n        -prop nsim_isa_pct_counters=8 -prop nsim_isa_pct_size=48 images/vmlinux\n</code></pre> <p>Run the image using a predefined TCF file:</p> <pre><code>nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/arc770d.tcf -prop nsim_isa_number_of_interrupts=32 \\\n        -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop nsim_isa_dpfp=none \\\n        -prop icache=32768,64,2,0 -prop dcache=32768,64,4,0 -prop nsim_isa_dpfp=none \\\n        -prop nsim_isa_swap_option=1 -prop nsim_isa_bitscan_option=1 -prop nsim_isa_sat=1 \\\n        -prop isa_counters=1 -prop nsim_isa_pct_counters=8 -prop nsim_isa_pct_size=48 \\\n        images/vmlinux\n</code></pre>"},{"location":"linux/simulators/nsim/#arc-hs5x-with-uclibc-ng","title":"ARC HS5x with uClibc-ng","text":"<p>Info</p> <p>Linux kernels for ARCv3 are loaded differently in comparison to kernels for ARCv1 and ARCv2. Kernels for ARCv3 are always loaded from a physical address <code>0x0</code> instead of <code>0x80000000</code>. A custom <code>loader</code> image is generated to distinguish it from a default <code>vmlinux</code> (<code>vmlinux</code> uses <code>0x80000000</code> as a starting address in physical and virtual spaces).</p> <p>We use <code>haps_hs5x</code> configuration file for the Linux kernel - it corresponds to a single core (UP) configuration. Here is a corresponding configuration file for Buildroot:</p> <pre><code>BR2_arcle=y\nBR2_arc32=y\n# BR2_STRIP_strip is not set\nBR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_5_16=y\nBR2_ROOTFS_POST_IMAGE_SCRIPT=\"board/synopsys/arc64/post-image.sh\"\nBR2_ROOTFS_POST_SCRIPT_ARGS=\"$(LINUX_DIR)\"\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_GIT=y\nBR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"https://github.com/foss-for-synopsys-dwc-arc-processors/linux.git\"\nBR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"arc64\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"haps_hs5x\"\nBR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y\nBR2_LINUX_KERNEL_IMAGE_TARGET_NAME=\"loader\"\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_PATH=\"/tools/toolchains/arc32-linux-uclibc\"\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_5_16=y\nBR2_TOOLCHAIN_EXTERNAL_LOCALE=y\nBR2_TOOLCHAIN_EXTERNAL_HAS_SSP=y\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_TOOLCHAIN_EXTERNAL_INET_RPC=n\nBR2_TOOLCHAIN_EXTERNAL_GCC_12=y\nBR2_TARGET_ROOTFS_INITRAMFS=y\n</code></pre> <p>Build a Linux image:</p> <pre><code>make -C .. O=$(pwd) defconfig DEFCONFIG=build/defconfig\nmake\n</code></pre> <p>Before running the image using nSIM create a corresponding configuration file <code>hs5x.props</code> (use <code>nsim_fast=1</code> option if you have nSIM Pro license):</p> <pre><code>nsim_fast=0\nnsim_isa_family=av3hs\nnsim_isa_dc_hw_prefetch=1\nnsim_isa_dual_issue_option=1\nnsim_isa_atomic_option=2\nnsim_isa_m128_option=0\nnsim_isa_ll64_option=1\nnsim_isa_mpy_option=9\nnsim_isa_div_rem_option=2\nnsim_isa_enable_timer_0=1\nnsim_isa_enable_timer_1=1\nnsim_isa_rtc_option=1\nicache=16384,64,4\ndcache=16384,64,2\nmmu_version=16\nmmu_pagesize=4096\nmmu_address_space=32\nnsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24\nnsim_isa_number_of_interrupts=32\nnsim_isa_number_of_external_interrupts=32\nnsim_isa_has_fp=1\nnsim_isa_fp_dds_option=1\nnsim_isa_fp_div_option=1\nnsim_isa_fp_dp_option=1\nnsim_isa_fp_hp_option=1\nnsim_isa_fp_vec_option=1\nnsim_isa_fp_wide_option=1\n</code></pre> <p>Then run the image using nSIM:</p> <pre><code>nsimdrv -propsfile hs5x.props images/loader\n</code></pre> <p>Run the image without a property file:</p> <pre><code>nsimdrv -prop nsim_isa_family=av3hs -prop nsim_isa_dc_hw_prefetch=1 -prop nsim_isa_dual_issue_option=1 \\\n        -prop nsim_isa_atomic_option=2 -prop nsim_isa_m128_option=0 -prop nsim_isa_ll64_option=1 -prop nsim_isa_mpy_option=9 \\\n        -prop nsim_isa_div_rem_option=2 -prop nsim_isa_enable_timer_0=1 -prop nsim_isa_enable_timer_1=1 \\\n        -prop nsim_isa_rtc_option=1 -prop icache=16384,64,4 -prop dcache=16384,64,2 -prop mmu_version=16 -prop mmu_pagesize=4096 \\\n        -prop mmu_address_space=32 -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop nsim_isa_number_of_interrupts=32 \\\n        -prop nsim_isa_number_of_external_interrupts=32 -prop nsim_isa_has_fp=1 -prop nsim_isa_fp_dds_option=1 \\\n        -prop nsim_isa_fp_div_option=1 -prop nsim_isa_fp_dp_option=1 -prop nsim_isa_fp_hp_option=1 -prop nsim_isa_fp_vec_option=1 \\\n        -prop nsim_isa_fp_wide_option=1 images/loader\n</code></pre> <p>Run the image using a predefined TCF file:</p> <pre><code>nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs58_full.tcf -prop icache=16384,64,4 -prop dcache=16384,64,2 \\\n        -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop nsim_isa_number_of_external_interrupts=32 \\\n        -prop nsim_isa_has_fp=1 -prop nsim_isa_fp_dds_option=1 -prop nsim_isa_fp_div_option=1 -prop nsim_isa_fp_dp_option=1 \\\n        -prop nsim_isa_fp_hp_option=1 -prop nsim_isa_fp_vec_option=1 -prop nsim_isa_fp_wide_option=1 \\\n        images/loader\n</code></pre>"},{"location":"linux/simulators/nsim/#arc-hs6x-with-glibc","title":"ARC HS6x with glibc","text":"<p>We use <code>haps_arc64</code> configuration file for the Linux kernel - it corresponds to a single core (UP) configuration. Here is a corresponding configuration file for Buildroot:</p> <pre><code>BR2_arcle=y\nBR2_arc64=y\n# BR2_STRIP_strip is not set\nBR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_5_16=y\nBR2_ROOTFS_POST_IMAGE_SCRIPT=\"board/synopsys/arc64/post-image.sh\"\nBR2_ROOTFS_POST_SCRIPT_ARGS=\"$(LINUX_DIR)\"\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_GIT=y\nBR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"https://github.com/foss-for-synopsys-dwc-arc-processors/linux.git\"\nBR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"arc64\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"haps_arc64\"\nBR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM=y\nBR2_LINUX_KERNEL_IMAGE_TARGET_NAME=\"loader\"\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM_GLIBC=y\nBR2_TOOLCHAIN_EXTERNAL_PATH=\"/tools/toolchains/arc64-linux-gnu\"\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_5_16=y\nBR2_TOOLCHAIN_EXTERNAL_LOCALE=y\nBR2_TOOLCHAIN_EXTERNAL_HAS_SSP=y\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_TOOLCHAIN_EXTERNAL_INET_RPC=n\nBR2_TOOLCHAIN_EXTERNAL_GCC_12=y\nBR2_TARGET_ROOTFS_INITRAMFS=y\n</code></pre> <p>Before running the image using nSIM create a corresponding configuration file <code>hs6x.props</code> (use <code>nsim_fast=1</code> option if you have nSIM Pro license):</p> <pre><code>nsim_fast=0\nnsim_isa_dual_issue_option=1\nnsim_isa_has_hw_pf=1\nnsim_isa_m128_option=1\nnsim_isa_has_hw_pf=1\nnsim_isa_vec64=1\nnsim_isa_family=arc64\nnsim_isa_enable_timer_0=1\nnsim_isa_enable_timer_1=1\nnsim_isa_rtc_option=1\nnsim_isa_addr_size=64\nnsim_isa_pc_size=64\nicache=16384,64,4,o\ndcache=16384,64,4,o\nmmu_version=16\nmmu_pagesize=4096\nmmu_address_space=48\nnsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24\nnsim_isa_mpy_option=9\nnsim_isa_mpy64=1\nnsim_isa_div64_option=1\nnsim_isa_div_rem_option=2\nnsim_isa_atomic_option=2\nnsim_isa_has_fp=1\nnsim_isa_fp_dds_option=1\nnsim_isa_fp_div_option=1\nnsim_isa_fp_dp_option=1\nnsim_isa_fp_hp_option=1\nnsim_isa_fp_vec_option=1\nnsim_isa_fp_wide_option=1\n</code></pre> <p>Then run the image using nSIM:</p> <pre><code>nsimdrv -propsfile hs6x.props images/loader\n</code></pre> <p>Also, you can run the images without a property file:</p> <pre><code>nsimdrv -prop nsim_isa_dual_issue_option=1 -prop nsim_isa_has_hw_pf=1 -prop nsim_isa_m128_option=1 \\\n        -prop nsim_isa_vec64=1 -prop nsim_isa_family=arc64 -prop nsim_isa_enable_timer_0=1 -prop nsim_isa_enable_timer_1=1 \\\n        -prop nsim_isa_rtc_option=1 -prop nsim_isa_addr_size=64 -prop nsim_isa_pc_size=64 -prop icache=16384,64,4,o \\\n        -prop dcache=16384,64,4,o -prop mmu_version=16 -prop mmu_pagesize=4096 -prop mmu_address_space=48 \\\n        -prop nsim_mem-dev=uart0,kind=dwuart,base=0xf0000000,irq=24 -prop nsim_isa_mpy_option=9 -prop nsim_isa_mpy64=1 \\\n        -prop nsim_isa_div64_option=1 -prop nsim_isa_div_rem_option=2 -prop nsim_isa_atomic_option=2 -prop nsim_isa_has_fp=1 \\\n        -prop nsim_isa_fp_dds_option=1 -prop nsim_isa_fp_div_option=1 -prop nsim_isa_fp_dp_option=1 -prop nsim_isa_fp_hp_option=1 \\\n        -prop nsim_isa_fp_vec_option=1 -prop nsim_isa_fp_wide_option=1 \\\n        images/loader\n</code></pre>"},{"location":"linux/simulators/qemu/","title":"Running Linux on QEMU","text":""},{"location":"linux/simulators/qemu/#preface","title":"Preface","text":"<p>It's possible to run on QEMU the same Linux images as for nSIM/HAPS. A process of building of Linux images is completely same.</p>"},{"location":"linux/simulators/qemu/#running-for-arc-hs-3x4x","title":"Running for ARC HS 3x/4x","text":"<pre><code>qemu-system-arc -M virt -cpu archs -display none -nographic -monitor none -m 2G -kernel vmlinux\n</code></pre>"},{"location":"linux/simulators/qemu/#running-for-arc-hs-5x","title":"Running for ARC HS 5x","text":"<p>Info</p> <p>Linux kernels for ARCv3 are loaded differently in comparison to kernels for ARCv1 and ARCv2. Kernels for ARCv3 are always loaded from a physical address <code>0x0</code> instead of <code>0x80000000</code>. A custom <code>loader</code> image is generated to distinguish it from a default <code>vmlinux</code> (<code>vmlinux</code> uses <code>0x80000000</code> as a starting address in physical and virtual spaces). Thus, it's necessary to run QEMU with <code>-M virt,ram_start=0</code> parameter.</p> <pre><code>qemu-system-arc -M virt,ram_start=0 -cpu hs5x -m 2G -display none -nographic -monitor none -kernel loader\n</code></pre>"},{"location":"linux/simulators/qemu/#running-for-arc-hs-6x","title":"Running for ARC HS 6x","text":"<pre><code>qemu-system-arc64 -M virt,ram_start=0 -cpu hs6x -m 2G -display none -nographic -monitor none -kernel loader\n</code></pre>"},{"location":"linux/simulators/qemu/#networking-in-qemu-using-a-user-level-network-interface","title":"Networking in QEMU Using a User Level Network Interface","text":""},{"location":"linux/simulators/qemu/#configuring-network","title":"Configuring Network","text":"<p>Firstly, it's necessary to enable <code>BR2_SYSTEM_DHCP</code> option in Buildroot configuration. Just use <code>BR2_SYSTEM_DHCP=eth0</code> in your configuration file or use this option in a configuration menu:</p> <pre><code>System configuration -&gt; Network interface to configure through DHCP -&gt; eth0\n</code></pre> <p>You can connect a QEMU machine to a network using a user level network interface by passing these additional options:</p> <pre><code>-netdev user,id=net0 -device virtio-net-device,netdev=net0 -device virtio-rng-pci \n</code></pre> <p>You can enable port forwarding for a set of ports. Here is an example for forwarding ports for FTP and SSH:</p> <pre><code>-netdev user,id=net0,hostfwd=tcp::2021-:21,hostfwd=tcp::2022-:22 -device virtio-net-device,netdev=net0 -device virtio-rng-pci \n</code></pre> <p>Here is a full command line for running QEMU with support of networking and forwarding of ports for FTP and SSH:</p> <pre><code>qemu-system-arc -M virt -cpu archs -m 2G -display none -nographic -monitor none -kernel vmlinux -device virtio-rng-pci \\\n                -netdev user,id=net0,hostfwd=tcp::2021-:21,hostfwd=tcp::2022-:22 -device virtio-net-device,netdev=net0\n</code></pre> <p>In boot log output you will see these lines:</p> <pre><code>Starting network: udhcpc: started, v1.35.0\nudhcpc: broadcasting discover\nudhcpc: broadcasting select for 10.0.2.15, server 10.0.2.2\nudhcpc: lease of 10.0.2.15 obtained from 10.0.2.2, lease time 86400\ndeleting routers\nadding dns 10.0.2.3\n</code></pre> <p>Use <code>ifconfig</code> or <code>ping</code> utility to ensure that an Ethernet interface is initialized successfully:</p> <pre><code># ifconfig\neth0      Link encap:Ethernet  HWaddr 52:54:00:12:34:56\n          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:2 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:2 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000\n          RX bytes:1180 (1.1 KiB)  TX bytes:689 (689.0 B)\n\nlo        Link encap:Local Loopback\n          inet addr:127.0.0.1  Mask:255.0.0.0\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000\n          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n\n# ping 8.8.8.8\nPING 8.8.8.8 (8.8.8.8): 56 data bytes\n64 bytes from 8.8.8.8: seq=0 ttl=255 time=15.418 ms\n64 bytes from 8.8.8.8: seq=1 ttl=255 time=0.701 ms\n64 bytes from 8.8.8.8: seq=2 ttl=255 time=0.558 ms\n64 bytes from 8.8.8.8: seq=3 ttl=255 time=1.122 ms\n</code></pre> <p>If you don't configure Buildroot with <code>BR2_SYSTEM_DHCP=eth0</code> option, then you will to initialize an network device manually after Linux is booted:</p> <pre><code># ifconfig eth0 up\n# udhcpc\nudhcpc: started, v1.35.0\nudhcpc: broadcasting discover\nudhcpc: broadcasting select for 10.0.2.15, server 10.0.2.2\nudhcpc: lease of 10.0.2.15 obtained from 10.0.2.2, lease time 86400\ndeleting routers\nadding dns 10.0.2.3\n</code></pre>"},{"location":"linux/simulators/qemu/#using-ssh","title":"Using SSH","text":"<p>You can connect to the Linux kernel through SSH using a custom port 2022 (it is forwarded to 22 port inside of QEMU machine). To add SSH server to the Linux image use <code>BR2_PACKAGE_OPENSSH=y</code> and <code>BR2_PACKAGE_HAVEGED=y</code> options for Buildroot:</p> <pre><code>Target packages -&gt; Networking applications -&gt; [*] openssh\n                -&gt; Miscellaneous -&gt; [*] haveged\n</code></pre> <p>Run Linux and create a user <code>user</code> and crate a home directory for the user:</p> <pre><code>adduser user\nmkdir -p /home/user\n</code></pre> <p>Here is an example for connecting to the Linux using SSH:</p> <pre><code>$ ssh -p 2022 user@127.0.0.1\nuser@127.0.0.1's password:\n$ pwd\n/home/user\n</code></pre>"},{"location":"linux/simulators/qemu/#networking-in-qemu-using-tuntap-network-interface","title":"Networking in QEMU Using TUN/TAP Network Interface","text":"<p>TUN/TAP network interface allows interacting of the target with your host in both directions. For example, you can mount host\u2019s NFS directories inside of the target.</p> <p>Configure TUN/TAP interface on host\u2019s side (choose your own IP address instead of <code>10.42.0.1</code>):</p> <pre><code>sudo ip tuntap add tap1 mode tap\nsudo ip addr add 10.42.0.1/24 dev tap1\nsudo ip link set tap1 up\n</code></pre> <p>Run QEMU</p> <pre><code>qemu-system-arc -M virt -cpu archs -m 2G -display none -nographic -monitor none -kernel vmlinux \\\n                -netdev tap,id=net0,ifname=tap1,script=no,downscript=no -device virtio-net-device,netdev=net0\n</code></pre> <p>Configure a network interface on target's side:</p> <pre><code>ifconfig eth0 10.42.0.100\n</code></pre> <p>After that you can connect to any Linux service without port forwarding. Here is an example of connecting to the Linux using SSH with TUN/TAP interface configured:</p> <pre><code>ssh user@10.42.0.100\n</code></pre>"},{"location":"linux/simulators/qemu/#mounting-an-external-filesystem-image","title":"Mounting an External Filesystem Image","text":"<p>It's possible to run Linux with an external filesystem image. Firstly, turn off linking an initial RAM filesystem into Linux kernel (<code>BR2_TARGET_ROOTFS_INITRAMFS=n</code>) and add an option for building Ext2 filesystem image (<code>BR2_TARGET_ROOTFS_EXT2=y</code>) in Buildroot:</p> <pre><code>Filesystem images -&gt; [*] ext2/3/4 root filesystem\n                  -&gt; [ ] initial RAM filesystem linked into linux kernel\n</code></pre> <p>Run the Linux kernel and initialize and external storage:</p> <pre><code>qemu-system-arc -M virt -cpu archs -m 2G -display none -nographic -monitor none -kernel vmlinux \\\n                -append \"root=/dev/vda ro\" -drive file=images/rootfs.ext2,format=raw,id=hd0 \\\n                -device virtio-blk-device,drive=hd0\n</code></pre>"},{"location":"linux/simulators/qemu/#mounting-a-shared-folder","title":"Mounting a Shared Folder","text":"<p>If you need shared folder access, add the following arguments to QEMU's command line:</p> <pre><code>-drive format=vvfat,id=hd0,file=fat:rw:/path/to/directory -device virtio-blk-device,drive=hd0\n</code></pre> <p>And the on target's side:</p> <pre><code>mount /dev/vda1\nmount /dev/vda1 /mnt\ntouch /mnt/test.txt\n</code></pre> <p>Target will see contents on your directory as if it's a FAT partition on some drive without symbolic links, special attributes, etc. Target may do changes to the contents of this folder (with read/write permissions above). Host must not do any changes to the folder while target is using this shared folder, otherwise things will go seriously wrong (QEMU creates FAT table on start and then it's target which manipulates it but not host).</p>"},{"location":"linux/simulators/vdk/","title":"Running Linux on VDK","text":"<p>Warning</p> <p>There is no guarantee that this guide will be applicable for newer versions of a Linux kernel or a toolchain.</p>"},{"location":"linux/simulators/vdk/#preface","title":"Preface","text":"<p>This guide is tested on VDK HS38x4 2020.09. VDK itself requires nSIM Pro license. ARC GNU toolchain 2017.09 based on uClibc-ng library is used for building a Linux kernel. Ubuntu 18.04 is used as a host system.</p>"},{"location":"linux/simulators/vdk/#prerequisites","title":"Prerequisites","text":"<p>Install packages for Ubuntu 18.04:</p> <pre><code>sudo apt install xterm libgl1-mesa-dri libsdl1.2debian\n</code></pre>"},{"location":"linux/simulators/vdk/#build-linux-kernel-and-filesystem-image","title":"Build Linux Kernel and Filesystem Image","text":"<p>Clone the latest Buildroot:</p> <pre><code>git clone https://git.busybox.net/buildroot\ncd buildroot\n</code></pre> <p>Filesystem images must not be linked against Linux kernel for running on VDK. Also, <code>vdk_hs38_smp</code> configuration file must be used for the Linux kernel. Create a <code>vdk_defconfig</code> configuration file in <code>configs</code> directory with a correct configuration:</p> <pre><code>BR2_arcle=y\nBR2_archs38=y\nBR2_TOOLCHAIN_EXTERNAL=y\nBR2_TOOLCHAIN_EXTERNAL_CUSTOM=y\nBR2_TOOLCHAIN_EXTERNAL_DOWNLOAD=y\nBR2_TOOLCHAIN_EXTERNAL_URL=\"https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain/releases/download/arc-2017.09-release/arc_gnu_2017.09_prebuilt_uclibc_le_archs_linux_install.tar.gz\"\nBR2_TOOLCHAIN_EXTERNAL_GCC_7=y\nBR2_TOOLCHAIN_EXTERNAL_HEADERS_4_12=y\nBR2_TOOLCHAIN_EXTERNAL_LOCALE=y\nBR2_TOOLCHAIN_EXTERNAL_HAS_SSP=y\nBR2_TOOLCHAIN_EXTERNAL_CXX=y\nBR2_LINUX_KERNEL=y\nBR2_LINUX_KERNEL_CUSTOM_VERSION=y\nBR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE=\"4.9\"\nBR2_LINUX_KERNEL_DEFCONFIG=\"vdk_hs38_smp\"\nBR2_LINUX_KERNEL_VMLINUX=y\nBR2_TARGET_ROOTFS_EXT2=y\n</code></pre> <p>Build images:</p> <pre><code>make vdk_defconfig\nmake\n</code></pre> <p>Linux kernel and filesystem images reside in <code>output/images</code> now:</p> <pre><code>$ ls output/images/\nrootfs.ext2  rootfs.tar  vmlinux\n</code></pre>"},{"location":"linux/simulators/vdk/#running-linux","title":"Running Linux","text":"<p>ARC HS VDK already includes Linux kernel image and root file system image. Save old images and replace them with your newly generated files:</p> <pre><code>cd &lt;VDK-directory&gt;/skins/ARC-Linux\nmv rootfs.ARCv2.ext2{,.orig}\ncp &lt;Buildroot-source-tree&gt;/output/images/rootfs.ext2 rootfs.ARCv2.ext2\nmv ARCv2/vmlinux_smp-noSD{,.orig}\ncp &lt;Buildroot-source-tree&gt;/output/images/vmlinux ARCv2/vmlinux_smp-noSD\n</code></pre> <p>Run a simulator:</p> <pre><code>&lt;VDK-directory&gt;/skins/ARC-Linux/start_interactive.tcl\n</code></pre>"},{"location":"linux/simulators/vdk/#configuring-network","title":"Configuring Network","text":"<p>Before running VDK if you wish to have a working networking connection on Linux for ARC system it is required to configure VDK VHub application. By default this application will pass all Ethernet packets to the VDK Ethernet model, however on busy networks that can be too much to handle in a model, therefore it is highly recommended to configure destination address filtering. Modify <code>VirtualAndRealWorldIO/VHub/vhub.conf</code>: set <code>DestMACFilterEnable</code> to <code>true</code>, and append some random valid MAC address to the list of <code>DestMACFilter</code>, or use one of the MAC address examples in the list. This guide will use <code>D8:D3:85:CF:D5:CE</code> - this address is already in the list. Note that is has been observed that it is not possible to assign some addresses to Ethernet device model in VDK, instead of success there is an error \u201cCannot assign requested address\u201d.</p> <p>Note, that due to the way how VHub application works, it is impossible to connect to the Ethernet model from the host on which it runs on and vice versa. Therefore to use networking in target it is required to either have another host and communicate with it.</p> <p>Run VHub application as <code>root</code>:</p> <pre><code>&lt;VDK-directory&gt;/VirtualAndRealWorldIO/VHub/vhub -f VirtualAndRealWorldIO/VHub/vhub.conf\n</code></pre> <p>In another console launch VDK as a regular user:</p> <pre><code>&lt;VDK-directory&gt;/skins/ARC-Linux/start_interactive.tcl\n</code></pre> <p>After VDK will load, start simulation. After Linux kernel will boot, login into system via UART console: login root, no password. By default networking is switched off. Enable <code>eth0</code> device, configure it is use MAC from address configured in VHub:</p> <pre><code>ifconfig eth0 hw ether d8:d3:85:cf:d5:ce\nifconfig eth0 up\n</code></pre> <p>Linux kernel will emit errors about failed PTP initialization - those are expected. Assign IP address to the target system. This example uses DHCP:</p> <pre><code>udhcpc eth0\n</code></pre> <p>Now it is possible to mount some NFS share and run applications from it:</p> <pre><code>mount -t nfs public-nfs:/home/arc_user/pub /mnt\n/mnt/hello_world\n</code></pre>"},{"location":"platforms/","title":"Development Platforms","text":"<p>Warning</p> <p>This section is under construction.</p>"},{"location":"platforms/digilent/","title":"Installing Digilent Adept","text":"<p>OpenOCD does not use Digilent drivers to communicate with Digilent debug cables. It uses it's own implementation of FTDI MPSSE protocol, which is compatible with FTDI x232 cable. However, you might need to install Digilent Adept drivers and utilities to use some features of Digilent cables.</p> <p>Download an appropriate version of runtime and utilities from Digilent Adept download page. There several options:</p> <ul> <li>Adept for Windows System \u2014 utilities and runtime in a single installer for Windows.</li> <li>Adept for Linux Runtime \u2014 runtime for Linux. <code>rpm</code> and <code>dep</code> packages   are available, as well as a generic <code>.tar.gz</code> archive.</li> <li>Adept Utilities \u2014 utilities for Linux. <code>rpm</code> and <code>dep</code> packages   are available, as well as a generic <code>.tar.gz</code> archive.</li> </ul> <p>You can check, that utilities and runtime are installed correctly using <code>djtgcfg</code> utility:</p> <pre><code>$ djtgcfg enum\n    Found 1 device(s)\n\n    Device: JtagHs2\n        Product Name:   Digilent JTAG-HS2\n        User Name:      JtagHs2\n        Serial Number:  210249810909\n</code></pre>"},{"location":"platforms/get-openocd/","title":"Getting OpenOCD","text":"<p>Warning</p> <p>If you are going to use OpenOCD on Windows, then also follow Installing WinUSB on Windows guide to install WinUSB driver.</p>"},{"location":"platforms/get-openocd/#downloading-a-prebuilt-openocd","title":"Downloading a Prebuilt OpenOCD","text":"<p>The easiest way to obtain OpenOCD is to download Eclipse IDE bundle from the releases page:</p> <ul> <li>For Windows download and install Eclipse IDE bundle with toolchains and OpenOCD.   OpenOCD itself resides in the default installation directory <code>C:\\arc_gnu\\bin</code>.</li> <li>For Linux download and extract Eclipse IDE bundle anywhere. OpenOCD resides in   <code>bin</code> subdirectory.</li> </ul>"},{"location":"platforms/get-openocd/#building-for-linux","title":"Building for Linux","text":"<p>Install prerequisites for Ubuntu 20.04:</p> <pre><code>$ sudo apt-get install libtool git-core build-essential autoconf \\\nautomake texinfo libusb-1.0-0 libusb-1.0-0-dev pkg-config\n</code></pre> <p>Install prerequisites for RHEL/CentOS 7:</p> <pre><code>$ sudo yum install libtool gcc autoconf automake texinfo libusb1 \\\nlibusb1-devel git make which\n</code></pre> <p>Download OpenOCD sources and checkout the latest release:</p> <pre><code>$ git clone -b arc-2021.09 https://github.com/foss-for-synopsys-dwc-arc-processors/openocd\n$ cd openocd\n</code></pre> <p>Configure OpenOCD (use your own <code>--prefix</code> path):</p> <pre><code>$ ./bootstrap\n$ ./configure --enable-ftdi --disable-werror --disable-doxygen-html --prefix=/tools/openocd\n</code></pre> <p>Also, you can pass <code>--enable-verbose</code> and <code>--enable-verbose-jtag-io</code> options for development activities.</p> <p>Build and install:</p> <pre><code>$ make\n$ make install\n</code></pre> <p>Configure your environment (use your own installation path):</p> <pre><code>$ export PATH=/tools/openocd/bin:$PATH\n</code></pre> <p>Finally you need to configure udev rules in such way that OpenOCD would be able to claim your JTAG debug cable. In common case for ARC this is an FTDI-based device. If you already have <code>libftdi</code> package installed on your system, then required rules are already provided to <code>udev</code>. Otherwise create file <code>/etc/udev/rules.d/99-ftdi.rules</code> with the following contents:</p> <pre><code># Digilent HS1 and similiar products\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6010\", MODE=\"0664\", GROUP=\"plugdev\"\n# Digilent HS2\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6014\", MODE=\"0664\", GROUP=\"plugdev\"\n</code></pre> <p>You also can use file <code>contrib/99-openocd.udev</code> supplied with OpenOCD sources, however this file doesn't work with Digilent HS2, though on the other hand it mentions many other FTDI-based devices.</p> <p>Then either reboot your system or reload <code>udev</code> configuration and reconnect debug cable to the host computer:</p> <pre><code>$ sudo udevadm control --reload-rules\n</code></pre>"},{"location":"platforms/get-openocd/#building-for-windows","title":"Building for Windows","text":"<p>It is possible to use OpenOCD on Windows with FTDI-based debug cables using a <code>ftdi</code> interface and <code>libusb</code> driver (further down called <code>ftdi</code>/<code>libusb</code>). Note, however that this requires replacing the original FTDI proprietary drivers with open source ones. This will render Digilent cable unusable by Digilent tools, like Adept.</p> <p>Install the same prerequisites like for Linux build (except for <code>libusb-dev</code>) and MinGW cross-compiler:</p> <pre><code>$ sudo apt-get install libtool git-core build-essential autoconf \\\nautomake texinfo pkg-config wget gcc-mingw-w64\n</code></pre> <p>Download libusb sources sources. Configure and build them with MinGW compiler. It is recommended to build only static <code>libusb</code>, so that OpenOCD will not need this library's <code>.dll</code> file to be copied around:</p> <pre><code>$ wget https://github.com/libusb/libusb/releases/download/v1.0.26/libusb-1.0.26.tar.bz2\n$ tar -xaf libusb-1.0.26.tar.bz2\n$ cd libusb-1.0.26\n$ ./configure --host=i686-w64-mingw32 --build=x86_64-linux-gnu \\\n--prefix=/tools/libusb-mingw --disable-shared --enable-static\n$ make\n$ make install\n</code></pre> <p>Download OpenOCD sources:</p> <pre><code>$ git clone -b arc-2021.09 https://github.com/foss-for-synopsys-dwc-arc-processors/openocd\n$ cd openocd\n</code></pre> <p>Configure OpenOCD. Consult <code>configure --help</code> and generic OpenOCD documentation for details. This command line is recommended for ARC with <code>libusb</code>/<code>ftdi</code>:</p> <pre><code>$ ./bootstrap\n$ PKG_CONFIG_PATH=/tools/libusb-mingw/lib/pkgconfig ./configure \\\n--enable-ftdi --host=i686-w64-mingw32 --build=x86_64-linux-gnu \\\n--disable-werror --prefix=/tools/openocd-mingw\n</code></pre> <p>Note that it is required to set <code>PKG_CONFIG_PATH</code>, otherwise configure script will detect host's <code>libusb</code> installation, instead of the one cross-compiled for Windows.</p> <p>Build and install:</p> <pre><code>$ make\n$ make install\n</code></pre> <p>If your application uses libusb and is being linked dynamically (this is by default), copy <code>/tools/libusb-mingw/bin/libusb-1.0.dll</code> to the OpenOCD bin directory. Copy OpenOCD installation to Window host.</p>"},{"location":"platforms/get-openocd/#building-for-macos","title":"Building for macOS","text":"<p>Warning</p> <p>Ensure that your <code>PATH</code> does not contain GNU binutils binaries, otherwise linkage will fail.</p> <p>Follow README.macOS guide and then README to install OpenOCD for macOS. Additionally, you have to install <code>libftdi</code> (for Homebrew) or <code>libftdi1</code> (for MacPorts) package. Here is a building process for Apple M1 targets:</p> <pre><code>$ git clone -b arc-2021.09 https://github.com/foss-for-synopsys-dwc-arc-processors/openocd\n$ cd openocd\n$ ./bootstrap\n$ CCACHE=none ./configure --enable-ftdi --disable-werror --disable-doxygen-html --prefix=/opt/openocd\n$ make\n$ make install\n</code></pre>"},{"location":"platforms/get-openocd/#running-internal-testsuite","title":"Running internal testsuite","text":"<p>There is a set of internal test for ARC and OpenOCD. This testsuite aim is to catch some issues with OpenOCD, JTAG or hardware. To run test suite: source <code>tcl/test/arc.cfg</code> then run <code>arc_test_run_all</code> procedure, or run tests individually.</p>"},{"location":"platforms/reset/","title":"Resetting Boards","text":""},{"location":"platforms/reset/#using-rff-reset","title":"Using <code>rff-reset</code>","text":"<p>You can use the <code>rff-reset</code> utility to reset ARC development boards. Follow instructions in the <code>rff-rtdi-reset</code> repository to install and use the utility.</p> <p>Here is an example for a case when only one board is connected to the host:</p> <pre><code># rff-reset --only-one\n</code></pre> <p>Here is an example for a case when it's necessary to reset a particular board (Digilent Adept utility is used to obtain a serial number):</p> <pre><code># djtgcfg enum\nFound 1 device(s)\n\nDevice: HSDK-4xD\n    Device Transport Type: 00020001 (USB)\n    Product Name:          DesignWare ARC SDP\n    User Name:             HSDK-4xD\n    Serial Number:         251642000213\n\n# rff-reset --serial 251642000213\n</code></pre>"},{"location":"platforms/reset/#using-openocd","title":"Using OpenOCD","text":"<p>It is possible to reset ARC SDP board without touching the physical button on the board. This can be done using an OpenOCD script:</p> <pre><code>$ openocd -f test/arc/reset_sdp.tcl\n</code></pre> <p>Note that OpenOCD will crash with a segmentation fault after executing this script - this is expected and happens only after board has been reset, but that means that other OpenOCD scripts cannot be used in chain with <code>reset_sdp.tcl</code>, first OpenOCD should be invoked to reset the board, second it should be invoked to run as an actual debugger.</p>"},{"location":"platforms/use-openocd/","title":"Using OpenOCD","text":""},{"location":"platforms/use-openocd/#preface","title":"Preface","text":"<p>OpenOCD is used for connecting to a board and running a GDB server for debugging.</p> <p>Connection host is a host that is connected to the debug target via USB cable and runs OpenOCD. Debug host is a host that runs GDB, which connects to the OpenOCD with TCP connection. Typically it is the same host.</p> <p>Note, that all Synopsys boards a have built-in debug cable. It means that a separate Digilent HS cable is not required for connecting to the board, but only a simple USB cable.</p>"},{"location":"platforms/use-openocd/#running-on-linux","title":"Running on Linux","text":"<p>Run <code>lsusb</code> to ensure that FTDI device is connected to the host. Here is an example for EM Starter Kit 2.2:</p> <pre><code>$ lsusb\nBus 001 Device 002: ID 0403:6010 Future Technology Devices International, Ltd FT2232C/D/H Dual UART/FIFO IC\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\n</code></pre> <p>If you built and installed OpenOCD manually, then you can run it this way:</p> <pre><code>$ openocd -f board/snps_em_sk_v2.2.cfg\nOpen On-Chip Debugger 0.9.0-dev (2023-08-08-15:19)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.sourceforge.net/doc/doxygen/bugs.html\nadapter speed: 5000 kHz\nInfo : clock speed 5000 kHz\nInfo : JTAG tap: arc-em.cpu tap/device found: 0x200044b1 (mfg: 0x258, part: 0x0004, ver: 0x2)\nInfo : JTAG tap: arc-em.cpu tap/device found: 0x200044b1 (mfg: 0x258, part: 0x0004, ver: 0x2)\ntarget state: halted\n</code></pre> <p>If you downloaded IDE bundle with OpenOCD for Linux, then you have to set a path to OpenOCD scripts. You can do it this way (replace <code>&lt;ide&gt;</code> by a path to the directory of IDE bundle):</p> <pre><code>$ &lt;ide&gt;/bin/openocd -s &lt;ide&gt;/share/openocd/scripts -f board/snps_em_sk_v2.2.cfg\n</code></pre> <p>You can find all available configuration files in <code>&lt;openocd&gt;/scripts/board</code> directory (where <code>&lt;openocd&gt;</code> stands for OpenOCD installation directory):</p> <pre><code>$ ls /tools/openocd/share/openocd/scripts/board/snps_* -1\n/tools/openocd/share/openocd/scripts/board/snps_axs101.cfg\n/tools/openocd/share/openocd/scripts/board/snps_axs102.cfg\n/tools/openocd/share/openocd/scripts/board/snps_axs103_hs36.cfg\n/tools/openocd/share/openocd/scripts/board/snps_axs103_hs38.cfg\n/tools/openocd/share/openocd/scripts/board/snps_axs103_hs47D.cfg\n/tools/openocd/share/openocd/scripts/board/snps_axs103_hs48.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk_v1.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk_v2.1.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk_v2.2.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk_v2.2_cjtag.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk_v2.3.cfg\n/tools/openocd/share/openocd/scripts/board/snps_em_sk_v2.3_cjtag.cfg\n/tools/openocd/share/openocd/scripts/board/snps_hsdk.cfg\n/tools/openocd/share/openocd/scripts/board/snps_iotdk.cfg\n</code></pre> <p>Refer to the corresponding section for details.</p> <p>Start a debugger on debug host:</p> <pre><code>$ arc-elf32-gdb application.elf\n</code></pre> <p>Connect to OpenOCD server:</p> <pre><code>(gdb) target remote &lt;connection host ip address&gt;:3333\n</code></pre> <p>If OpenOCD and GDB are running on the same host:</p> <pre><code>(gdb) target remote :3333\n</code></pre> <p>Load image to be debugged (<code>application.elf</code>) into the target memory:</p> <pre><code>(gdb) load\n</code></pre> <p>Set breakpoints at functions main and exit:</p> <pre><code>(gdb) break main\n(gdb) break exit\n</code></pre> <p>Start the execution on target of the image to debug, to reach function main:</p> <pre><code>(gdb) continue\n</code></pre> <p>Resume execution to reach function exit:</p> <pre><code>(gdb) continue\n</code></pre>"},{"location":"platforms/use-openocd/#running-on-windows","title":"Running on Windows","text":"<p>Warning</p> <p>If you are going to use OpenOCD on Windows, firstly follow Installing WinUSB on Windows guide to install WinUSB driver.</p> <p>OpenOCD may be used on Windows the same way it's used on Linux. However, you have  For example, if you downloaded and installed IDE bundle for Windows, then you can run OpenOCD this way:</p> <pre><code>$ C:\\arc_gnu\\bin\\openocd -s C:\\arc_gnu\\share\\openocd\\scripts -f board\\snps_em_sk_v2.2.cfg\n</code></pre>"},{"location":"platforms/use-openocd/#running-on-macos","title":"Running on macOS","text":"<p>Run <code>ioreg</code> application to ensure that FTDI device is there:</p> <pre><code>$ ioreg -p IOUSB -l -w 0\n</code></pre> <p>There should be output like this:</p> <pre><code>Digilent USB Device@14100000  &lt;class AppleUSBDevice, id 0x1000015f7, registered, matched, active, busy 0 (5 ms), retain 21&gt;\n{\n    ...\n}\n</code></pre> <p>OpenOCD may be used on macOS the same way it's used on Linux. However, consider using <code>sudo</code> to get access to USB devices:</p> <pre><code>$ sudo openocd -f board/snps_em_sk_v2.2.cfg\n</code></pre> <p>Note that exact output could differ from host to host.</p> <p>If you're using a USB adapter and have a driver kext matched to it, you will need to unload it prior to running OpenOCD. E.g. with Apple driver (OS X 10.9 or later) for FTDI run:</p> <pre><code>$ sudo kextunload -b com.apple.driver.AppleUSBFTDI\n</code></pre> <p>For FTDI vendor driver use:</p> <pre><code>sudo kextunload FTDIUSBSerialDriver.kext\n</code></pre>"},{"location":"platforms/use-openocd/#advanced-debug-commands","title":"Advanced debug commands","text":"<p>With the GDB <code>monitor</code> command, you have an access to the core without any interference from GDB. With other words, GDB has no notion of changes in core state when using the so called <code>monitor</code> commands (but it is very powerful). In GDB, connect to the OpenOCD target and type following command to get a list of available monitor commands:</p> <pre><code>(gdb) monitor help\n</code></pre> <p>To get a list of some ARC-specific commands, run:</p> <pre><code>(gdb) monitor help arc\n</code></pre> <p>Those are actually internal OpenOCD commands which are also available in configuration scripts and can be passed in OpeOCD command line with <code>-c ...</code> options. Those command allow to enabled some extra features of OpenOCD (disabled by default for one or another reason) or perform some low-level actions bypassing GDB or even OpenOCD. For example it is possible to write/read core and aux registers. However some command for register access will be removed in future, when ARC OpenOCD will fully support flexible register configurations.</p>"},{"location":"platforms/use-openocd/#configurations-files","title":"Configurations Files","text":"<p>Here is a table of configuration files for OpenOCD 0.9:</p> Board OpenOCD configuration HS Development Kit 4x/4xD <code>snps_hsdk_4xd.cfg</code> HS Development Kit <code>snps_hsdk.cfg</code> IoT Development Kit <code>snps_iotdk.cfg</code> EM Software Development Platform \u274c EM Starter Kit 2.3 <code>snps_em_sk_v2.3.cfg</code> EM Starter Kit 2.2 <code>snps_em_sk_v2.2.cfg</code> EM Starter Kit 2.1 <code>snps_em_sk_v2.1.cfg</code> EM Starter Kit 2.0 <code>snps_em_sk_v2.1.cfg</code> EM Starter Kit 1 <code>snps_em_sk_v1.cfg</code> AXS Software Development Platform 101 <code>snps_axs101.cfg</code> AXS Software Development Platform 102 <code>snps_axs102.cfg</code> AXS Software Development Platform 103 with HS36 <code>snps_axs103_hs36.cfg</code> AXS Software Development Platform 103 with HS38 <code>snps_axs103_hs38.cfg</code> AXS Software Development Platform 103 with HS47D <code>snps_axs103_hs47D.cfg</code> AXS Software Development Platform 103 with HS48 <code>snps_axs103_hs48.cfg</code>"},{"location":"platforms/winusb/","title":"Installing WinUSB on Windows","text":"<p>Warning</p> <p>After replacing an original FTDI driver by WinUSB, you cannot use MetaWare Debugger or Digilent Adept utilities with ARC devices.</p>"},{"location":"platforms/winusb/#replacing-ftdi-driver","title":"Replacing FTDI Driver","text":"<p>Before you can start using OpenOCD on Windows, you have to download WinUSB driver and replace with it one of FTDI drivers for your hardware development system. To do that, download Zadig and run it. You should be able to see Digilent Adept USB Device in the list of devices.</p> <p></p> <p>If your device is not shown by Zadig, then click on List all devices in Options.</p> <p>For EM Starter Kit, select Digilent Adept USB Device (Interface 0), choose WinUSB driver and press Replace Driver. Your FTDI driver will be replaced with WinUSB.</p> <p></p> <p>For HS Development Kit, IoT Development Kit, EM SDP and AXS10x SDP, the only thing that differs is that you should select Digilent Adept USB Device (Interface 1).</p> <p>Note that antivirus might complain about drivers files created by Zadig.</p>"},{"location":"platforms/winusb/#restoring-an-original-driver","title":"Restoring an Original Driver","text":"<p>If you want to change driver for your device back for some reason, you can uninstall current driver in \u201cDevices and Printers\u201d and then reconnect your board to the computer, Windows will install the default driver automatically.</p>"},{"location":"simulators/nsim/","title":"nSIM","text":""},{"location":"simulators/nsim/#running-applications","title":"Running Applications","text":"<ul> <li>Building Baremetal Applications and Debugging on nSIM</li> <li>Building Linux and Running on nSIM</li> </ul>"},{"location":"simulators/nsim/#profiling-and-ncam","title":"Profiling and nCAM","text":"<p>You can run nSIM in NCAM mode - Near Cycle-Accurate Mode. This mode activates counters that depend on micro-architectural simulations. It may be a good tool for optimization and exploration. NCAM's model is not cycle-accurate and it's not derived from RTL, but it's much faster than xCAM. If you need a cycle-accurate model then consider using xCAM models.</p> <p>Use <code>-on cycles</code> to enable NCAM:</p> <pre><code>$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on cycles main.elf\n</code></pre> <p>Use <code>-on nsim_print_stats_on_exit</code> and <code>-on ncam_profiling</code> (this option enables more profiling counters) options to print simulation statistics at the end of a simulation:</p> <pre><code>$ arc-elf32-gcc -mcpu=archs -specs=hl.specs main.c -o main.elf\n$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on cycles -on ncam_profiling \\\n          -on nsim_print_stats_on_exit main.elf\n&lt;Main_Memory&gt;\n-------------------------------------------------------------------\n Main Memory          |            Frequency|                    %\n Read                 |                   86|                54.09\n Write                |                   73|                45.91\n-------------------------------------------------------------------\n Total                |                  159|               100.00\n&lt;/Main_Memory&gt;\n&lt;L1-I-CACHE&gt;\n-------------------------------------------------------------------\n L1-I-CACHE           |            Frequency|                    %\n-------------------------------------------------------------------\n Read Hits            |                  770|                94.48\n Read Misses          |                   45|                 5.52\n-------------------------------------------------------------------\n Total                |                  815|               100.00\n&lt;/L1-I-CACHE&gt;\n&lt;L1-D-CACHE&gt;\n-------------------------------------------------------------------\n L1-D-CACHE           |            Frequency|                    %\n-------------------------------------------------------------------\n RW Misses            |                   17|                 4.47\n RW Hits              |                  363|                95.53\n Read Hits            |                   89|                23.42\n Read Misses          |                    1|                 0.26\n Write Hits           |                  274|                94.48\n Write Misses         |                   16|                 4.21\n Dirty Misses         |                    0|                 0.00\n-------------------------------------------------------------------\n Span Lines           |                    2|                 0.53\n Double Miss          |                    0|                 0.00\n-------------------------------------------------------------------\n Total                |                  380|               100.00\n&lt;/L1-D-CACHE&gt;\n&lt;Statistics-Branch_Predictor_FB-GShare&gt;\n Description: FB-GShare Branch Predictor Statistics\n-------------------------------------------------------------------\n BPU (Two-Level)      |            Frequency|                    %\n-------------------------------------------------------------------\n Correctly Predicted  |                  327|                76.05\n Miss Predicted       |                  103|                23.95\n Conditional Misses   |                   26|                25.24\n Uconditional Misses  |                   77|                74.76\n-------------------------------------------------------------------\n Total                |                  430|               100.00\n&lt;/Statistics-Branch_Predictor_FB-GShare&gt;\n\n&lt;Histogram-Instructions&gt;\n-------------------------------------------------------------------\n Instruction          |            Frequency|                    %\n-------------------------------------------------------------------\n stw                  |                  302|                25.44\n nop                  |                  197|                16.60\n mov                  |                  128|                10.78\n...\n neg                  |                    1|                 0.08\n div                  |                    1|                 0.08\n-------------------------------------------------------------------\n Delay Slot           |                   55|                 4.63\n-------------------------------------------------------------------\n Total                |                 1187|               100.00\n&lt;/Histogram-Instructions&gt;\n&lt;Summary-Execution_Profile&gt;\n-------------------------------------------------------------------\n Execution Profile    |            Frequency|                    %\n-------------------------------------------------------------------\n Interpreted Inst     |                 1187|               100.00\n Cond Branches        |                  102|                 8.59\n Cond Branch Mispred  |                   26|                 2.19\n Ucond Branches       |                  121|                10.19\n Ucond Branch Mispred |                   77|                 6.49\n-------------------------------------------------------------------\n Total                |                 1187|               100.00\n&lt;/Summary-Execution_Profile&gt;\n&lt;Summary-Simulation_Time&gt;\n-------------------------------------------------------------------\n Simulation Time      |              Seconds|                    %\n-------------------------------------------------------------------\n Simulation           |               0.0032|                99.72\n Hostlink             |               0.0000|                 0.28\n-------------------------------------------------------------------\n Total                |               0.0032|               100.00\n&lt;/Summary-Simulation_Time&gt;\n&lt;Summary-Simulation_Performance&gt;\n Instruction Count =   1187 [# Total]\n Simulation  Time  =   0.00 [Seconds]\n Simulation  Rate  =   0.38 [MIPS]\n Cycle Count       =   2766 [Cycles]\n CPI               =    2.330\n IPC               =    0.429\n Effective Clock   =   0.9 [MHz]\n&lt;/Summary-Simulation_Performance&gt;\n</code></pre> <p>Use <code>-on nsim_trace</code> and <code>-p nsim_trace-output=trace.txt</code> options to trace instructions (omit <code>nsim_trace-output</code> if you want to print trace log right into <code>stdout</code>):</p> <pre><code>$ nsimdrv -tcf $NSIM_HOME/etc/tcf/templates/hs38_full.tcf -on nsim_trace \\\n          -p nsim_trace-output=trace.txt main.elf\n$ head trace.txt\n\n                nSIM, Version: 2023.03 (Build: 002)\n\n[0x00000124] 0x226a0280                 K       lr             r2,[0xa] : (w0) r2 &lt;= 0x00000000: aux[0x0a] =&gt; 0x00 *\n[0x00000128] 0x224f04c2                 K       bset           r2,r2,0x13 : (w0) r2 &lt;= 0x00080000 *\n[0x0000012c] 0x20290080                 K       flag           r2 *\n[0x00000130] 0x26ab740a 0x00000122   AD K       sr             00000122,0x290: aux[0x290] &lt;= 0x122 *\n[0x00000138] 0x220a3f80 0x00005c10   AD K       mov            gp,00005c10 : (w0) r26 &lt;= 0x00005c10 *\n[0x00000140] 0x42c3     0x00005b20   AD K       mov_s          r2,00005b20 : (w0) r2 &lt;= 0x00005b20 *\n[0x00000146] 0x26027083 0x00005e34   AD K       sub            r3,00005e34,r2 : (w0) r3 &lt;= 0x00000314 *\n</code></pre>"},{"location":"simulators/qemu/","title":"QEMU","text":""},{"location":"simulators/qemu/#running-applications","title":"Running Applications","text":"<ul> <li>Building Baremetal Applications and Debugging on QEMU</li> <li>Building Linux and Running on QEMU</li> </ul>"},{"location":"simulators/qemu/#building-qemu","title":"Building QEMU","text":"<p>Additional packages and plugins</p> <p>Refer to the official documentation for details about installing additional packages and enabling support of QEMU plugins.</p> <p>Install necessary packages for Arch:</p> <pre><code>sudo pacman -S git cmake ninja gperf ccache dfu-util dtc wget            \\\npython-pip python-setuptools python-wheel xz file make\n</code></pre> <p>Install necessary packages for Fedora:</p> <pre><code>sudo dnf group install \"Development Tools\" \"C Development Tools and Libraries\"\ndnf install git cmake ninja-build gperf ccache dfu-util dtc wget         \\\npython3-pip xz file glibc-devel.i686 libstdc++-devel.i686\n</code></pre> <p>Install necessary packages for Ubuntu:</p> <pre><code>sudo apt-get install --no-install-recommends git cmake ninja-build gperf \\\nccache dfu-util device-tree-compiler wget           \\\npython3-pip python3-setuptools python3-wheel        \\\nxz-utils file make gcc gcc-multilib\n</code></pre> <p>Install necessary packages for Void:</p> <pre><code>sudo xbps-install git cmake ninja gperf ccache dfu-util dtc wget  \\\npython3-pip python3-setuptools python3-wheel xz \\\nfile make\n</code></pre> <p>Then prepare sources and a build directory:</p> <pre><code>git clone https://github.com/foss-for-synopsys-dwc-arc-processors/qemu\nmkdir -p qemu/build\ncd qemu/build\n</code></pre> <p>Configure QEMU inside of the build directory (use your own <code>--prefix</code> value for installation path):</p> <pre><code>../configure --target-list=arc-softmmu,arc64-softmmu,arc-linux-user,arc64-linux-user \\\n             --prefix=/tools/qemu --enable-debug --enable-debug-tcg --enable-trace-backends=simple \\\n             --disable-plugins --skip-meson --disable-werror --disable-pie\n</code></pre> <p>What options are responsible for what:</p> <ul> <li><code>--target-list=arc-softmmu,arc64-softmmu,arc-linux-user,arc64-linux-user</code> \u2014 build QEMU both for these targets:</li> <li><code>qemu-system-arc</code> \u2014 system emulation for ARC HS3x/4x/5x processors family;</li> <li><code>qemu-system-arc64</code> \u2014 system emulation for ARC HS6x processors family;</li> <li><code>qemu-arc</code> \u2014 user space Linux emulation for ARC HS3x/4x/5x processors family;</li> <li><code>qemu-arc64</code> \u2014 user space Linux emulation for ARC HS6x processors family.</li> <li><code>--prefix=/tools/qemu</code> \u2014 an installation path.</li> <li><code>--enable-debug --enable-debug-tcg --enable-trace-backends=simple --disable-plugins</code> \u2014 options for development needs.</li> <li><code>--enable-trace-backends=simple</code> \u2014 for tracing (described in [[Profiling with QEMU]]).</li> <li><code>--skip-meson</code> \u2014 do not run Meson on every build.</li> <li><code>--disable-werror</code> \u2014 in case QEMU emits unexpected warnings.</li> <li><code>--disable-pie</code> \u2014 needed for older GCC (like in CentOS 7).</li> </ul> <p>Build and install:</p> <pre><code>make\nmake install\n</code></pre> <p>Configure your environment:</p> <pre><code>export QEMU_HOME=\"/tools/qemu\"\nexport PATH=\"${QEMU_HOME}/bin:$PATH\"\n</code></pre>"},{"location":"simulators/qemu/#enhanced-logging","title":"Enhanced Logging","text":"<p>To enable logging, it is necessary to provide the enabled log levels with the <code>-d</code> flag. Some of the more relevant ones are:</p> <p><pre><code>in_asm          show target assembly code for each compiled TB\nnochain         do not chain compiled TBs so that \"exec\" and \"cpu\" show complete traces\nexec            show trace before each executed TB (lots of logs)\ncpu             show CPU registers before entering a TB (lots of logs)\nfpu             include FPU registers in the 'cpu' logging\nint             show interrupts/exceptions in short format\nmmu             log MMU-related activities\nunimp           log unimplemented functionality\n</code></pre> To get a complete listing, run <code>qemu-system-arc -d help</code>. Use <code>-D &lt;logfile&gt;</code> to dump the logs into a file instead of standard output.</p>"},{"location":"simulators/qemu/#tracing-internals","title":"Tracing Internals","text":"<p>QEMU provides a tracing infrastructure which may help in debugging or analyzing what happens within a simulation cycle. At this moment, there are two tracers added into ARC backend, one for MMU operations, and another for exceptions:</p> <pre><code># mmu.c\nmmu_command(uint32_t address, const char *command, uint32_t pd0, uint32_t pd1) \"[MMU] at 0x%08x, CMD=%s, PD0=0x%08x, PD1=0x%08x\"\n# helper.c\nexcp_info(uint32_t address, const char *name) \"[IRQ] at 0x08, Exception=%s\"\n</code></pre> <p>Firstly, build QEMU with the <code>--enable-trace-backends=simple</code> configure parameter. Then Create a file with the events you want to trace. For example, here is such file with name <code>events.trc</code>:</p> <pre><code>mmu_command\nexcp_info\n</code></pre> <p>Run the virtual machine to produce a trace file:</p> <pre><code>$ qemu-system-arc --trace events=events.trc ...\n</code></pre> <p>Pretty-print the binary trace file (override <code>&lt;pid&gt;</code> with QEMU process id for you session):</p> <pre><code>$ &lt;QEMU-source-tree-path&gt;/scripts/simpletrace.py &lt;QEMU-source-tree-path&gt;/target/arc/trace-events trace-&lt;pid&gt;\n</code></pre>"},{"location":"testing/dejagnu/","title":"Running DejaGNU Tests","text":"<p>Info</p> <p>You can run DejaGNU tests using scripts after building the toolchain using the arc-gnu-toolchain repository.</p>"},{"location":"testing/dejagnu/#prerequisites","title":"Prerequisites","text":"<p><code>toolchain</code> repository contains DejaGNU scripts for ARC. <code>newlib</code> and <code>gcc</code> repositories contain corresponding tests. Prepare an environment for running DejaGNU tests in a separate working directory (for example, <code>/home/user/dejagnu</code>):</p> <pre><code>mkdir -p /home/user/dejagnu\ncd /home/user/dejagnu\ngit clone https://github.com/foss-for-synopsys-dwc-arc-processors/toolchain\ngit clone https://github.com/foss-for-synopsys-dwc-arc-processors/newlib\ngit clone https://github.com/foss-for-synopsys-dwc-arc-processors/gcc\n</code></pre> <p>Add paths for ARCv1/ARCv2 and ARCv3 toolchains to <code>PATH</code> environment variable:</p> <pre><code>export PATH=\"/tools/arc-elf32/bin:$PATH\"\nexport PATH=\"/tools/arc64-elf/bin:$PATH\"\n</code></pre> <p>Set <code>WORKING_DIR</code> environment variable with path of the working directory for convenience:</p> <pre><code>export WORKING_DIR=\"/home/user/dejagnu\"\n</code></pre> <p>Set environment variables for QEMU simulator:</p> <pre><code>export QEMU_HOME=\"/tools/qemu\"\nexport PATH=\"$QEMU_HOME/bin:$PATH\"\n</code></pre> <p>Set environment variables for nSIM simulator:</p> <pre><code>export NSIM_HOME=\"/tools/mwdt/nSIM/nSIM_64\"\nexport PATH=\"$NSIM_HOME/bin:$PATH\"\nexport SNPSLMD_LICENSE_FILE=\"&lt;your-license-file&gt;\"\n</code></pre> <p>Export multilib options through <code>ARC_MULTILIB_OPTIONS</code> variable (for example, <code>cpu=hs38</code> will be passed to GCC as <code>-mcpu=hs38</code>):</p> <pre><code>export ARC_MULTILIB_OPTIONS=\"cpu=hs38\"\n</code></pre>"},{"location":"testing/dejagnu/#constructing-siteexp-file","title":"Constructing <code>site.exp</code> File","text":"<p><code>site.exp</code> file is a main configuration file for DejaGNU tests. It consists several parts. Firstly, choose a toolchain:</p> Toolchain <code>site.exp</code> ARCv1/ARCv2 <pre><code>set target_triplet arc-unknown-elf32\nset target_alias arc-elf32\n</code></pre> ARCv3 <pre><code>set target_triplet arc64-unknown-elf\nset target_alias arc64-elf\n</code></pre> <p>Choose a simulator:</p> Simulator <code>site.exp</code> nSIM <pre><code>set target_list arc-sim-nsimdrv\n</code></pre> QEMU <pre><code>set target_list arc-sim-qemu\n</code></pre> <p>Choose a tool for testing:</p> Tool <code>site.exp</code> GCC <pre><code>set tool gcc\nset srcdir \"$env(WORKING_DIR)/gcc/gcc/testsuite\"\n</code></pre> Newlib <pre><code>set tool newlib\nset tool_version \"4.3.0\"\nset srcdir \"$env(WORKING_DIR)/newlib/newlib/testsuite\"\n</code></pre> C++ standard library <pre><code>set tool libstdc++\nset baseline_subdir_switch \"--print-multi-directory\"\nset srcdir \"$env(WORKING_DIR)/gcc/libstdc++-v3/testsuite\"\n</code></pre> <p>Set paths to DejaGNU scripts for ARC:</p> <pre><code>set boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu\"\nlappend boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu/baseboards\"\n</code></pre> <p>Set a temporary directory for output files:</p> <pre><code>set tmpdir \"$env(WORKING_DIR)/tmp\"\n</code></pre> <p>Set verbosity from 0 to 9:</p> <pre><code>set verbose 0\n</code></pre>"},{"location":"testing/dejagnu/#examples","title":"Examples","text":""},{"location":"testing/dejagnu/#running-newlib-tests-using-qemu-for-arcv2-with-mcpuhs38","title":"Running Newlib tests using QEMU for ARCv2 with <code>-mcpu=hs38</code>","text":"<p>Content of <code>site.exp</code>:</p> <pre><code>set target_triplet arc-unknown-elf32\nset target_alias arc-elf32\nset target_list arc-sim-qemu\n\nset tool newlib\nset tool_version \"4.3.0\"\nset srcdir \"$env(WORKING_DIR)/newlib/newlib/testsuite\"\nset tmpdir \"$env(WORKING_DIR)/tmp\"\nset boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu\"\nlappend boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu/baseboards\"\nset verbose 0\n</code></pre> <p>Running tests:</p> <pre><code>export QEMU_HOME=\"/tools/qemu\"\nexport PATH=\"$QEMU_HOME/bin:$PATH\"\nexport ARC_MULTILIB_OPTIONS=\"cpu=hs38\"\nexport WORKING_DIR=$(dirname \"$0\")\nexport PATH=\"/tools/arc-elf32:$PATH\"\nmkdir -p $WORKING_DIR/tmp\n\nruntest\n</code></pre> <p>An example of output:</p> <pre><code>Using ./newlib/newlib/testsuite/lib/newlib.exp as tool init file.\nTest run by ykolerov on Wed Aug  9 14:14:10 2023\nTarget is arc-unknown-elf32\nHost   is x86_64-pc-linux-gnu\n\n                === newlib tests ===\n\nSchedule of variations:\n    arc-sim-qemu\n\nRunning target arc-sim-qemu\nUsing ./toolchain/dejagnu/baseboards/arc-sim-qemu.exp as board description file for target.\nUsing /usr/share/dejagnu/config/sim.exp as generic interface file for target.\nUsing /usr/share/dejagnu/baseboards/basic-sim.exp as board description file for target.\nUsing ./newlib/newlib/testsuite/config/default.exp as tool-and-target-specific interface file.\nRunning ./newlib/newlib/testsuite/newlib.elix/elix.exp ...\nRunning ./newlib/newlib/testsuite/newlib.iconv/iconv.exp ...\nRunning ./newlib/newlib/testsuite/newlib.locale/UTF-8.exp ...\nFAIL: newlib.locale/UTF-8.c output\nRunning ./newlib/newlib/testsuite/newlib.locale/locale.exp ...\nRunning ./newlib/newlib/testsuite/newlib.search/hsearchtest.exp ...\nRunning ./newlib/newlib/testsuite/newlib.stdio/stdio.exp ...\nRunning ./newlib/newlib/testsuite/newlib.stdlib/atexit.exp ...\nRunning ./newlib/newlib/testsuite/newlib.stdlib/stdlib.exp ...\nRunning ./newlib/newlib/testsuite/newlib.string/string.exp ...\nRunning ./newlib/newlib/testsuite/newlib.time/time.exp ...\nRunning ./newlib/newlib/testsuite/newlib.wctype/wctype.exp ...\nFAIL: newlib.wctype/twctype.c compilation\nFAIL: newlib.wctype/twctrans.c compilation\n\n                === newlib Summary ===\n\n# of expected passes            29\n# of unexpected failures        3\n# of unresolved testcases       2\n</code></pre>"},{"location":"testing/dejagnu/#running-gcc-tests-using-nsim-for-arcv3-with-mcpuhs68","title":"Running GCC tests using nSIM for ARCv3 with <code>-mcpu=hs68</code>","text":"<pre><code>set target_triplet arc64-unknown-elf\nset target_alias arc64-elf\nset target_list arc-sim-nsimdrv\n\nset tool gcc\nset srcdir \"$env(WORKING_DIR)/gcc/gcc/testsuite\"\nset tmpdir \"$env(WORKING_DIR)/tmp\"\nset boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu\"\nlappend boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu/baseboards\"\nset verbose 0\n</code></pre> <p>Running tests:</p> <pre><code>export NSIM_HOME=\"/tools/mwdt/nSIM/nSIM_64\"\nexport PATH=\"$NSIM_HOME:$PATH\"\nexport SNPSLMD_LICENSE_FILE=\"&lt;your-license-file&gt;\"\nexport ARC_MULTILIB_OPTIONS=\"cpu=hs68\"\nexport WORKING_DIR=$(dirname \"$0\")\nexport PATH=\"/tools/toolchains/arc64-elf:$PATH\"\nmkdir -p $WORKING_DIR/tmp\n\nruntest\n</code></pre>"},{"location":"testing/dejagnu/#compatibility-tests","title":"Compatibility Tests","text":"<p>GCC contains a set of compatibility tests named <code>compat.exp</code>. It allows to test compatibility of GCC with different compilers.</p> <p>If you want to run these tests it is necessary to configure additional variables in site.exp file: </p> <pre><code># Enable compatibility tests\nset is_gcc_compat_suite \"1\"\n# A different compiler is used (for example, clang-based)\nset compat_same_alt \"0\"\n# Flags to be used by both compilers\nset TEST_ALWAYS_FLAGS  \"$env(TEST_ALWAYS_FLAGS)\"\n# Path to the alternate compiler used for C/C++\nset ALT_CC_UNDER_TEST  \"$env(COMPAT_ALT_PATH)\"\nset ALT_CXX_UNDER_TEST \"$env(COMPAT_ALT_PATH)\"\n# Flags for gcc and alternate compiler respectively\nset COMPAT_OPTIONS [list [list \"$env(GCC_COMPAT_GCC_OPTIONS)\" \"$env(GCC_COMPAT_CCAC_OPTIONS)\"]]\n# Disable tests with packed structures to avoid unaligned access errors\nset COMPAT_SKIPS [list {ATTRIBUTE}]\n</code></pre> <p>Here is an example of <code>site.exp</code> file for running compatibility tests for GCC and MetaWare CCAC compilers on nSIM simulator for ARC EM family:</p> <pre><code>set target_triplet arc-unknown-elf32\nset target_alias arc-elf32\nset target_list arc-sim-nsimdrv\n\nset tool gcc\nset srcdir \"$env(WORKING_DIR)/gcc/gcc/testsuite\"\nset tmpdir \"$env(WORKING_DIR)/tmp\"\nset boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu\"\nlappend boards_dir \"$env(WORKING_DIR)/toolchain/dejagnu/baseboards\"\nset is_gcc_compat_suite \"1\"\nset compat_same_alt \"0\"\nset TEST_ALWAYS_FLAGS  \"$env(TEST_ALWAYS_FLAGS)\"\nset ALT_CC_UNDER_TEST  \"$env(COMPAT_ALT_PATH)\"\nset ALT_CXX_UNDER_TEST \"$env(COMPAT_ALT_PATH)\"\nset COMPAT_OPTIONS [list [list \"$env(GCC_COMPAT_GCC_OPTIONS)\" \"$env(GCC_COMPAT_CCAC_OPTIONS)\"]]\nset COMPAT_SKIPS [list {ATTRIBUTE}]\nset verbose 0\n</code></pre> <p>Running tests:</p> <pre><code>export NSIM_HOME=\"/tools/mwdt/nSIM/nSIM_64\"\nexport PATH=\"$NSIM_HOME:$PATH\"\nexport SNPSLMD_LICENSE_FILE=\"&lt;your-license-file&gt;\"\nexport WORKING_DIR=$(dirname \"$0\")\nexport PATH=\"/tools/toolchains/arc-elf32:$PATH\"\nexport METAWARE_ROOT=\"/tools/mwdt/MetaWare\"\nexport COMPAT_ALT_PATH=\"$METAWARE_ROOT/arc/bin/ccac\"\nexport TEST_ALWAYS_FLAGS=\"-O0 -g\"\nexport GCC_COMPAT_GCC_OPTIONS=\"-mcpu=em4_dmips -mno-sdata \\\n        -fshort-enums -Wl,-z,muldefs -Wl,--no-warn-mismatch -lgcc -lnsim -lc \\\n        -lg -lm -L$METAWARE_ROOT/arc/lib/av2em/le -lmw\"\nexport GCC_COMPAT_CCAC_OPTIONS=\"-av2em -Xbasecase -Hnocopyr -Hnosdata -fstrict-abi\"\nmkdir -p $WORKING_DIR/tmp\n\nruntest compat.exp\n</code></pre> <p>Options for other targets:</p> <pre><code># ARCv2 HS3x/4x\nexport GCC_COMPAT_GCC_OPTIONS=\"-mcpu=archs ... -L$METAWARE_ROOT/arc/lib/av2hs/le\"\nexport GCC_COMPAT_CCAC_OPTIONS=\"-arcv2hs ...\"\n# ARCv3 HS5x\nexport GCC_COMPAT_GCC_OPTIONS=\"-mcpu=hs5x ... -L$METAWARE_ROOT/arc/lib/av3hs/le\"\nexport GCC_COMPAT_CCAC_OPTIONS=\"-arcv3hs ...\"\n# ARCv3 HS6x\nexport GCC_COMPAT_GCC_OPTIONS=\"-mcpu=hs6x ... -L$METAWARE_ROOT/arc/lib/arc64/le\"\nexport GCC_COMPAT_CCAC_OPTIONS=\"-arc64 ...\"\n</code></pre>"},{"location":"testing/glibc/","title":"Running Glibc Tests","text":""},{"location":"testing/glibc/#standalone-testing","title":"Standalone Testing","text":"<p>It might be useful to perform tests without having to build the entire toolchain.</p> <p>To perform the tests, it is necessary to build glibc like:</p> <pre><code>$ export TOOLCHAIN_SRC=/absolute/path/to/parent                  # Path to parent of ARC sources (at least glibc, toolchain and arc-gnu-toolchain)\n$ export GLIBC_PARENT=/new/empty/directory; cd $GLIBC_PARENT     # We might need to network share this directory, so create a new one\n$ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/glibc;\n$ cd glibc; git checkout arc64                                   # Setup the glibc source we want to test\n$ cd ../; mkdir glibc_build\n$ ../glibc/configure --host=arc64-linux-gnu --prefix=/usr             \\\n--disable-werror --enable-shared --enable-obsolete-rpc                \\\n--with-headers=$TOOLCHAIN_SRC/arc-gnu-toolchain/linux-headers/include \\\n--disable-multilib --libdir=/usr/lib libc_cv_slibdir=/lib             \\\nlibc_cv_rtlddir=/lib CFLAGS=\"-O2 -g3\"\n$ make -j &lt;NMB_CORES&gt;                                            # set NMB_CORES to whatever amount of cores you want \n</code></pre> <p>There are two ways to run the GLIBC tests for ARC. We can use QEMU usermode or full system emulation.</p>"},{"location":"testing/glibc/#user-mode-testing","title":"User mode testing","text":"<p>If you are running a linux host, usermode provides faster but possibly less accurate testing, since it uses the host kernel instead of a fully simulated one.</p>"},{"location":"testing/glibc/#setting-up","title":"Setting up","text":"<p>There are a few ways to set this up but the most direct one is to setup binfmt. Fortunately, QEMU provides a script that sets up binfmt so the launched executables are interpreted by a shell script at <code>/usr/local/qemu-arc64</code>. An example of which is:</p> <pre><code>$ sudo $QEMU_SOURCE/scripts/qemu-binfmt-conf.sh\n$ sudo cat &gt; /usr/local/bin/qemu-arc64 &lt;&lt; 'EOF'\n#!/bin/bash\n${QEMU_BINPATH}/qemu-arc64 -R 4G -L ${TOOLCHAIN_INST}/sysroot -cpu hs6x $@\nEOF\n</code></pre> <p>Afterwards, launching an ARC executable will run this script and consequently, QEMU.</p>"},{"location":"testing/glibc/#running-the-tests","title":"Running the tests","text":"<p>Running the actual tests is simple. <pre><code>$ cd $GLIBC_PARENT/glibc-build\n$ make tests\n</code></pre></p> <p>The results are then stored in <code>*test-result</code> files. See some debugging tips at the end of this wiki entry</p>"},{"location":"testing/glibc/#full-system","title":"Full system","text":"<p>To run the more accurate but `heavier` full system tests, there are a few intermediary steps required.</p>"},{"location":"testing/glibc/#linux-image","title":"Linux image","text":"<p>We will need to generate local ssh keys (<code>ssh-keygen -t ed25519</code>) Then, configure a linux image. The configurations required are:</p> <ol> <li>eth0 configured via dhcp</li> <li>gdbserver, ssh and ftpd</li> <li>User/Network namespace support</li> <li>An overlay file system such that the generated public key is recognized (present inside '~/.ssh/authorized_keys')</li> </ol>"},{"location":"testing/glibc/#nfs","title":"NFS","text":"<p>Second, we need to be able to share our build and source directories with the qemu instance that will be running the aforementioned Linux image.</p> <p>There are many ways to do this, but the one contemplated here is NFS. Install and enable it for your respective platform and set up $GLIBC_PARENT as a shared directory.</p>"},{"location":"testing/glibc/#running-the-instance","title":"Running the instance","text":"<p>In a separate terminal, we run the QEMU instance that must stay alive for the entirety of the testing.</p> <pre><code>$ qemu-system-arc64 -M virt -cpu hs6x -nographic -no-reboot -global cpu.freq_hz=50000000 -netdev user,id=net0,hostfwd=tcp::2221-:21,hostfwd=tcp::2222-:22,hostfwd=tcp::2223-:23,hostfwd=tcp::6175-:6175 -device virtio-net-device,netdev=net0 -kernel $PATH_TO_LOADER/glicready_loader\nLinux version 5.16.0-711640-g19e84a74062a (YOUR_USER@YOUR_MACHINE) (arc64-linux-gnu-gcc (ARCv3 ARC64 GNU/Linux f2bc3b4c762) 12.2.1 20220829, GNU ld (GNU Binutils) 2.40.50.20230314) #11 PREEMPT Tue May 9 10:32:00 WEST 2054\nMemory @ 80000000 [1024M] Memory @ 100000000 [1024M] Not used\nOF: fdt: Machine model: snps,zebu_hs\nearlycon: uart8250 at MMIO32 0x00000000f0000000 (options '115200n8')\nprintk: bootconsole [uart8250] enabled\n\n...\n\nWelcome to Buildroot\nbuildroot login: root\n# # Mount the network folders\n# export SHARED_DIR=/same/absolute/path/as/for/GLIBC_PARENT\n# mkdir -p $SHARED_DIR\n# mount -t nfs -o nolock 10.0.2.2:$SHARED_DIR $SHARED_DIR\n</code></pre> <p>We can test the connection with:</p> <pre><code>$ ssh -p 2222 root@127.0.0.1\nThe authenticity of host '[127.0.0.1]:2222 ([127.0.0.1]:2222)' cant be established.\nED25519 key fingerprint is SHA256:jbqautMkwc2FSBo4c89RKpTDjaSDlmQ3dGk+TrWOCjo.\nThis key is not known by any other names.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '[127.0.0.1]:2222' (ED25519) to the list of known hosts.\n# exit\nConnection to 127.0.0.1 closed.\n$\n</code></pre>"},{"location":"testing/glibc/#setting-up-the-tests","title":"Setting up the tests","text":"<p>For the tests to automatically run without entering the password for each one, we must setup an ssh host with the keys shared with the linux image</p> <pre><code>$ cat ~/.ssh/config\n...\nHOST arcglibc\n    HostName 127.0.0.1\n    User root\n    Port 2222\nIdentityFile ~/.ssh/id_ed25519\n    HostKeyAlgorithms ssh-ed25519\n...\n$\n</code></pre>"},{"location":"testing/glibc/#running-the-tests_1","title":"Running the tests","text":"<p>With the QEMU instance running, now we can run the actual tests.</p> <pre><code>$ cd $GLIBC_PARENT/glibc-build\n$ make test-wrapper=\"/absolute/path/to/shared/glibc/scripts/cross-test-ssh.sh --timeoutfactor 30 arcglibc\" tests\n</code></pre> <p>The results are then stored in <code>*test-result</code> files.</p>"},{"location":"testing/glibc/#debugging-in-full-system","title":"Debugging in full system","text":"<p>In full system it is not a good idea to use QEMUs' gdbstub unless we want to debug the whole kernel. As such we must use the gdbserver packaged in with the linux image:</p> <pre><code># gdbserver 127.0.0.1:6175 $SHARED_DIR/glibc-build/math/test-float-tgamma\n</code></pre> <p>And then we simply connect GDB</p> <pre><code>$ arc64-elf-gdb $GLIBC_PARENT/glibc-build/math/test-float-tgamma\n(gdb) target remote:6175\n</code></pre> <p>If there is any problem running the image, <code>Ctrl+A X</code> can be used to kill QEMU After an instance has run, we might get the following error which will crash the tests. It is best to run the <code>ssh-keygen</code> command below after stopping QEMU to prevent it.</p> <pre><code>$ ssh -p 2222 root@127.0.0.1\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                        @    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ED25519 key sent by the remote host is\nSHA256:jbqautMkwc2FSBo4c89RKpTDjaSDlmQ3dGk+TrWOCjo.\nPlease contact your system administrator.\nAdd correct host key in /home/YOUR_USER/.ssh/known_hosts to get rid of this message.\nOffending ED25519 key in /home/YOUR_USER/.ssh/known_hosts:16\nHost key for [127.0.0.1]:2222 has changed and you have requested strict checking.\nHost key verification failed.\n$ ssh-keygen -f \"/home/YOUR_USER/.ssh/known_hosts\" -R \"[127.0.0.1]:2222\"\n# Host [127.0.0.1]:2222 found: line 160\n/home/YOUR_USER/.ssh/known_hosts updated.\nOriginal contents retained as /home/YOUR_USER/.ssh/known_hosts.old\n</code></pre> <p>See more debugging tips below</p>"},{"location":"testing/glibc/#general-debugging-tips","title":"General debugging tips","text":""},{"location":"testing/glibc/#single-test","title":"Single test","text":"<p>You can run a single test by replacing 'tests' with the test /, i.e. 'test t=math/test-double-trunc'"},{"location":"testing/glibc/#single-group-of-tests","title":"Single group of tests","text":"<p>You can run a single group of tests by adding 'subdirs='' after 'tests', i.e.  'tests subdirs=math'"},{"location":"testing/qemu/","title":"Running QEMU Tests","text":"<p>TCG is the internal language that powers QEMU. There are some assembly tests that validate the basic function of several instructions in QEMU.</p> <p>Firstly, make sure that QEMU if configured with <code>--cross-cc-arc=arc-elf32-gcc</code> and <code>--cross-cc-arc64=arc64-elf-gcc</code> options. Then after building QEMU use these commands to run TCG tests:</p> <pre><code>make clean-tcg\nmake build-tcg\nmake check-tcg\n</code></pre>"}]}